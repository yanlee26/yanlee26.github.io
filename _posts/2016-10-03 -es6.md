---
date: 2016-10-03 
layout: post
title: ES6/ES7总结分析
thread: 9
categories: JS
tags: [ES6]
excerpt: ES6/ES7总结分析.
---

# ECMAScript 6 

## Introduction

>ECMAScript 6, also known as ECMAScript 2015, is the latest version of the ECMAScript
 standard.  ES6 is a significant update to the language, and the first update to 
 the language since ES5 was standardized in 2009. Implementation of these features
 in major  engines is [underway now(支持情况一览)](http://kangax.github.io/es5-compat-table/es6/).

See the [ES6 standard（ES6规范）](http://www.ecma-international.org/ecma-262/6.0/) for full specification of the ECMAScript 6 language.

### ES6 includes the following new features---新特性如下:

0. let + const
1. arrows箭头函数
5. destructuring解耦
3. enhanced string literals字符串的扩展
3. enhanced regular expression正则的扩展
3. enhanced number expression数值的扩展
3. enhanced array expression数组的扩展
3. enhanced function expression函数的扩展
3. enhanced object literals对象的扩展
15. symbols标记
13. map + set
14. proxies代理
20. reflect
17. promises
8. iterators迭代器 + for..of
9. generators
9. async函数
9. class
21. decorator
11. modules
12. module loaders

16. subclassable built-ins
18. typed arrays
22. internationalization-localization国际及地域化
22. SIMD
22. Good Practise

## ECMAScript 6 Features

###  Let + Const

>Block-scoped binding constructs.  ```let``` is the new ```var```(块级作用域绑定结构，let是新的var). 
```const```is single-assignment.  Static restrictions prevent use before assignment
（const 是单一声明，严格模式限制其必须先声明再使用）.

```
//ES6
const PI=3.1415926;
let callbacks = []
for (let i = 0; i <= 2; i++) {
    callbacks[i] = function () { return i * 2 }
}
callbacks[0]() === 0;
//block-scoped functions
{
    function foo () { return 1 }
    foo() === 1
    {
        function foo () { return 2 }
        foo() === 2
    }
    foo() === 1
}
//ES5
Object.defineProperty(typeof global === "object" ? global : window, "PI", {
    value:        3.1415926,
    enumerable:   true,
    writable:     false,
    configurable: false
})
var callbacks = [];
for (var i = 0; i <= 2; i++) {
    (function (i) {
        callbacks[i] = function() { return i * 2; };
    })(i);
}
callbacks[0]() === 0;
(function () {
    var foo = function () { return 1; }
    foo() === 1;
    (function () {
        var foo = function () { return 2; }
        foo() === 2;
    })();
    foo() === 1;
})();
```

More MDN info: [let statement](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/let), [const statement](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/const)

###  Destructuring解耦

>Destructuring allows binding using pattern matching, with support for matching arrays and objects(解耦允许绑定模式匹配
，支持数组和对象). 

```
// list matching列表匹配
var [a, , b] = [1,2,3];

// object matching对象匹配
var { op: a, lhs: { op: b }, rhs: c }
       = getASTNode()
var {op, lhs, rhs} = getASTNode()
// Can be used in parameter position用于形参位置
function g({name: x}) {
  console.log(x);
}
g({name: 5})
// Fail-soft destructuring
var [a] = [];
a === undefined;

// Fail-soft destructuring with defaults
var [a = 1] = [];
a === 1;
```

More info: [MDN Destructuring assignment](https://developer.mozilla.org/en-US/docs/Web//Reference/Operators/Destructuring_assignment)

###  enhanced string literals字符串的扩展

1. Unicode编码

>Non-breaking additions to support full Unicode, including new Unicode literal form in strings and 
new RegExp `u` mode to handle code points, as well as new APIs to process strings at the 21bit code points level.  
These additions support building global apps in JS.

```
"𠮷".length === 2
"𠮷".match(/./u)[0].length === 2
"𠮷" === "\uD842\uDFB7"
"𠮷" === "\u{20BB7}"
"𠮷".codePointAt(0) == 0x20BB7
for (let codepoint of "𠮷") console.log(codepoint)
//ES5
"𠮷".length === 2;
"𠮷".match(/(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF][\uD800-\uDBFF][\uDC00-\uDFFF][\uD800-\uDBFF](?![\uDC00-\uDFFF])(?:[^\uD800-\uDBFF]^)[\uDC00-\uDFFF])/)[0].length === 2;
"𠮷" === "\uD842\uDFB7";
//  no equivalent in ES5
//  no equivalent in ES5
//  no equivalent in ES5

```
More info: [MDN RegExp.prototype.unicode](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/RegExp/unicode)

2. Template Strings

>Template strings provide syntactic sugar for constructing strings.  
This is similar to string interpolation features in Perl, Python and more. 
模板字符串为适应的字符串提供了语法糖。这类似于Perl，Python等中的字符串插值功能.

```
// Basic literal string creation
`In  '\n' is a line-feed.`

// Multiline strings
`In  this is
 not legal.`

// String interpolation字符串插值
var name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`

// Construct an HTTP request prefix is used to interpret the replacements and construction
get`http://example.com/foo?bar=${bar + baz}&quux=${quux}`
//ES5
get([ "http://example.com/foo?bar=", "&quux=", "" ],bar + baz, quux);

```

3. codePointAt()

```
var s = '𠮷a';
s.codePointAt(0) // 134071
s.codePointAt(1) // 57271
s.codePointAt(2) // 97
```

4. string.fromCodePoint() 从码点返回对应字符

```
String.fromCodePoint(0x20BB7)
// "𠮷"
```

5. 遍历

```
for (let codePoint of 'foo') {
  console.log(codePoint)
}
```

6. at() 返回字符串给定位置的字符

```
'abc'.at(0) // "a"
```

7. normalize()

> ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。

```
'\u01D1'.normalize() === '\u004F\u030C'.normalize()

```

8. includes(),startWith(),endsWith()

```
var s = 'Hello world!';
s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true
 ```

9. repeat() 

```
'x'.repeat(3) // "xxx"
```

10. padStart(),padEnd()

ES2017 引入了字符串补全长度的功能。

```
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'
'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
```

11. 标签模板

紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。

```
alert`123`
// 等同于
alert(123)
```

12. string.raw()
String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。

```
String.raw`Hi\\n`
// "Hi\\n"
```

13. 局限

模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。

More info: [MDN Template Strings](https://developer.mozilla.org/en-US/docs/Web//Reference/template_strings)

###  enhanced regular expression正则的扩展

> 保持匹配之间的匹配位置粘性，并且以这种方式支持对任意长输入字符串的有效解析，即使具有任意数量的不同的正则表达式。

1. RegExp构造函数
ES5中，按参数类型正则分两种情况：字符串/正则表达式

```
var regex=new RegExp('xyz',i);//var regex=/xyz/i;
var regex=new RegExp(/xyz/i);//var regex=/xyz/i;
```

ES6中，RegExp构造函数首个参数是正则对象，次个参数可以指定修饰符且以次个参数修饰符为准

```
new RegExp(/abc/ig, 'i').flags
```

2. 字符串的正则方法

```
String.prototype.match // RegExp.prototype[Symbol.match]
String.prototype.replace // RegExp.prototype[Symbol.replace]
String.prototype.search //RegExp.prototype[Symbol.search]
String.prototype.split // RegExp.prototype[Symbol.split]
```

3. u修饰符
4. y修饰符
实例

```
let parser = (input, match) => {
    for (let pos = 0, lastPos = input.length; pos < lastPos; ) {
        for (let i = 0; i < match.length; i++) {
            match[i].pattern.lastIndex = pos
            let found
            if ((found = match[i].pattern.exec(input)) !== null) {
                match[i].action(found)
                pos = match[i].pattern.lastIndex
                break
            }
        }
    }
}

let report = (match) => {
    console.log(JSON.stringify(match))
}
parser("Foo 1 Bar 7 Baz 42", [
    { pattern: /^Foo\s+(\d+)/y, action: (match) => report(match) },
    { pattern: /^Bar\s+(\d+)/y, action: (match) => report(match) },
    { pattern: /^Baz\s+(\d+)/y, action: (match) => report(match) },
    { pattern: /^\s*/y,         action: (match) => {}            }
])
//ES5
var parser = function (input, match) {
    for (var i, found, inputTmp = input; inputTmp !== ""; ) {
        for (i = 0; i < match.length; i++) {
            if ((found = match[i].pattern.exec(inputTmp)) !== null) {
                match[i].action(found);
                inputTmp = inputTmp.substr(found[0].length);
                break;
            }
        }
    }
}

var report = function (match) {
    console.log(JSON.stringify(match));
};
parser("Foo 1 Bar 7 Baz 42", [
    { pattern: /^Foo\s+(\d+)/, action: function (match) { report(match); } },
    { pattern: /^Bar\s+(\d+)/, action: function (match) { report(match); } },
    { pattern: /^Baz\s+(\d+)/, action: function (match) { report(match); } },
    { pattern: /^\s*/,         action: function (match) {}                 }
]);
```

###  enhanced number expression数值的扩展

1. 二进制八进制

```
0b111110111 === 503 // true   Ob二进制
0o767 === 503 // true Oo八进制
```

2. Number.isFinite(),Number.isNaN()
3. Number.parseInt(),Number.parseFloat()

```
// ES5的写法
parseInt('12.34') // 12
parseFloat('123.45#') // 123.45

// ES6的写法 是逐步减少全局性方法，使得语言逐步模块化。
Number.parseInt('12.34') // 12
Number.parseFloat('123.45#') // 123.45
```

4. Number.isInteger()
5. Number.EPSILON ES6在Number对象上面，新增一个极小的常量Number.EPSILON。
6. Number.isSafeInteger()                 
7. Math对象的扩展

- Math.trunc() 去除一个数的小数部分，返回整数部分。
- Math.sign() 判断一个数到底是正数、负数、还是零。
- Math.cbrt() 立方根。
- Math.clz32() 返回一个数的32位无符号整数形式有多少个前导0。
- Math.imul()方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。
- Math.fround()方法返回一个数的单精度浮点数形式。
- Math.hypot()方法返回所有参数的平方和的平方根。
- 对数方法
    - Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。
    - Math.log1p(x)方法返回1 + x的自然对数
    - Math.log10(x)返回以10为底的x的对数
    - Math.log2(x)返回以2为底的x的对数
- 三角函数
    Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
    Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
    Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
    Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
    Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
    Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）
8. Math.sign()用来判断一个值的正负
9. 指数运算符

```
2 ** 2 // 4
2 ** 3 // 8
```

### enhanced array expression数组的扩展

1. Array.from()

>将类数组（array-like object）与可遍历(literable)对象转化成真数组

```
//兼容性
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();

let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
var arr1=[].slice.call(arrayLike);//ES5
var arr2=Array.from(arrayLike);//ES6

let ps=document.querySelectorAll('p');//NodeList对象
Array.from(ps).forEach(p=>condole.log(p));

function foo(){
    Array.from(arguments);//arguments对象
}
//事实上，部署了Iterator接口的数据结构，Array.from都能将其转为数组
Array.from('hello');//['h', 'e', 'l', 'l', 'o']
let nameSet=new Set(['a','b']);
Array.from(nameSet);//['a','b']
//第二个参数
Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
Array.from([1, , 2, , 3], (n) => n || 0)
// [1, 0, 2, 0, 3]   布尔值为false的成员转为0。
function typesOf () {
  return Array.from(arguments, value => typeof value)
}
typesOf(null, [], NaN)
// ['object', 'object', 'number'] 返回各种类型的数据

```
另辟蹊径 ...也可以将某些数据转为数组

>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是
还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，
都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。

```
function foo(){
    var args=[...arguements];
}
[...document.querySelectorAll('div')];//NodeList
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```
More MDN info:[Array.from()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)

2. Array.of()
为弥补Array()构造函数的不足，将一组值转为数组

```
//hacker
function ArrayOf(){
  return [].slice.call(arguments);
}

Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]

Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```

3. 数组实例的copyWithin()

```
Array.prototype.copyWithin(target, start = 0, end = this.length)
//target（必需）：从该位置开始替换数据
[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]

```

4. find()和findIndex()

```
[1, 4, -5, 10].find((n) => n < 0);//参数为回调函数
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2  返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
[NaN].indexOf(NaN)
// -1  这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足
```

5. fill()

```
//使用给定值填充一个数组
['a', 'b', 'c'].fill(7)
// [7, 7, 7]
new Array(3).fill(7)
// [7, 7, 7]
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```

6. entries(),keys(),values() 都返回一个遍历器对象

```
//keys()对键名的遍历
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1
//values()对键值的遍历
for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'
//entries()对键值对的遍历
for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
//不用for...of手动next遍历
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

7. includes() 某个数组是否包含给定的值

```
[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, NaN].includes(NaN); // true

```

8. 空位
注意，空位不是undefined，一个位置的值等于undefined，
依然是有值的。空位是没有任何值，in运算符可以说明这一点。

```
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
```

ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。
forEach(),filter(),every(),some()跳过空位；map()跳过空位但保留该值
；join(),toString(),将空位视为undefined，而undefined和null被处理成空字符串

ES6明确将空位转为undefined 即不忽略空位

```
Array.from(['a',,'b'])
// [ "a", undefined, "b" ]
[...['a',,'b']]
// [ "a", undefined, "b" ]
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"] 
new Array(3).fill('a') // ["a","a","a"]
let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1
```

>Callee-evaluated default parameter values.  
Turn an array into consecutive arguments in a function call.  
Bind trailing parameters to an array.  
Rest replaces the need for `arguments` and addresses common cases more directly.

```
function f(x, y=12) {
  return x + y;
}
f(3) == 15;
// ES5 y=undefined||12
```

```
function f(x, ...y) {
  return x * y.length;
}
f(3, "hello", true) == 6;
//ES5
"use strict";
function f(x) {
  for (var _len = arguments.length, y = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    y[_key - 1] = arguments[_key];
  }
  return x * y.length;
}
```

```
function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) == 6
var str = "foo"
var chars = [ ...str ] // [ "f", "o", "o" ],ES5 var chars = str.split(""); // [ "f", "o", "o" ]
```

More MDN info: [Default parameters](https://developer.mozilla.org/en-US/docs/Web//Reference/Functions/Default_parameters), [Rest parameters](https://developer.mozilla.org/en-US/docs/Web//Reference/Functions/rest_parameters), [Spread Operator](https://developer.mozilla.org/en-US/docs/Web//Reference/Operators/Spread_operator)

### enhanced function expression函数的扩展

1. 参数默认值

基本用法
```
//ES5
function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}
//ES6,参数默认值是惰性求值的
let m='My'
function log(x, y = m+'World') {
  console.log(x, y);
}
```

结合解耦赋值

```
function fetch(url,{body='',method='GET',headers={} }){
    //...
}
fetch('http://example.com', {})
// "GET"
fetch('http://example.com')
// 报错,函数fetch的第二个参数是一个对象
```

函数的length属性:没有指定默认值的参数个数

```
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

作用域

```
//调用函数f时，参数形成一个单独的作用域
let x = 1;
function f(y = x) {
  let x = 2;
  console.log(y);
}
f() // 1
```
应用

```
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}
foo()
// Error: Missing parameter
```

2. rest 参数

```
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

3. spread...  扩展运算符,好比 rest 参数的逆运算
主要用于函数运算

```
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers) // 42
```
替代数组的apply方法
```
// ES5的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f(...args);
//应用
Math.max.apply(null, [14, 3, 77]);// ES5
Math.max(...[14, 3, 77]);// ES6
Math.max(14, 3, 77);// 等同于

var arr1=[1,2,3],arr2=[4,5];
Array.prototype.push.apply(arr1,arr2);//ES5
arr1.push(...arr2);//ES6
new (Date.bind.apply(Date, [null, 2015, 1, 1]));//ES5
new Date(...[2015, 1, 1]);// ES6
```

扩展运算符应用

1. 数组合并

```
arr1.concat(arr2,arr3);//ES5
[...arr1,...arr2,...arr3];//ES6
```

2. 结合解耦:将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]
```

3.函数返回值

>JS函数只能有一个返回值，如果返回多个值只能将其放入数组或对象中返回

```
var dateFields=readDateFields(datebase);
var d=new Date(...dateFields);
//上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。
```

4. 字符串:将字符串转为真正的数组。

```
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```

5. 实现了Iterator接口的对象

>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。

```
var nodeList = document.querySelectorAll('div');
var array = [...nodeList];

let arrayLike = {
  '0': 'a',
  '1': 'b',
  '2': 'c',
  length: 3
};
let arr = [...arrayLike];
// TypeError: Cannot spread non-iterable object.
//arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。
```

6. Map和Set结构，Generator函数

```
let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);
let arr = [...map.keys()]; // [1, 2, 3]
var go = function*(){
  yield 1;
  yield 2;
  yield 3;
};
[...go()] // [1, 2, 3]
```

4. 严格模式
>ES5中函数内部可设定为严格模式，ES6中规定函数参数一旦使用了默认值，
解耦赋值，或者扩展运算符，那么函数内就不能设定为严格模式。不合理之处在于
函数执行时先执行参数代码再执行函数体代码，而只有执行了函数体代码才知道是否
遵循严格模式。

*为规避之，可以全局设置严格模式或者把函数放于一个IIFE中*
```
  'use strict';
  //or...
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
```

5. name属性：函数的函数名

```
var f = function () {};
f.name // "f"  ES6
const bar = function baz() {};
bar.name // "baz"
(new Function).name // "anonymous"
function foo() {};
foo.bind({}).name // "bound foo"
(function(){}).bind({}).name // "bound "
```

6. 箭头函数

>Arrows are a function shorthand using the `=>` syntax.  They are syntactically similar to
 the related feature in C#, Java 8 and CoffeeScript(和C#，Java8及CoffeeScript类似).  
 They support both statement block bodies as well as expression bodies which return the value of the expression.  
 Unlike functions, arrows share the same lexical `this` as their surrounding code(异于function，箭头函数和其EC
 共享this).

```
// Expression bodies表达式主体
var odds = evens.map(v => v + 1);
var nums = evens.map((v, i) => v + i);
var pairs = evens.map(v => ({even: v, odd: v + 1}));
// Statement bodies声明式主体
nums.forEach(v => {
  if (v % 5 === 0)
    fives.push(v);
});

// Lexical this共享this
this.nums.forEach((v) => {
    if (v % 5 === 0)
        this.fives.push(v)
})
//ES5
odds  = evens.map(function (v) { return v + 1; });
pairs = evens.map(function (v) { return { even: v, odd: v + 1 }; });
nums  = evens.map(function (v, i) { return v + i; });
nums.forEach(function (v) {
   if (v % 5 === 0)
       fives.push(v);
});
//  variant 1
var self = this;
this.nums.forEach(function (v) {
    if (v % 5 === 0)
        self.fives.push(v);
});

//  variant 2
this.nums.forEach(function (v) {
    if (v % 5 === 0)
        this.fives.push(v);
}, this);
```

注意点：

- 函数体内this对象为定义时而非使用时所在的对象
- 不可作为构造函数
- 不可使用arguments对象，可用rest参数代替
- 不可作为generator函数，因不可使用yield命令

箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。

```
var handler = {
  id: '123456',
  init: function() {
    document.addEventListener('click',
      event => this.doSomething(event.type), false);
  },
  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};

function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});
var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
```
More info: [MDN Arrow Functions](https://developer.mozilla.org/en/docs/Web//Reference/Functions/Arrow_functions)

8. 尾调用（tail call，算法层）优化

>Tail Call 函数式编程的重要概念，某个函数最后一步调用的是另一个函数
函数调用会在内存中形成一个调用记录（call frame）,保存调用位置和内部变量等信息

```
//模型
function f(x){
  return g(x);
}
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();
// 等同于
function f() {
  return g(3);
}
f();
// 等同于
g(3);
//注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。
function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}//并未优化
//curring将多参数的函数转换成单参数的形式。
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}
//算法复杂度由O(n)降到O(1)
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}
const factorial = currying(tailFactorial, 1);
factorial(5) // 120
//ES6的默认值
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5) // 120
```

### enhanced object expression对象的扩展

1. 属性的简洁表示

```
var foo='bar';
var baz={foo};//{foo:'bar'},可将对象的属性或方法直接写成变量或函数
function f(x, y) {return {x, y};}
var o={
    method(){},
}
//getter,setter
var cart = {
  _wheels: 4,
  get wheels () {
    return this._wheels;
  },
  set wheels (value) {
    if (value < this._wheels) {
      throw new Error('数值太小了！');
    }
    this._wheels = value;
  }
}
```

2. 属性名表达式

```
//JS定义对象属性方法
obj.foo=true;//一
obj['a'+'bc']=123;//二
var obj={foo:true,abc:123};//ES5
let propKey = 'foo';
//ES6
let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};
obj.hello() // hi
//属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]
const keyA = {a: 1};
const keyB = {b: 2};
const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};
myObject // Object {[object Object]: "valueB"}
```

3. 方法的name属性

```
const person = {
  sayName() {
    console.log('hello!');
  },
};
person.sayName.name   // "sayName"
/*
如果对象的方法使用了取值函数（getter）和存值函数（setter），
则name属性不是在该方法上面，而是该方法的属性的描述对象的
get和set属性上面，返回值是方法名前加上get和set。
*/
const obj = {
  get foo() {},
  set foo(x) {}
};
obj.foo.name
// TypeError: Cannot read property 'name' of undefined
const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
descriptor.get.name // "get foo"
descriptor.set.name // "set foo"

(new Function()).name // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"
//如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
```

4. Object.is()

> ES5中只有==（自动转换数据类型）和===（NaN!=NaN,+0==-0）,ES6中提出
Same-value equality 同值相等

```
Object.is('foo', 'foo');// true
Object.is({}, {});// false
+0 === -0 //true
NaN === NaN // false
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
```

5. Object.assign()

用于对象合并，将源对象(source)所有可枚举属性，复制到目标对象(target)
```
var target={a:1};
var source1={b:2};
var source2={c:3};
Object.assign(target,source1,source2);
target;//{a:1,b:2,c:3}
var obj = {a: 1};
Object.assign(obj) === obj // true,如果只有一个参数，Object.assign会直接返回该参数。
typeof Object.assign(2) // "object" 如果该参数不是对象，则会先转成对象，然后返回。
Object.assign(undefined) // 报错
Object.assign(null) // 报错,由于undefined和null无法转成对象
Object.assign(obj, undefined) === obj // true,如果无法转成对象，就会跳过

var v1 = 'abc';
var v2 = true;
var v3 = 10;
var obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { "0": "a", "1": "b", "2": "c" }
//只有字符串的包装对象，会产生可枚举属性。故除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
Object(true) // {[[PrimitiveValue]]: true}
Object(10)  //  {[[PrimitiveValue]]: 10}
Object('abc') // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}

Object.assign({b: 'c'},
  Object.defineProperty({}, 'invisible', {
    enumerable: false,
    value: 'hello'
  })
)
// { b: 'c' } ，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。

Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })
// { a: 'b', Symbol(c): 'd' }

Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3] ，把数组视为对象。
```

*Object.assign进行的是浅拷贝*

应用：

1. 为对象添加属性

```
class Point{
    constructor(x,y){
        Object.assign(this,{x,y});//将x属性和y属性添加到Point类的对象实例。
    }
}
```

2. 为对象添加方法

```
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
  },
  anotherMethod() {
  }
});
//等同于
SomeClass.prototype.someMethod = function (arg1, arg2) {
};
SomeClass.prototype.anotherMethod = function () {
};
```

3. 克隆对象

```
function clone(origin){
    return Object.assign({},origin);
}//只克隆原始对象自身的值而克隆不了其继承的值
function clone(origin){
    let originProto=Object.getPrototypeOf(origin);
    return Object.assign(Object.create(originProto),origin);
}//不仅克隆本身还克隆其继承的值
```

4.合并对象

```
//将多个对象合并到某个对象
const merge=(target,...source)=>Object.assign(target,...source);
//合并后返回一个新对象
const merge=(...source)=>Object.assign({},...source);
```

5. 为属性指定默认值

```
const DEFAULTS = {
  logLevel: 0,
  outputFormat: 'html'
};

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
```

6.属性的可枚举性：Object.getOwnPropertyDescriptor可以获取该属性的描述对象

```
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
```
*ES5的三个操作会忽略enumerable为false的属性*
- for...in循环:只遍历对象自身*及继承的*可枚举属性
- Object.keys():返回对象自身所有科美居属性的键名
- JSON.stringify():只串行化对象自身的可枚举属性
- ES 6中Object.assign()会忽略enumerable为false的属性,只拷贝对象自身可枚举属性
```
Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable
// false
Object.getOwnPropertyDescriptor([], 'length').enumerable
// false
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false,故for...in不会遍历到这两个继承自原型的属性。
//一般我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。
```

7. 属性遍历

  1. for...in :对象自身的和继承的可枚举属性（不含Symbol属性）。
  2. Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。
  3. Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。
  4. Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。
  5. Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。

```
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
//遍历顺序：数值>字符串>Symbol
```

8. __proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()

> __proto__读取或设置对象的prototype对象，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性
后边几个替代之

```
Object.getPrototypeOf({ __proto__: null })
// null,设置了__proto__属性的对象，其值既是对象的原型
// 格式, ES6 正式推荐
Object.setPrototypeOf(object, prototype);
Object.getPrototypeOf(obj);
// 用法
var o = Object.setPrototypeOf({}, null);
function Rectangle() {
  // ...
}
var rec = new Rectangle();
Object.getPrototypeOf(rec) === Rectangle.prototype
// true
Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
```

9. Object.keys(),Object.values(),Object.entries()

10. 对象的扩展运算符

  1. 解耦
  ```
  let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
  x // 1
  y // 2
  z // { a: 3, b: 4 }
  ```
  2. 扩展运算符
  ```
  let z = { a: 3, b: 4 };
  let n = { ...z };
  n // { a: 3, b: 4 }
  ```
11.  Object.getOwnPropertyDescriptors() 

> 指定对象所有自身属性（非继承属性）的描述对象

```
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
```

12. Null传导运算符(Babel尚未支持)

More info: [MDN Grammar and types: Object literals](https://developer.mozilla.org/en-US/docs/Web//Guide/Grammar_and_types#Object_literals)

### Symbol

1. ES5对象属性名都是容易造成命名冲突的字符串，引入Symbol数据类型从根本上解决了此问题
 
*注意symbol不能用new命令，因为生成Symbol对象是一个原始类型的值，而非对象*

 ```
 let s=Symbol();
 typeof s;//'symbol'
//Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
var s1=Symbol('foo');
s1;//Symbol(foo)
s1.toString();//"Symbol(foo)"
//Symbol函数的参数只是表示对当前 Symbol 值的描述
var s2 = Symbol('foo');
s1 === s2 // false
String(s1);//"Symbol(foo)"
"your symbol is " + s1;//Symbol不能与其它类型值进行运算，但可以显示转为字符串
var sym = Symbol();
Boolean(sym) // true
!sym  // false
if (sym) {
  // ...
}
Number(sym) // TypeError
sym + 2 // TypeError,Symbol值也可以转为布尔值，但是不能转为数值。
```

2. 作为属性名的Symbol

```
var mySymbol=Symbol();
var a={};
a[mySymbol]='hello!';
var a={[mySymbol]:'hello!'};
Object.defineProperty(a,mySymbol,{value:'hello!'});
a[mySymbol];//'hello!'
//Symbol值作为对象属性名时，由于点运算符后面总是字符串不会读取mySymbol作为标识名所指代的那个值不能用点运算符
a.mySymbol='hello!';
a.mySymbol;//'undefined'
a['mySymbol'];//'hello!'
let s = Symbol();
let obj = {
   [s](arg) { ... }
};
obj[s](123);
//实例，常量使用Symbol的好处是任何值都不可能有相同值了，且Symbol值作为属性名时该属性为公有属性
const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();
function getComplement(color) {
  switch (color) {
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_GREEN:
      return COLOR_RED;
    default:
      throw new Error('Undefined color');
    }
```

3. 消除魔术字符串

```
const shapeType = {
  triangle: Symbol()
};
function getArea(shape, options) {
  var area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
```

4. 属性名遍历

> Symbol作为属性名，该属性不会出现在for...in，for...of,Object.keys(),
Object.getOwnPropertyNames(),JSON.stringify()返回，但也不是私有属性，唯有
Object.getOwnPropertySymbols可以获取指定对象的所有Symbol属性名。

```
var obj = {};
var a = Symbol('a');
var b = Symbol('b');
obj[a] = 'Hello';
obj[b] = 'World';
Object.getOwnPropertySymbols(obj);// [Symbol(a), Symbol(b)]
```

5. Symbol.for(),Symbol.keyFor()

More info: [MDN Symbol](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Symbol)

###  Map + Set 

>Efficient data structures for common algorithms.  WeakMaps provides leak-free object-key’d side tables.

1. Set

> ES6新的数据结构之一，类似数组但成员唯一，Set本身是一个构造函数用来生成Set数据结构

```
var set = new Set([1, 2, 3, 4, 4]);
[...set] // [1, 2, 3, 4]
set.size // 4
function divs () {
  return [...document.querySelectorAll('div')];
}
var set = new Set(divs());//or
divs().forEach(div => set.add(div));
set.size // 56
//Set内部，NaN相等而两个对象不等
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}

et.add({});
set.size // 1
set.add({});
set.size // 2
```

Set实例的属性和方法

属性：

- Set.prototype.constructor
- Set.prototype.size

方法

- add(value)
- clear()
- delete(value)
- has(value)

遍历:Set的遍历顺序就是插入顺序

- keys()
- values()
- entries()
- forEach()

Array.from可以将Set结构转为数组

```
var items=new Set([1,2,3,4,5]);
var array=Array.from(items);
[...new Set(arr)]//不失为数组去重的好方法
Array.from(new Set(arr));//不失为数组去重的好方法

let set = new Set(['red', 'green', 'blue']);
for (let item of set.keys()) {
  console.log(item);
}
// red green blue
for (let item of set.values()) {
  console.log(item);
}
// red green blue
for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]

Set.prototype[Symbol.iterator] === Set.prototype.values;//可以省略values方法
// true

```

2. WeakSet

>WeakSet成员只能是弱引用对象，成员不可遍历

3. Map

>JS对象本质是键值对的集合（hash结构），但传统上只能用字符串作键。ES6中
的Map类对象的数据结构使得各种类型的值都可以作键，是一种更完善的hash结构实现

```
var m = new Map();
var o = {p: 'Hello World'};
m.set(o, 'content')
m.get(o) // "content"
m.has(o) // true
m.delete(o) // true
m.has(o) // false

var map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);
map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
```

实例和属性的操作方法

1. size

```
let map = new Map();
map.set('foo', true);
map.set('bar', false);
map.size // 2
```

2. set(key, value)

```
var m = new Map();    
m.set("edition", 6)        // 键是字符串
m.set(262, "standard")     // 键是数值
m.set(undefined, "nah")    // 键是undefined
let map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');
```

3. get(key)

```
var m = new Map();   
var hello = function() {console.log("hello");}
m.set(hello, "Hello ES6!") // 键是函数
m.get(hello)  // Hello ES6!
```

4. has(key)
5. delete(key)
6. clear()

遍历方法同Set
与其它数据结构的互换

  1. 数组

```
let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
new Map([[true, 7], [{foo: 3}, ['abc']]])
// Map {true => 7, Object {foo: 3} => ['abc']}
```

  2. 对象

```
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}   
objToStrMap({yes: true, no: false})
// [ [ 'yes', true ], [ 'no', false ] ]
```

  5. JSON

```
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}   
let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{"yes":true,"no":false}'

function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}    
jsonToStrMap('{"yes":true,"no":false}')
// Map {'yes' => true, 'no' => false}
```

4. WeakMap:只接收不计入GC的对象作为键名

More MDN info: [Map](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Map), [Set](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Set), [WeakMap](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/WeakMap), [WeakSet](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/WeakSet)

###  Proxy代理

>用于修改某些操作的默认行为,等同于在语言层面修改，属于meta programming元编程
即对编程语言编程

```
//Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。
var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});
obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2

```

proxy支持的操作

- get(target, propKey, receiver) 拦截对象属性的读取
- set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
- has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。
- deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。
- ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。
- getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
- defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
- preventExtensions(target)拦截Object.preventExtensions(proxy)，返回一个布尔值。
- getPrototypeOf(target)拦截Object.getPrototypeOf(proxy)，返回一个对象
- isExtensible(target)拦截Object.isExtensible(proxy)，返回一个布尔值。
- setPrototypeOf(target, proto)拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。
- apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
- construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

```
// Proxying a normal object
var target = {};
var handler = {
  get: function (receiver, name) {
    return `Hello, ${name}!`;
  }
};

var p = new Proxy(target, handler);
p.world === 'Hello, world!';
```

```
// Proxying a function object
var target = function () { return 'I am the target'; };
var handler = {
  apply: function (receiver, ...args) {
    return 'I am the proxy';
  }
};

var p = new Proxy(target, handler);
p() === 'I am the proxy';
```

There are traps available for all of the runtime-level meta-operations:

```
var handler =
{
  get:...,
  set:...,
  has:...,
  deleteProperty:...,
  apply:...,
  construct:...,
  getOwnPropertyDescriptor:...,
  defineProperty:...,
  getPrototypeOf:...,
  setPrototypeOf:...,
  enumerate:...,
  ownKeys:...,
  preventExtensions:...,
  isExtensible:...
}
```

More info: [MDN Proxy](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Proxy)

###  Reflect

设计目的：

1. 将Object对象一些明显属于语言内部的方法（Object.defineProperty）,放到Reflect对象上
2. 修改某些Object方法的返回结果，让其变得更合理。

>如，Object.defineProperty(obj, name, desc)在无法定义属性时，
    会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
```
//ES5
try{
    Object.defineProperty(target,property,attributes);
}catch(e){}
//ES6
if(Reflect.defineProperty(target,property,attributes)){
//success
}else{//failure}
```

3. 让Object操作都变成函数行为。

>某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)
和Reflect.deleteProperty(obj, name)让它们变成了函数行为。

```
'assign' in Object;//true ES5
Reflect.has(Object,'assign');//true
```

4. Reflect对象的方法与Proxy对象的方法一一对应。

```
var loggedObj = new Proxy(obj, {
  get(target, name) {
    console.log('get', target, name);
    return Reflect.get(target, name);
  },
  deleteProperty(target, name) {
    console.log('delete' + name);
    return Reflect.deleteProperty(target, name);
  },
  has(target, name) {
    console.log('has' + name);
    return Reflect.has(target, name);
  }
});

Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 ES5
Reflect.apply(Math.floor, undefined, [1.75]) // 1
```

2. 静态方法

- Reflect.apply(target,thisArg,args)
- Reflect.construct(target,args)
- Reflect.get(target,name,receiver)
- Reflect.set(target,name,value,receiver)
- Reflect.defineProperty(target,name,desc)
- Reflect.deleteProperty(target,name)
- Reflect.has(target,name)
- Reflect.ownKeys(target)
- Reflect.isExtensible(target)
- Reflect.preventExtensions(target)
- Reflect.getOwnPropertyDescriptor(target, name)
- Reflect.getPrototypeOf(target)
- Reflect.setPrototypeOf(target, prototype)
实例：使用Proxy实现观察者模式

> 函数自动观察数据对象，一旦对象有变化函数变化便自动执行

```
const queuedObservers = new Set();
const observe = fn => queuedObservers.add(fn);
const observable = obj => new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer());
  return result;
}
const person = observable({
  name: '张三',
  age: 20
});
function print() {
  console.log(`${person.name}, ${person.age}`)
}
observe(print);
person.name = '李四';
```

###  Promises

>Promise,简而言之即存放未来才会结束的事件结果的容器。

1. 特点：
    1. 对象状态不受外部影响。
    > Promise代表一个异步操作，有三种状态：Pending(进行中)，Resolved(已完成)和
    Rejected(已失败)。只有异步操作的结果可以决定当前是哪一种状态，也即是Promise名字的由来。
    2. 状态改变就不会再变，任何时候都可以得到该结果。
    >Promise对象状态的改变有两种：从Pending变为Resolved和从Pending变为Rejected。
    只要此二种情况发生就凝固了，结果不会再变。与事件event完全不同（错过了再去监听则得不到结果）

*有了Promise对象即可以同步操作的流程实现异步操作，避免了回调地狱；且Promise对象提供统一接口，简化了异步操作*
缺点是：

- 无法取消Promise，一旦建立则立即执行；
- 如无回调函数，内部抛出错误但外部无反应；
- 当处于Pending时，无法得知目前进行到哪个阶段
- 如某事件不断发生，stream模式则优于Promise

2. 基本用法

> Promise对象是一个构造函数，用来生成Promise实例

```
var promise = new Promise(function(resolve, reject) {
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
//Promise新建后就会立即执行
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});
promise.then(function() {
  console.log('Resolved.');
});
console.log('Hi!');
// Promise
// Hi!
// Resolved
```

实例：实现Ajax

```
var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();

    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });
  return promise;
};
getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});

```

3. Promise.prototype.then()

```
getJSON("/post/1.json").then(
  post => getJSON(post.commentURL)
).then(
  comments => console.log("Resolved: ", comments),
  err => console.log("Rejected: ", err)
);
```

4. Promise.prototype.catch()

```
// 写法一
var promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二,reject方法的作用，等同于抛出错误
var promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
```

5. Promise.all()

> 将多个Promise实例包装成一个新的实例

```
//Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。
var p=Promise.all([p1,p2,p3]);
```

6. Promise.race()
7. Promise.resolve()

>将现有对象转为Promise对象

```
var jsPromise=Promise.resolve($.ajax('/whatever.json'))；
//将jQuery生成的deferred对象，转为一个新的Promise对象
Promise.resolve('foo');
// 等价于但并不等于(异曲同工)
new Promise(resolve => resolve('foo'))
```
8. Promise.reject()
9. 两个附加方法：done(),finally()

>应用

```
function timeout(duration = 0) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, duration);
    })
}

var p = timeout(1000).then(() => {
    return timeout(2000);
}).then(() => {
    throw new Error("hmm");
}).catch(err => {
    return Promise.all([timeout(100), timeout(200)]);
})

//promise combination
function fetchAsync (url, timeout, onData, onError) {
    …
}
let fetchPromised = (url, timeout) => {
    return new Promise((resolve, reject) => {
        fetchAsync(url, timeout, resolve, reject)
    })
}
Promise.all([
    fetchPromised("http://backend/foo.txt", 500),
    fetchPromised("http://backend/bar.txt", 500),
    fetchPromised("http://backend/baz.txt", 500)
]).then((data) => {
    let [ foo, bar, baz ] = data
    console.log(`success: foo=${foo} bar=${bar} baz=${baz}`)
}, (err) => {
    console.log(`error: ${err}`)
})
//ES5
function fetchAsync (url, timeout, onData, onError) {
    …
}
function fetchAll (request, onData, onError) {
    var result = [], results = 0;
    for (var i = 0; i < request.length; i++) {
        result[i] = null;
        (function (i) {
            fetchAsync(request[i].url, request[i].timeout, function (data) {
                result[i] = data;
                if (++results === request.length)
                    onData(result);
            }, onError);
        })(i);
    }
}
fetchAll([
    { url: "http://backend/foo.txt", timeout: 500 },
    { url: "http://backend/bar.txt", timeout: 500 },
    { url: "http://backend/baz.txt", timeout: 500 }
], function (data) {
    var foo = data[0], bar = data[1], baz = data[2];
    console.log("success: foo=" + foo + " bar=" + bar + " baz=" + baz);
}, function (err) {
    console.log("error: " + err);
});
```

More info: [MDN Promise](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Promise)

###  Iterators + For..Of

>Iterator objects enable custom iteration like CLR IEnumerable or Java Iterable(Iterator对象启用自定义迭代，像CLR IEnumerable或Java Iterable。).  
Generalize `for..in` to custom iterator-based iteration with `for..of`.  Don’t require realizing an array, enabling lazy design patterns like LINQ.
JS中集合主要有Array,Object,Map,Set;需要一种统一的接口机制，来处理所有不同的数据结构

Iterator应运而生，其作用有
    
    1. 为各种数据结构提供一个统一的简便的访问接口；
    2. 使得数据结构的成员能够按某种次序排列；
    3. ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供其消费
遍历过程：
   
    1. 创建一个指针对象，指向当前数据结构的起始位置；即遍历器对象的本质是指针对象
    2. 第n次调用指针对象的next方法，将指针指向nth数据成员；
    3. 不断调用指针对象的next方法，直到指向数据结构的结束位置。
```
var it = makeIterator(['a', 'b']);
it.next() // { value: "a", done: false }
it.next() // { value: "b", done: false }
it.next() // { value: undefined, done: true }
function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex < array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
```

2. 数据结构默认Iterator接口

> Iterator是为for...of而生的，当使用for...of时，该循环会自动寻找Iterator接口；一种数据结构只要部署了
Iterator接口即为可遍历的（iterable），ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性。

```
let fibonacci = {
  [Symbol.iterator]() {
    let pre = 0, cur = 1;
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        return { done: false, value: cur }
      }
    }
  }
}
for (var n of fibonacci) {
  // truncate the sequence at 1000
  if (n > 1000)
    break;
  console.log(n);
}
//ES5
var fibonacci = {
    next: (function () {
        var pre = 0, cur = 1;
        return function () {
            tmp = pre;
            pre = cur;
            cur += tmp;
            return cur;
        };
    })()
};

var n;
for (;;) {
    n = fibonacci.next();
    if (n > 1000)
        break;
    console.log(n);
}
```

Iteration is based on these duck-typed interfaces (using [TypeScript](http://typescriptlang.org) type syntax for exposition only):
```
TypeScript
interface IteratorResult {
  done: boolean;
  value: any;
}
interface Iterator {
  next(): IteratorResult;
}
interface Iterable {
  [Symbol.iterator](): Iterator
}
```

3. 调用Iterator接口的场合

- 解耦赋值

```
let set = new Set().add('a').add('b').add('c');
let [x,y] = set;
// x='a'; y='b'
let [first, ...rest] = set;
// first='a'; rest=['b','c'];
```

- 扩展运算符

```
let arr = ['b', 'c'];
['a', ...arr, 'd']
// ['a', 'b', 'c', 'd']

```

- yield*

```
let generator = function* () {
  yield 1;
  yield* [2,3,4];
  yield 5;
};
var iterator = generator();
iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
```

- 其它

```
for...of
Array.from()
Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）
Promise.all()
Promise.race()
```

4. 字符串的Iterator接口

```
var someString = "hi";
typeof someString[Symbol.iterator]
// "function"
var iterator = someString[Symbol.iterator]();
iterator.next()  // { value: "h", done: false }
iterator.next()  // { value: "i", done: false }
iterator.next()  // { value: undefined, done: true }
```

5. Iterator与Generator函数

```
var myIterable = {};

myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable] // [1, 2, 3]
// 或者采用下面的简洁写法
let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};
for (let x of obj) {
  console.log(x);
}
// hello
// world
```

6. 遍历器对象的return()，throw()
7. for...of循环

>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。
 
与其它遍历语法比较

- for循环

```
for (var index = 0; index < myArray.length; index++) {
  console.log(myArray[index]);
}
//比较繁琐，故数组内置forEach方法
```

- forEach

```
myArray.forEach(function (value) {
  console.log(value);
});
//无法跳出forEach循环，break,continue也无能为力
```

- for...in循环

```
for (var index in myArray) {
  console.log(myArray[index]);
}
//可以遍历数组键名
```
缺点如下：

    1. 数组的键名是数字，但for...in循环是以字符串作为键名的；
    2. 不仅遍历数字键名，而且还遍历手动添加的其它键，乃至原型链上的键；
    3. 某些情况下，for...in循环以任意顺序遍历键名
总之，for...in循环主要是为遍历对象而设计的，不适用于数组遍历

- for...of循环优点如下，故首选之。

```
for (var n of fibonacci) {
  if (n > 1000)
    break;
  console.log(n);
}
```

  1. 有着for...in循环的简洁语法，但规避了其缺点；
  2. 不同于forEach方法，可以与break，continue，和return配合使用；
  3. 提供了遍历所有数据结构的同意操作接口。

More info: [MDN for...of](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/for...of)

###  Generators

1. 简介

> Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。语法上，Generator函数是一个状态机，
封装了多个内部状态。执行之，会返回一个遍历器对象，即其除了状态机还是一个遍历器生成函数，返回的遍历器对象可依次遍历
其内每个状态。

```
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}
var hw = helloWorldGenerator();
```
yield语句

> Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，
故其实提供了一种可以暂停执行的函数，yield语句即暂停标识。

遍历器next方法运行逻辑如下：

  1. 遇到yield，暂停执行其后操作，并将紧跟在yield后的表达式值作为返回对象的value属性值
  2. 下一次调用next方法时，继续往下执行，直到遇到下一个yield语句。
  3. 如未遇yield语句，就一直运行到函数结束知道return语句为止，并将return语句后的表达式值作为返回对象的value属性值。
  4. 如无return语句则返回对象的value属性值为undefined

yield与return对比

> 同：都能返回紧跟气候的表达式值；异：每次遇到yield函数暂停执行，下次继续从此执行，而return不具位置记忆功能，
一个函数里只能执行一次return但可以执行多次yield语句。Generator函数可以返回一系列的值。

```
function* f() {
  console.log('执行了！')
}
var generator = f();
setTimeout(function () {
  generator.next()
}, 2000);
```

*若f是普通函数，为变量generator赋值便执行。但如f为Generator函数，只有调用next方法时才会执行。
且yield只能用在Generator函数中*

2. next方法的参数

> yield语句本身无返回值（返回undefined），next方法可以带一个被当作上一个yield语句返回值的参数。

3. for...of

>for...of循环可以自动遍历Generator函数时生成的Iterator对象且无需next方法。
```
function* foo(){
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    return 5
}
for(let v of foo()){console.log(v)} //1 2 3 4 
//一旦next方法返回对象的done为true，for...of终止且不含该返回对象
//原生的JavaScript对象没有遍历接口，无法使用for...of循环，Generator函数为其加上接口完成遍历
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for (;;) {
    [prev, curr] = [curr, prev + curr];
    yield curr;
  }
}
for (let n of fibonacci()) {
  if (n > 1000) break;
  console.log(n);
}
/*除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，
它们都可以将Generator函数返回的Iterator对象，作为参数。*/
function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}

// 扩展运算符
[...numbers()] // [1, 2]

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
// 1
// 2
```

4. Generator.prototype.throw()
5. Generator.prototype.return()
6. yield*语句
7. 作为属性的Generator函数

```
let obj = {
  myGeneratorMethod: function* () {
    // ···
  }
};
```

8. Generator函数的this

> Generator函数总是返回一个其实例且继承了其prototype对象上方法的遍历器

```
function* g() {}
g.prototype.hello = function () {
  return 'hi!';
};
let obj = g();
obj instanceof g // true
obj.hello() // 'hi!'
//如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。
function* g() {
  this.a = 11;
}
let obj = g();
obj.a // undefined
```

9. Generator与状态机，前者是后者的最佳结构

```
var ticking = true;
var clock = function() {
  if (ticking)
    console.log('Tick!');
  else
    console.log('Tock!');
  ticking = !ticking;
}
//
var clock = function*() {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
};
```

- Generator与协程(coroutine)

> 协程：协作的线程或函数

10. 应用

- 异步操作的同步化表达

```function* loadUI() {
     showLoadingScreen();
     yield loadUIDataAsynchronously();
     hideLoadingScreen();
   }
   var loader = loadUI();
   // 加载UI
   loader.next()
   
   // 卸载UI
   loader.next()
```

- 控制流管理

```
Promise.resolve(step1)
  .then(step2)
  .then(step3)
  .then(step4)
  .then(function (value4) {
    // Do something with value4
  }, function (error) {
    // Handle any error from step1 through step4
  })
  .done();
  //Generator更优雅
function* longRunningTask(value1) {
  try {
    var value2 = yield step1(value1);
    var value3 = yield step2(value2);
    var value4 = yield step3(value3);
    var value5 = yield step4(value4);
    // Do something with value4
  } catch (e) {
    // Handle any error from step1 through step4
  }
}
```

3. 部署Iterator接口

```
function* iterEntries(obj) {
  let keys = Object.keys(obj);
  for (let i=0; i < keys.length; i++) {
    let key = keys[i];
    yield [key, obj[key]];
  }
}

let myObj = { foo: 3, bar: 7 };

for (let [key, value] of iterEntries(myObj)) {
  console.log(key, value);
}

// foo 3
// bar 7
```

4. 作为数据结构

```
function *doStuff() {
  yield fs.readFile.bind(null, 'hello.txt');
  yield fs.readFile.bind(null, 'world.txt');
  yield fs.readFile.bind(null, 'and-such.txt');
}
```

```//generator function,iterator protocol
let fibonacci = {
    *[Symbol.iterator]() {
        let pre = 0, cur = 1
        for (;;) {
            [ pre, cur ] = [ cur, pre + cur ]
            yield cur
        }
    }
}
for (let n of fibonacci) {
    if (n > 1000)
        break
    console.log(n)
}
//ES5
var fibonacci = {
      next: (function () {
          var pre = 0, cur = 1;
          return function () {
              tmp = pre;
              pre = cur;
              cur += tmp;
              return cur;
          };
      })()
  };
  var n;
  for (;;) {
      n = fibonacci.next();
      if (n > 1000)
          break;
      console.log(n);
  }
```

```
//direct use
function* range (start, end, step) {
    while (start < end) {
        yield start
        start += step
    }
}

for (let i of range(0, 10, 2)) {
    console.log(i) // 0, 2, 4, 6, 8
}
//ES5
function range (start, end, step) {
    var list = [];
    while (start < end) {
        list.push(start);
        start += step;
    }
    return list;
}

var r = range(0, 10, 2);
for (var i = 0; i < r.length; i++) {
    console.log(r[i]); // 0, 2, 4, 6, 8
}
```

```
//generator matching
let fibonacci = function* (numbers) {
    let pre = 0, cur = 1
    while (numbers-- > 0) {
        [ pre, cur ] = [ cur, pre + cur ]
        yield cur
    }
}

for (let n of fibonacci(1000))
    console.log(n)

let numbers = [ ...fibonacci(1000) ]

let [ n1, n2, n3, ...others ] = fibonacci(1000)
```

```
//generator control-flow
function async (proc, ...params) {
    var iterator = proc(...params)
    return new Promise((resolve, reject) => {
        let loop = (value) => {
            let result
            try {
                result = iterator.next(value)
            }
            catch (err) {
                reject(err)
            }
            if (result.done)
                resolve(result.value)
            else if (   typeof result.value      === "object"
                     && typeof result.value.then === "function")
                result.value.then((value) => {
                    loop(value)
                }, (err) => {
                    reject(err)
                })
            else
                loop(result.value)
        }
        loop()
    })
}

//  application-specific asynchronous builder
function makeAsync (text, after) {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve(text), after)
    })
}

//  application-specific asynchronous procedure
async(function* (greeting) {
    let foo = yield makeAsync("foo", 300)
    let bar = yield makeAsync("bar", 200)
    let baz = yield makeAsync("baz", 100)
    return `${greeting} ${foo} ${bar} ${baz}`
}, "Hello").then((msg) => {
    console.log("RESULT:", msg) // "Hello foo bar baz"
})
```

```
//generator methods
class Clz {
    * bar () {
        …
    }
}
let Obj = {
    * foo () {
        …
    }
}
```
The generator interface is (using [TypeScript](http://typescriptlang.org) type syntax for exposition only):

```
//TypeScript
interface Generator extends Iterator {
    next(value?: any): IteratorResult;
    throw(exception: any);
}
```
More info: [MDN Iteration protocols](https://developer.mozilla.org/en-US/docs/Web//Reference/Iteration_protocols)

###  Generator函数的异步应用

> 由于JS的执行环境是单线程的，没有异步编程根本没法用。

1. 传统方法有以下四种

    1. 回调函数
    2. 事件监听
    3. 发布/订阅
    4. Promise 对象

2. 基本概念

- 异步：一个任务不是连续完成的，先执行第一段然后执行其它任务，等做好了准备再回头执行第二段。

>比如读取文件并处理，第一段是向操作系统发出请求，要求读取文件；然后执行其他任务，等到操作系统
返回文件，再接着执行任务第二阶段（处理文件）。不连续的执行即异步，连续即同步。

- 回掉函数：JS对异步编程的实现就是通过回调函数(把任务的第二阶段单独写在一个函数里，等到重新执行该任务
时就直接调用这个函数callback)。

```
fs.readFile('/etc/passwd', 'utf-8', function (err, data) {
  if (err) throw err;
  console.log(data);
});
```
*Node 错误优先原则：执行分两个阶段，首个执行完之后任务所在的EC已经结束，在此抛出错误原来的EC已无法捕捉，
只能当作参数，传入第二段？？？。直观理解就是如果读取文件就出错了那还谈何打印文件，故错误优先*

- Promise

>回调函数本身无问题，问题在于多层嵌套。而Promise对象应运而生，它并非新的语法功能而是一种新的写法，将嵌套改成链式调用。
除此之外并无新意。且其最大的问题是代码冗余，一堆then原来的语义变得不清楚。
```
var readFile = require('fs-readfile-promise');
readFile(fileA)
.then(function (data) {
  console.log(data.toString());
})
.then(function () {
  return readFile(fileB);
})
.then(function (data) {
  console.log(data.toString());
})
.catch(function (err) {
  console.log(err);
});
```

3. Generator函数

>传统编程语言早有异步(多任务)的解决方案，其一叫协程(coroutine)，有点像函数又像线程。
协程A=》A暂停，协程B=》B交还执行权于A，yield命令是两个阶段的分界线。

- Generator函数可以暂停执行和恢复执行，这是它封装异步任务的根本原因。除此之外还有两个特性，
使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。

```
function* gen(x){
  var y = yield x + 2;
  return y;
}
var g = gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
g.throw('出错了');
// 出错了
```

- 异步任务的封装

```
var fetch = require('node-fetch');
function* gen(){
  var url = 'https://api.github.com/users/github';
  var result = yield fetch(url);
  console.log(result.bio);
}
//执行这段代码的方法如下。
var g = gen();
var result = g.next();
result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
/*可以看到，虽然 Generator 函数将异步操作表示得很简洁，
但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。*/
```

4. Thunk函数：自动执行 Generator 函数的一种方法，"传值调用"（call by value）/“传名调用”（call by name）

###  async 函数

> ES7标准引入async函数使异步操作更加方便，本质是Generator函数的语法糖。

```
//Generator函数
var fs = require('fs');
var readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function(error, data) {
      if (error) reject(error);
      resolve(data);
    });
  });
};
var gen = function* () {
  var f1 = yield readFile('/etc/fstab');
  var f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
//async 函数
var asyncReadFile = async function () {
  var f1 = await readFile('/etc/fstab');
  var f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```

*async其实就是将Generator函数的※替换成了async，将yield换成了await*
改进如下：

- 内置执行器

```var result = asyncReadFile();```

- 更好的语义

async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。

- 更广的适用性

co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值
（数值、字符串和布尔值，但这时等同于同步操作）。

- 返回值是Promise

async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。

2. 用法

>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，
等到异步操作完成，再接着执行函数体内后面的语句。
```
function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value)
}
asyncPrint('hello world', 50);
```

3. 语法

- 返回Promise对象

```
async function f() {
  return 'hello world';
}
f().then(v => console.log(v))
// "hello world"
```

- 错误处理

```
async function f() {
  await new Promise(function (resolve, reject) {
    throw new Error('出错了');
  });
}
f()
.then(v => console.log(v))
.catch(e => console.log(e))
// Error：出错了
```

4. async函数的实现原理：将 Generator 函数和自动执行器，包装在一个函数里。

###  Classes

>ES6 classes are a simple sugar over the prototype-based OO pattern(ES6类是基于原型的（Object-Oriented）模式的简单糖).  
Having a single convenient declarative form makes class patterns easier to use, 
and encourages interoperability(互通性).  Classes support prototype-based inheritance, super 
calls,instance and static methods and constructors(支持基于原型的继承，super calls，instance实例及静态方法和构造器).

```
//class definition
class Shape {
    constructor (id, x, y) {
        this.id = id
        this.move(x, y)
    }
    move (x, y) {
        this.x = x
        this.y = y
    }
}
//ES5
var Shape = function (id, x, y) {
    this.id = id;
    this.move(x, y);
};
Shape.prototype.move = function (x, y) {
    this.x = x;
    this.y = y;
};
```
```
//class inheritance
class Rectangle extends Shape {
    constructor (id, x, y, width, height) {
        super(id, x, y)
        this.width  = width
        this.height = height
    }
}
class Circle extends Shape {
    constructor (id, x, y, radius) {
        super(id, x, y)
        this.radius = radius
    }
}
//ES5
var Rectangle = function (id, x, y, width, height) {
    Shape.call(this, id, x, y);
    this.width  = width;
    this.height = height;
};
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;
var Circle = function (id, x, y, radius) {
    Shape.call(this, id, x, y);
    this.radius = radius;
};
Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;
```
```class inheritance from expressions
var aggregation = (baseClass, ...mixins) => {
    let base = class _Combined extends baseClass {
        constructor (...args) {
            super(...args)
            mixins.forEach((mixin) => {
                mixin.prototype.initializer.call(this)
            })
        }
    }
    let copyProps = (target, source) => {
        Object.getOwnPropertyNames(source)
            .concat(Object.getOwnPropertySymbols(source))
            .forEach((prop) => {
            if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))
                return
            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))
        })
    }
    mixins.forEach((mixin) => {
        copyProps(base.prototype, mixin.prototype)
        copyProps(base, mixin)
    })
    return base
}

class Colored {
    initializer ()     { this._color = "white" }
    get color ()       { return this._color }
    set color (v)      { this._color = v }
}

class ZCoord {
    initializer ()     { this._z = 0 }
    get z ()           { return this._z }
    set z (v)          { this._z = v }
}

class Shape {
    constructor (x, y) { this._x = x; this._y = y }
    get x ()           { return this._x }
    set x (v)          { this._x = v }
    get y ()           { return this._y }
    set y (v)          { this._y = v }
}

class Rectangle extends aggregation(Shape, Colored, ZCoord) {}
var rect = new Rectangle(7, 42)
rect.z     = 1000
rect.color = "red"
console.log(rect.x, rect.y, rect.z, rect.color)
//ES5
var aggregation = function (baseClass, mixins) {
    var base = function () {
        baseClass.apply(this, arguments);
        mixins.forEach(function (mixin) {
            mixin.prototype.initializer.call(this);
        }.bind(this));
    };
    base.prototype = Object.create(baseClass.prototype);
    base.prototype.constructor = base;
    var copyProps = function (target, source) {
        Object.getOwnPropertyNames(source).forEach(function (prop) {
            if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))
                return
            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))
        })
    }
    mixins.forEach(function (mixin) {
        copyProps(base.prototype, mixin.prototype);
        copyProps(base, mixin);
    });
    return base;
};

var Colored = function () {};
Colored.prototype = {
    initializer: function ()  { this._color = "white"; },
    getColor:    function ()  { return this._color; },
    setColor:    function (v) { this._color = v; }
};

var ZCoord = function () {};
ZCoord.prototype = {
    initializer: function ()  { this._z = 0; },
    getZ:        function ()  { return this._z; },
    setZ:        function (v) { this._z = v; }
};

var Shape = function (x, y) {
    this._x = x; this._y = y;
};
Shape.prototype = {
    getX: function ()  { return this._x; },
    setX: function (v) { this._x = v; },
    getY: function ()  { return this._y; },
    setY: function (v) { this._y = v; }
}

var _Combined = aggregation(Shape, [ Colored, ZCoord ]);
var Rectangle = function (x, y) {
    _Combined.call(this, x, y);
};
Rectangle.prototype = Object.create(_Combined.prototype);
Rectangle.prototype.constructor = Rectangle;

var rect = new Rectangle(7, 42);
rect.setZ(1000);
rect.setColor("red");
console.log(rect.getX(), rect.getY(),rect.getZ(), rect.getColor());
```
```static members
class Rectangle extends Shape {
    …
    static defaultRectangle () {
        return new Rectangle("default", 0, 0, 100, 100)
    }
}
class Circle extends Shape {
    …
    static defaultCircle () {
        return new Circle("default", 0, 0, 100)
    }
}
var defRectangle = Rectangle.defaultRectangle()
var defCircle    = Circle.defaultCircle()
//ES5
var Rectangle = function (id, x, y, width, height) {
    …
};
Rectangle.defaultRectangle = function () {
    return new Rectangle("default", 0, 0, 100, 100);
};
var Circle = function (id, x, y, width, height) {
    …
};
Circle.defaultCircle = function () {
    return new Circle("default", 0, 0, 100);
};
var defRectangle = Rectangle.defaultRectangle();
var defCircle    = Circle.defaultCircle();
```

```
//getter/setter
class Rectangle {
    constructor (width, height) {
        this._width  = width
        this._height = height
    }
    set width  (width)  { this._width = width               }
    get width  ()       { return this._width                }
    set height (height) { this._height = height             }
    get height ()       { return this._height               }
    get area   ()       { return this._width * this._height }
}
var r = new Rectangle(50, 20)
r.area === 1000
//ES5
var Rectangle = function (width, height) {
    this._width  = width;
    this._height = height;
};
Rectangle.prototype = {
    set width  (width)  { this._width = width;               },
    get width  ()       { return this._width;                },
    set height (height) { this._height = height;             },
    get height ()       { return this._height;               },
    get area   ()       { return this._width * this._height; }
};
var r = new Rectangle(50, 20);
r.area === 1000;
```

- constructor方法

>类的默认方法，通过new关键字生成对象实例时自动调用。一个类必须有constructor方法，如未定义默认添加。
默认返回实例对象(this)，完全可以指定另外一个对象。

```
class Foo {
  constructor() {
    return Object.create(null);
  }
}
new Foo() instanceof Foo
// false,类的构造函数不使用new是无法调用的，这点与普通构造函数的主要区别
```

- 类的实例对象

>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
```
//定义类
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);
point.toString() // (2, 3)
point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
//类的所有实例共享同一个原型对象，同ES5一样
```

- 不存在变量提升
- Class表达式

```
const MyClass = class Me {
  getClassName() {
    return Me.name;
  }
};
//类名为MyClass而非Me,Me只在Class内部代码可用，指代当前类，如果内部没用到可以省略
//使用class关键字可以写出立即执行的Class
let person = new class {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}('张三');

person.sayName(); // "张三"
```

- 私有方法

>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。

- this指向

>类的方法内部如含有this，默认指向类的实例。但必须小心，一旦单独使用可能报错。
类和模块内部默认全是严格模式，name属性总是返回紧跟在class关键字后边的类名。
```
class Logger {
  printName(name = 'there') {
    this.print(`Hello ${name}`);
  }
  print(text) {
    console.log(text);
  }
}
const logger = new Logger();
const { printName } = logger;
printName(); // TypeError: Cannot read property 'print' of undefine
/*printName默认指向Logger实例。若将该方法提出使用，this会指向该方法运行时环境*/
class Logger {
//构造方法中绑定this
  constructor() {
    this.printName = this.printName.bind(this);
  }
//箭头函数
constructor() {
    this.printName = (name = 'there') => {
      this.print(`Hello ${name}`);
    };
  }
}
//使用Proxy，获取方法的时候，自动绑定this
function selfish (target) {
  const cache = new WeakMap();
  const handler = {
    get (target, key) {
      const value = Reflect.get(target, key);
      if (typeof value !== 'function') {
        return value;
      }
      if (!cache.has(value)) {
        cache.set(value, value.bind(target));
      }
      return cache.get(value);
    }
  };
  const proxy = new Proxy(target, handler);
  return proxy;
}
const logger = selfish(new Logger());
```

2. class继承

>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。

```
class ColorPoint extends Point{
 constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```
上述实例中constructor和toString方法都出现了super，表示父类的构造函数，用来新建父类this对象。
子类必须在constructor方法中调用super方法，否则新建实例报错。只因子类无自身this对象，只有继承父类的然后
加工。如不调用super方法子类就得不到this对象。
>ES5的继承实例先造子类实例对象this，然后将父类的方法添加到this上。ES6则完全不同，先造父类实例对象this，然后
再用子类构造函数修改this。

类的prototype属性和__proto__属性
>多数浏览器ES5实现之中，每个对象都有一个指向构造函数的__proto__属性。Class作为构造函数的语法糖，同时拥有prototype和
__proto__属性，故同时存在两条继承链。作为一个对象，子类B的原型（__proto__属性）是父类；作为构造函数，子类B的原型(prototype
属性)是父类的实例。
- 子类的__proto__属性，表示构造函数的继承，总是指向父类；
- 子类prototype属性的__proto__属性，表示方法的继承，指向父类的prototype属性。

```
class A {
}
class B extends A {
}
B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
//原理
// B的实例继承A的实例
Object.setPrototypeOf(B.prototype, A.prototype);
const b = new B();
// B的实例继承A的静态属性
Object.setPrototypeOf(B, A);

Object.setPropertypeOf=function (obj,proto){
    obj.__proto__=proto;
    return obj;
}
```

- Extends 的继承目标

extends关键字后边可以继承多种类型的值，只要被继承者有prototype属性

  1. 子类继承Object类

```
class A extends Object{}
A.__proto__===Objecdt;//true
A.prototype.__proto__=Object.prototype;//true
//A即构造函数Object的复制，A的实例即Object的实例
```

  2. 不存在任何继承

```
class A{}
A.__proto__===Function.prototype;//true
A.prototype.__proto__===Object.prototype;//true
//A作为一个基类(不存在任何继承)，即普通函数故直接继承Function.prototype。
但当A调用后返回一个空对象(Object实例)，故A.prototype.__proto__指向构造函数(Object)的prototype属性。
  ```

  3. 子类集成null

```
class A extends null{}
A.__proto__===Function.prototype;//true
A.prototype.__proto__===undefined;//true
//实际上是
class C extends null {
  constructor() { return Object.create(null); }
}
  ```

- Object.getPropertyOf():从子类获取父类

- super关键字

> 既可以当函数使用也可以当对象使用，但用法完全不同。

  1. 作为函数，代表父类的构造函数,只能用在子类的构造函数中。(ES6规定子类构造函数必须执行一次super函数)

```
class A{}
class B extends A{
    constructor(){
        super();
    }
}
/*super虽然代表了父类A的构造函数，但返回的是子类的实例(super内this指向B)，
此时super()相当于A.prototype.constructor.call(this).*/
```

2. 作为对象，指向父类的原型对象。

```
class A{
    p(){
        return 2;
    }
}
class B extends A{
    constructor(){
        super();
        console.log(super.p());
    }
}
let b=new B();//2
//ES6 规定，通过super调用父类的方法时，super会绑定子类的this。因此super就是this
class A {
  constructor() {
    this.x = 1;
  }
}   
class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined,A.prototype.x
    console.log(this.x); // 3
  }
}  
let b = new B();
/*使用super的时候，必须显式指定是作为函数、还是作为对象;由于对象都是继承其它对象的，
所以可以在任意对象中使用super关键字*/
var obj = {
  toString() {
    return "MyObject: " + super.toString();
  }
};
obj.toString(); // MyObject: [object Object]
```

- 实例的__proto__属性

>子类实例的__proto__属性的__proto__属性，指向父类实例的__prototype__属性。
即子类原型的原型是父类的原型。

```

var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, 'red');
p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true,ColorPoint继承了Point
//通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为
p2.__proto__.__proto__.printName = function () {
  console.log('Ha');
};
p1.printName() // "Ha"
```

3. 原生构造函数的继承---无法继承

- Boolean()
- Number()
- String()
- Array()
- Date()
- Function()
- RegExp()
- Error()
- Object()

4. Class的取值函数getter和存值函数setter
存值函数和取值函数是设置在属性的descriptor对象上的,与ES5完全一致。

```
lass MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+value);
  }
}
let inst = new MyClass();
inst.prop = 123;
// setter: 123
inst.prop
// 'getter'
//prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。
```

5. Class的Generator方法

>某个方法之前加上*即为Generator函数

```
class Foo {
  constructor(...args) {
    this.args = args;
  }
  * [Symbol.iterator]() {
    for (let arg of this.args) {
      yield arg;
    }
  }
}
for (let x of new Foo('hello', 'world')) {
  console.log(x);
}
```

6. Class的静态方法

>类相当于实例的原型，故类中定义的方法都会被实例继承。若在一个方法上加上static关键字
则表示该方法不会被实例继承，而是直接通过类来调用，但可以被子类继承，也可以通过super对象调用所谓的‘静态方法’。

```
class Foo{
    static classMethod(){
        return 'hello';
    }
}
Foo.classMethod();//'hello'
var foo=new Foo();
foo.classMethod();// TypeError: foo.classMethod is not a function
 class Bar extends Foo {
   static classMethod() {
     return super.classMethod() + ', too';
   }
 }
```

7. Class的静态属性和实例属性

>静态属性指Class本身的属性Class.propname,而非定义在实例对象this上的属性。

```
class Foo{
    prop:2//无效
    static prop:2//无效
}
Foo.prop=1;
Foo.prop;//1,只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。
```

ES7提议，Babel支持

```
//类的实例属性可以用等式，写入类的定义之中。
class MyClass {
  myProp = 42;
  constructor() {
    console.log(this.myProp); // 42
  }
}
/*定义实例属性，之前只能写在类的constructor方法里面，如今可以不在。
为了可读性的目的，对于那些在constructor里面已经定义的实例属性，
新写法允许直接列出。*/
class ReactCounter extends React.Component {
  state = {
    count: 0
  };
}
//类的静态属性，只需在实例属性前加上static关键字
class MyClass {
  static myStaticProp = 42;
  constructor() {
    console.log(MyClass.myStaticProp); // 42
  }
```

8. 类的私有属性---提案，为class加了私有属性。方法是在属性名之前，使用#表示。

>之所以引入一个新的#表示私有属性而非private关键字是因为JS是一门动态语言，使用独立符号似乎是唯一
可靠方法，能够准确地区分属性之公私。

```
class Point {
  #x;
  constructor(x = 0) {
    #x = +x;
  }
  get x() { return #x }
  set x(value) { #x = +value }
}
```

9. new.target属性---确定构造函数如何调用的

```
function Person(name) {
  if (new.target !== undefined) {
    this.name = name;
  } else {
    throw new Error('必须使用new生成实例');
  }
}
// 另一种写法
function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用new生成实例');
  }
}
var person = new Person('张三'); // 正确
var notAPerson = Person.call(person, '张三');  // 报错
//Class内调用new.target返回当前Class
```
10. Mixin模式的实现
>将多个类的接口混入(mix in)另一个类

```
function mix(...mixins) {
  class Mix {}

  for (let mixin of mixins) {
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  }
  return Mix;
}
function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== "constructor"
      && key !== "prototype"
      && key !== "name"
    ) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}
class DistributedEdit extends mix(Loggable, Serializable) {
}
```
More info: [MDN Classes](https://developer.mozilla.org/en/docs/Web//Reference/Classes)

###  decorator

>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。

1. 类的修饰
2. 方法的修饰
3. 不能用于函数
4. core-decorators.js
5. 使用修饰器实现自动发布事件
6. mixin混入
7. trait

```
function factorial(n, acc = 1) {
    'use strict';
    if (n <= 1) return acc;
    return factorial(n - 1, n * acc);
}

// Stack overflow in most implementations today,
// but safe on arbitrary inputs in ES6
factorial(100000)
```

###  Modules模块

>Language-level support for modules for component definition.  
Codifies patterns from popular  module loaders (AMD, CommonJS). 
Runtime behaviour defined by a host-defined default loader.  
Implicitly async model – no code executes until requested modules are available and processed.
组件定义的模块的语言级支持。编译流行模块加载程序（AMD，COMMONJS）的模式。
由主机定义的默认加载器定义的运行时行为。隐式异步模型 - 在请求的模块可用并处理之前，不执行代码。
ES6在语言标准层面上实现了模块功能，完全可以取代CommonJS，AMD规范，成为B/S通用的模块解决方案。
模块化设计思想是尽量静态化，使得编译时就能确定模块的依赖关系以及输入和输出的变量。

好处：

  1. 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式；
  2. 将来浏览器的新API就能用模块格式提供，不必做成全局变量或者navigator对象的属性；
  3. 不再需要对象作为命名空间(如Math)，未来这些功能可以通过模块提供。
```
// lib/math.js
export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
```
```
// app.js
import * as math from "lib/math";
alert("2π = " + math.sum(math.pi, math.pi));
```
```
// otherApp.js
import {sum, pi} from "lib/math";
alert("2π = " + sum(pi, pi));
```
Some additional features include `export default` and `export *`:

```
// lib/mathplusplus.js
export * from "lib/math";
export var e = 2.71828182846;
export default function(x) {
    return Math.log(x);
}
```
```
// app.js
import ln, {pi, e} from "lib/mathplusplus";
alert("2π = " + ln(e)*pi*2);
```

2. 严格模式---自动设定为'use strict'
3. export,export default及import命令
4. 模块的整体加载

```
import * as circle from './circle';
console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));
//注意：整体加载的模块所在的那个对象是可以静态分析的，不允许运行时改变
circle.foo = 'hello';//不允许
```

5. 模块的继承

```
// circleplus.js

export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}
```

6. import():按需加载，条件加载，动态模块路径

More MDN info: [import statement](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/import), [export statement](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/export)

###  Module Loaders

1. 浏览器加载

- 传统方法：script引入

> 默认情况下，B是同步加载JS脚本，即渲染引擎遇到script就停下来直到脚本执行完，再继续向下循环。
如果是外部脚本，还必须加入脚本下载时间。

```
//defer:整个页面渲染结束才执行，渲染完再执行；async:一旦下载完，渲染引擎就会中断渲染，执行此脚本后再继续渲染，下载完就执行。
<script src="path/to/myModule.js" defer></script>
<script src="path/to/myModule.js" async></script>
```

- 加载规则：ES6模块也可以使用script标签，但要加入type='module'属性

``` 
<script type="module" src="foo.js">
 import utils from "./utils.js";
</script>
<!-- 等同于 -->
<script type="module" src="foo.js" defer></script>
```
对于外部模块脚本，注意以下几点：

    1. 代码在模块作用域之中运行而非全局，模块内顶层变量外部不可见
    2. 模块脚本自动采用严格模式，无论声明与否；
    3. 模块中可以使用import及export命令处理模块
    4. 模块中，顶层的this关键字返回undefined而非window
    5. 同一个模块如果加载多次，只执行一次

```const isNotModuleScript = this !== undefined;//侦测是否在ES6模块中```

2. ES6模块与CommonJS模块差异

两大重大差异：

- 前者输出的是值的引用，后者是拷贝
- 前者是编译时输出接口，后者是运行时加载

> CommonJS加载的是一个在脚本运行才会生成的对象，而ES6不是对象，其对外接口只是一种静态定义，
在代码静态解析阶段就会生成。ES6的import有点像Unix系统的符号连接，原始值变了，import加载的值也变。
故ES6模块是动态引用，不会缓存值，模块里的变量绑定其所在的模块。

3. Node加载

>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。
目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。

在静态分析阶段，一个模块脚本若含import或export语句，Node便认为其为ES6模块，否则就是CommonJS模块。
若不输出任何接口但希望被认为是ES6模块，可在脚本中加入```export {};//不输出任何脚本的ES6标准写法 ```
ES6模块中顶层的this指向undefined；而CommonJS模块的顶层this指向当前模块。

- import 命令加载CommonJS模块

```
// a.js  CommonJS模块
module.exports = {
  foo: 'hello',
  bar: 'world'
};

// 等同于
export default {
  foo: 'hello',
  bar: 'world'
};
```
- require命令加载ES6模块
>采用require命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。
4. 循环加载circular dependency
- CommonJS模块加载原理
###  Subclassable Built-ins内嵌对象的亚类
>In ES6, built-ins like `Array`, `Date` and DOM `Element`s can be subclassed.
Object construction for a function named `Ctor` now uses two-phases (both virtually dispatched):
- Call `Ctor[@@create]` to allocate the object, installing any special behavior
- Invoke constructor on new instance to initialize
The known `@@create` symbol is available via `Symbol.create`.  Built-ins now expose their `@@create` explicitly.

```
// Pseudo-code of Array
class Array {
    constructor(...args) { /* ... */ }
    static [Symbol.create]() {
    }
}

// User code of Array subclass
class MyArray extends Array {
    constructor(...args) { super(...args); }
}

// Two-phase 'new':
// 1) Call @@create to allocate object
// 2) Invoke constructor on new instance
var arr = new MyArray();
arr[1] = 12;
arr.length == 2
```

###  typed arrays

>支持任意基于字节的数据结构来实现网络协议，加密算法，文件格式操作等。

```
class Example {
    constructor (buffer = new ArrayBuffer(24)) {
        this.buffer = buffer
    }
    set buffer (buffer) {
        this._buffer    = buffer
        this._id        = new Uint32Array (this._buffer,  0,  1)
        this._username  = new Uint8Array  (this._buffer,  4, 16)
        this._amountDue = new Float32Array(this._buffer, 20,  1)
    }
    get buffer ()     { return this._buffer       }
    set id (v)        { this._id[0] = v           }
    get id ()         { return this._id[0]        }
    set username (v)  { this._username[0] = v     }
    get username ()   { return this._username[0]  }
    set amountDue (v) { this._amountDue[0] = v    }
    get amountDue ()  { return this._amountDue[0] }
}

let example = new Example()
example.id = 7
example.username = "John Doe"
example.amountDue = 42.0
```

###  internationalization-localization

>collation整理

```
var list = [ "ä", "a", "z" ]
var l10nDE = new Intl.Collator("de")
var l10nSV = new Intl.Collator("sv")
l10nDE.compare("ä", "z") === -1
l10nSV.compare("ä", "z") === +1
console.log(list.sort(l10nDE.compare)) // [ "a", "ä", "z" ]
console.log(list.sort(l10nSV.compare)) // [ "a", "z", "ä" ]
```

>number formatting

```
var l10nEN = new Intl.NumberFormat("en-US")
var l10nDE = new Intl.NumberFormat("de-DE")
l10nEN.format(1234567.89) === "1,234,567.89"
l10nDE.format(1234567.89) === "1.234.567,89"
```

>current formatting

```
var l10nUSD = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" })
var l10nGBP = new Intl.NumberFormat("en-GB", { style: "currency", currency: "GBP" })
var l10nEUR = new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" })
l10nUSD.format(100200300.40) === "$100,200,300.40"
l10nGBP.format(100200300.40) === "£100,200,300.40"
l10nEUR.format(100200300.40) === "100.200.300,40 €"
```

>date/time formating

```
var l10nEN = new Intl.DateTimeFormat("en-US")
var l10nDE = new Intl.DateTimeFormat("de-DE")
l10nEN.format(new Date("2015-01-02")) === "1/2/2015"
l10nDE.format(new Date("2015-01-02")) === "2.1.2015"
```

###  SIMD

>SIMD（发音/sim-dee/）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。
它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。
与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。

###  Good Practise

1. 块级作用域
    
    1. let取代var
    2. 全局常量和线程安全
    在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量
2. 字符串：``
3. 解耦赋值：首选
4. 对象：单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。
5. 数组：使用扩展运算符配合Array.from方法
6. 函数：
7. Map结构：区分Object和Map，只有模拟现实世界的实体对象采用Object。若是键值对结构首选Map
8. Class :首选
9. 模块：import取代require
10. EsLint使用

### #参考链接

[https://github.com/lukehoban/es6features#readme](https://github.com/lukehoban/es6features#readme)
[http://es6-features.org/#Constants](http://es6-features.org/#Constants)
[http://es6.ruanyifeng.com/](http://es6.ruanyifeng.com/)