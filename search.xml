<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Becoming a Great Web Front-end Developer]]></title>
      <url>https://yanlee26.github.io/2017/01/04/front-end-career/</url>
      <content type="html"><![CDATA[<h1 id="成就一名卓越的前端开发者"><a href="#成就一名卓越的前端开发者" class="headerlink" title="成就一名卓越的前端开发者"></a>成就一名卓越的前端开发者</h1><blockquote>
<p>本文记录了两位工程师为web开发者们所提出的多条建议，其中一位推荐了多种实用的工具与技术，而另一位则对于如何克服浏览器开发时所面临的挑战提出了诸多建议。<br>Rebecca Murphey是来自于Bazaarvoice的一位软件工程师。今年早些时候，她发布了一篇博客文章<a href="http://rmurphey.com/blog/2015/03/23/a-baseline-for-front-end-developers-2015" target="_blank" rel="external">“前端（JS）开发者的基本素质之2015版”</a>，为JavaScript开发者在进行客户端web开发时使用的工具与开发方式提出了一些建议。她在文章的总结中写道：</p>
</blockquote>
<h3 id="1-学习ECMAScript-2015"><a href="#1-学习ECMAScript-2015" class="headerlink" title="1. 学习ECMAScript 2015"></a>1. 学习ECMAScript 2015</h3><p>推荐的参考资料有：<a href="https://www.infoq.com/news/2015/06/ecmascript-2015-es6" target="_blank" rel="external">《Understanding ES6》</a>、ES6 Rocks以及BabelJS。我们在此还要加上一条，即Axel Rauschmayer的著作<a href="http://www.infoq.com/cn/news/2015/07/exploring-es6" target="_blank" rel="external">《探索ES6》</a>。考虑到在当前这个时间点上似乎还没有必要了解ECMAScript 2015的所有细节，Murphey建议开发者更深入地了解如何使用异步调用、回调以及promise。</p>
<p>###2.使用模块。<br>Murphey相信，模块毫无疑问应当作为客户端web应用程序的构建块。她最近在使用webpack以实现模块化的效果，但她希望让每个人都能够使用ECMAScript标准模块的那一天能够早日到来。</p>
<p>###3.测试你的代码。<br>在Murphey看来，为你的代码编写测试，并且保证代码的可测试性是至关重要的。<br>虽然她对于Intern“非常中意”，但出于习惯，她还是坚持使用Mocha。关于这一方面，<br>她也强烈推荐Michael Feathers的著作<a href="http://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/" target="_blank" rel="external">《修改代码的艺术》</a>。</p>
<p>###4.实现流程自动化。<br>Murphey曾经尝试使用Grunt与Gulp，但她最终还是选择了Yeoman。因为在“使用不熟悉的技术开始一个全新的项目”，或是对第三方JavaScript应用的开发进行标准化时，Yeoman的表现“非常出色”。Murphey也提到了Broccoli，认为它将来或许能够取代Grunt和Yeoman。</p>
<p>###5.编写高质量的代码。<br>她的建议是，对“违反了项目中经过良好定义的风格指南”的代码进行重构，还应当使用lint工具，例如JSCS或ESLint。</p>
<p>###6.使用Git。<br>Murphey建议在Git中使用特性分支，因此得以“通过交互式rebase，在与他人分享提交时对提交进行清理，并且尽可能地在较小的单元上进行工作，以减少冲突的发生机率”。此外还应当通过ghooks在push操作与commit操作前运行钩子操作。</p>
<p>###7.在服务端生成HTML。<br>出于性能方面的考虑，Murphey推荐在大型项目中尽可能在服务端生成HTML。“预先生成这些文件，将其作为静态文件保存，以加快处理请求的速度。随后在客户端的相应事件中可通过客户端代码操作这些HTML文件，并在客户端模板中修改。”</p>
<p>###8. 拥抱Node。<br>Murphey建议web开发者熟练掌握Node.js的相关知识，至少要了解如何初始化一个Node项目、如何搭建一台Express服务器、以及如何使用request模块转发请求。<br>Philip Walton是来自Google的一位软件工程师，他最近撰写了一篇博客文章<a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052" target="_blank" rel="external">Working-Effectively-Legacy-Michael-Feathers</a>。这篇文章的观点另辟蹊径，他并没有向读者推荐任何工具或框架，而是专注于如何处理这一领域中的某些挑战。在他看来，优秀员工与真正杰出的人才的差别不在于他们的知识量，而在于他们的思考方式。他是这样描述开发者的智慧的：</p>
<p>###9.真正理解背后的过程。<br>对于Walton来说，仅仅编写出可以运行的代码算不得优秀。他见过许多编写CSS与JavaScript的人，他们 “只求找到能够运行的代码，然后就继续下一步工作了。”很多时候，开发者并不了解某段代码运行的机制。Walton建议开发者进行深入钻研：</p>
<blockquote>
<p>要充分理解代码的工作原理或许会很耗时间，但我向你保证，从长远来说，这种方式最终将节省你大量的时间。一旦你充分理解你所参与的系统是如何运作的，你就无需不断地进行猜测与检验这些费时的工作了。<br>预先了解浏览器将产生的改动。Web开发者应当持续了解有哪些浏览器的改动会破坏现有的代码。以下代码在IE10中必然会导致整个JavaScript框架的方法出错：<br>var isIE6 = !isIE7 &amp;&amp; !isIE8 &amp;&amp; !isIE9;</p>
</blockquote>
<p>###10仔细阅读规范<br>Walton指出，虽然阅读规范是一项艰辛的任务，但一旦出现浏览器对某个页面的渲染不同的情况，这一任务就是不可避免的了。他为此特别举例说明：</p>
<blockquote>
<p>最近我遇到这样一个例子，与可伸缩（flex）元素的默认最小尺寸有关。根据规范所说，可伸缩元素的min-width与min-height的初始值是auto，而不是0，这就意味着在默认情况下，这些元素不可能收缩到比其中的内容尺寸还小。而在过去8个月中，Firefox是唯一一个正确地实现了这一特性的浏览器。<br>如果你遇到了这个跨浏览器的不一致性问题，并且注意到你的网站在Chrome、IE、Opera和Safari上的展现完全相同，只在Firefox上有所差别，那你很可能会认为是Firefox的问题。实际上，我曾多次发现这一情况，在我的Flexbugs项目中，有许多由用户报告的bug其实都是由这种不一致性所导致的。而如果我按照用户所提议的那些临时方案来改变实现方式，那么在两周前所发布的Chrome 44中又会产生问题。由于这些临时方案选择了违背规范的方式，它们在无形中起到了提倡不正确行为的负面作用。</p>
</blockquote>
<p>###11.代码审查<br>Walton表示，从阅读他人的代码中可以学到很多知识，它可以拓宽你的思路，了解“新的工作方法”，同时也有助于你在团队中的工作。实际上，这一点确实相当必要，因为“作为一位工程师来说，你的时间大部分都是在一个现有的代码库中添加或修改代码”，而不是从头开始编写全新的代码。</p>
<p>###12.与更聪明的人一起工作。<br>Walton“强烈”建议你至少在职业生涯的初期阶段要尽量在某个团队中进行工作，向更有经验的团队成员学习，并让他们审查你的代码。如果之后选择了自由职业者这条职业路线，那么Walton建议你参与开源项目，这同样可以感受到在团队中工作的益处。</p>
<p>###13.重复发明轮子。<br>Walton相信，虽然“重复发明轮子对于业务来说是有害的”，但它对于学习很有好处。在有些情况下，他建议你自己编写代码，而不是依赖于第三方的代码，因为这一过程将让你学到许多东西。当然这也要看情况而定。</p>
<p>###14.将你的经验记录下来。<br>Walton的最后一条建议是将你所学到的东西用文字记录下来：“按我的经验来看，写作、演讲以及开发demo，这些方法能够迫使我对知识点进行充分的挖掘，并做到从内到外的完全理解。哪怕你写的东西完全没人看，但写作的过程本身就已经值得你付出的努力了。”</p>
<p><a href="https://www.infoq.com/news/2015/08/great-front-end-developer" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node--文件及网络操作]]></title>
      <url>https://yanlee26.github.io/2016/11/04/node--http&amp;https/</url>
      <content type="html"><![CDATA[<h1 id="Node–文件及网络操作"><a href="#Node–文件及网络操作" class="headerlink" title="Node–文件及网络操作"></a>Node–文件及网络操作</h1><blockquote>
<p>文件流、网络操作、服务端Web开发基础</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h3><h4 id="利用文件监视实现自动-markdown-文件转换"><a href="#利用文件监视实现自动-markdown-文件转换" class="headerlink" title="利用文件监视实现自动 markdown 文件转换"></a>利用文件监视实现自动 markdown 文件转换</h4><ul>
<li><p>相关链接：</p>
<ol>
<li><a href="https://github.com/chjj/marked" target="_blank" rel="external">https://github.com/chjj/marked</a></li>
<li><a href="https://github.com/Browsersync/browser-sync" target="_blank" rel="external">https://github.com/Browsersync/browser-sync</a> </li>
</ol>
</li>
<li><p>实现思路：</p>
<ol>
<li>利用<code>fs</code>模块的文件监视功能监视指定MD文件</li>
<li>当文件发生变化后，借助<code>marked</code>包提供的<code>markdown</code> to <code>html</code>功能将改变后的MD文件转换为HTML</li>
<li>再将得到的HTML替换到模版中</li>
<li>最后利用BrowserSync模块实现浏览器自动刷新<br>browsersync需要用到Python</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line"><span class="keyword">var</span> bs = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> target = path.join(__dirname, process.argv[<span class="number">2</span>] || <span class="string">'./README.md'</span>);</div><div class="line"><span class="keyword">var</span> filename = path.basename(target, path.extname(target)) + <span class="string">'.html'</span>;</div><div class="line"><span class="keyword">var</span> targetHtml = path.join(path.dirname(target), filename);</div><div class="line"></div><div class="line">bs.init(&#123;</div><div class="line">  <span class="attr">server</span>: path.dirname(target),</div><div class="line">  <span class="attr">index</span>: filename,</div><div class="line">  <span class="attr">notify</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">bs.reload(filename);</div><div class="line"></div><div class="line"><span class="keyword">var</span> template = <span class="string">`&lt;!DOCTYPE html&gt;</span></div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset="UTF-8"&gt;</div><div class="line">  &lt;title&gt;&lt;/title&gt;</div><div class="line">  &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;article class="markdown"&gt;</div><div class="line">    &#123;&#123;&#123;body&#125;&#125;&#125;</div><div class="line">  &lt;/article&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">`;</div><div class="line"></div><div class="line">fs.readFile(path.join(__dirname, <span class="string">'./markdown.css'</span>), <span class="string">'utf8'</span>, (error, css) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</div><div class="line">  template = template.replace(<span class="string">'&#123;&#123;&#123;styles&#125;&#125;&#125;'</span>, css);</div><div class="line">  <span class="keyword">var</span> handler = <span class="function">(<span class="params">current, previous</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(target, <span class="string">'utf8'</span>, (error, content) =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> html = template.replace(<span class="string">'&#123;&#123;&#123;body&#125;&#125;&#125;'</span>, marked(content));</div><div class="line">      fs.writeFile(targetHtml, html, (error) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (!error) &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">`updated@<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>);</div><div class="line">          bs.reload(filename);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  handler();</div><div class="line">  fs.watchFile(target, &#123; <span class="attr">interval</span>: <span class="number">100</span> &#125;, handler);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p><img src="./img/01.png" alt="二进制的世界"></p>
<ul>
<li><p>现实过程的流</p>
<ul>
<li>水流，人流</li>
</ul>
</li>
<li><p>在程序开发的概念中</p>
<ul>
<li>流是程序输入或输出的一个连续的字节序列</li>
<li>文件流、网络流</li>
<li>设备(例如鼠标、键盘、磁盘、屏幕、调制解调器和打印机)的输入和输出都是用流来处理的。</li>
</ul>
</li>
</ul>
<h3 id="Node中的流操作"><a href="#Node中的流操作" class="headerlink" title="Node中的流操作"></a>Node中的流操作</h3><p><img src="./img/02.png" alt="流的操作"></p>
<p>在 Node 核心模块 fs 中定义了一些与流相关的 API</p>
<ul>
<li>fs.createReadStream()<ul>
<li>=&gt; 得到一个ReadableStream</li>
</ul>
</li>
<li>fs.createWriteStream()<ul>
<li>=&gt; 得到一个WritableStream</li>
</ul>
</li>
</ul>
<h3 id="读取流常用-API"><a href="#读取流常用-API" class="headerlink" title="读取流常用 API"></a>读取流常用 API</h3><h4 id="Event："><a href="#Event：" class="headerlink" title="Event："></a>Event：</h4><ul>
<li>data</li>
<li>end</li>
<li>error</li>
</ul>
<h4 id="Method："><a href="#Method：" class="headerlink" title="Method："></a>Method：</h4><ul>
<li>read([size])、</li>
<li>pause()、</li>
<li>isPause()、</li>
<li>resume()、</li>
<li>setEncoding(encoding)、</li>
<li>pipe(destination[, options])、</li>
<li>unpipe([destination])</li>
</ul>
<h3 id="写入流常用-API"><a href="#写入流常用-API" class="headerlink" title="写入流常用 API"></a>写入流常用 API</h3><h4 id="Event"><a href="#Event" class="headerlink" title="Event:"></a>Event:</h4><ul>
<li>error</li>
<li>pipe</li>
</ul>
<h4 id="Method：-1"><a href="#Method：-1" class="headerlink" title="Method："></a>Method：</h4><ul>
<li>write(chunk[, encoding][, callback])</li>
<li>end([chunk][, encoding][, callback])</li>
<li>setDefaultEncoding(encoding)</li>
</ul>
<hr>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p>如何计算循环节长度呢？</p>
<p>想想我们手算，如果余数比除数小，我们会在后面补0然后再除。也就是说补零之后的数是下一次的被除数。如果被除数重复出现，除数确定的，那么商和余数也就是一样的。这时，循环节就出现了。</p>
<p>下面的函数分为两部分，</p>
<p>补零操作<br>查找有没有同样的被除数存在，如果有，就找到了循环节，计算循环节长度并返回。在没有找到的前提下，把当前被除数记录下来，并得到余数作为下一次的被除数。<br>这里需要注意，如果某一次出现了除尽的情况，说明该分数是有限小数，循环节长度是0。<br>`<br>JavaScript</p>
<p>console.log(foo(11, 3));<br>console.log(foo(1, 7));;<br>console.log(foo(2, 10));;<br>function foo(a, b) {<br>  if (!(a % b)) {<br>    return <code>${a}÷${b}:${a / b}</code>;<br>  }<br>  var all = (a / b).toString().split(‘.’);<br>  var i = getCycleSection(a, b);<br>  if(i)<br>    return <code>${a}÷${b}: ${all[0]}.{${all[1].substr(0, i) }}</code>;<br>    return <code>${a}÷${b}: ${a / b}</code>;</p>
<p>}<br>function getCycleSection(n, m) {<br>  var temp = [];<br>  while (true) {<br>    while (n &lt; m) {<br>      n *= 10;<br>    }<br>    var index = temp.indexOf(n);<br>    if (index &gt;= 0) {<br>      return temp.length - index;<br>    }<br>    temp.push(n);<br>    n %= m;<br>    if (!n)<br>      return 0;<br>  }<br>}</p>
<p>`</p>
<blockquote>
<p>HTTP协议，http、url、querystring、模块、网络爬虫，创建文件服务器</p>
</blockquote>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h2 id="收发有格式的数据"><a href="#收发有格式的数据" class="headerlink" title="收发有格式的数据"></a>收发有格式的数据</h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="Node中与HTTP相关的模块"><a href="#Node中与HTTP相关的模块" class="headerlink" title="Node中与HTTP相关的模块"></a>Node中与HTTP相关的模块</h2><h2 id="网络爬虫爬取页面内容"><a href="#网络爬虫爬取页面内容" class="headerlink" title="网络爬虫爬取页面内容"></a>网络爬虫爬取页面内容</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node--常用模块初探]]></title>
      <url>https://yanlee26.github.io/2016/11/03/node--npmpackages/</url>
      <content type="html"><![CDATA[<h1 id="Node–常用模块初探"><a href="#Node–常用模块初探" class="headerlink" title="Node–常用模块初探"></a>Node–常用模块初探</h1><blockquote>
<p>核心模块和NPM、文件操作、文件流、网络操作</p>
</blockquote>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><h3 id="核心模块的意义"><a href="#核心模块的意义" class="headerlink" title="核心模块的意义"></a>核心模块的意义</h3><ul>
<li>如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。</li>
<li>Node 的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。</li>
<li>这些核心的功能模块在 Node 中内置。</li>
</ul>
<h3 id="内置如下模块："><a href="#内置如下模块：" class="headerlink" title="内置如下模块："></a>内置如下模块：</h3><ul>
<li><a href="http://nodejs.org/api/path.html" target="_blank" rel="external">path</a>：处理文件路径。</li>
<li><a href="http://nodejs.org/api/fs.html" target="_blank" rel="external">fs</a>：操作文件系统。</li>
<li><a href="http://nodejs.org/api/child_process.html" target="_blank" rel="external">child_process</a>：新建子进程。</li>
<li><a href="http://nodejs.org/api/util.html" target="_blank" rel="external">util</a>：提供一系列实用小工具。</li>
<li><a href="http://nodejs.org/api/http.html" target="_blank" rel="external">http</a>：提供HTTP服务器功能。</li>
<li><a href="http://nodejs.org/api/url.html" target="_blank" rel="external">url</a>：用于解析URL。</li>
<li><a href="http://nodejs.org/api/querystring.html" target="_blank" rel="external">querystring</a>：解析URL中的查询字符串。</li>
<li><a href="http://nodejs.org/api/crypto.html" target="_blank" rel="external">crypto</a>：提供加密和解密功能。</li>
<li><a href="https://nodejs.org/api/" target="_blank" rel="external">其他</a></li>
</ul>
<hr>
<h2 id="Node-Package"><a href="#Node-Package" class="headerlink" title="Node Package"></a>Node Package</h2><blockquote>
<p>由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（Package）的概念。与核心模块类似，就是将一些预先设计好的功能或者说API封装到一个文件夹，提供给开发者使用；</p>
</blockquote>
<h3 id="包的加载机制"><a href="#包的加载机制" class="headerlink" title="包的加载机制"></a>包的加载机制</h3><ul>
<li>与内置模块相同，包的加载同样使用<code>require</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div></pre></td></tr></table></figure>
<ul>
<li>加载机制也和内置模块加载机制相同</li>
<li><p>加载注意事项：</p>
<ul>
<li>先在系统核心（优先级最高）的模块中找；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// 永远加载内部核心模块fs</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>然后再到当前项目中 node_modules 目录中找；</li>
</ul>
<h3 id="如何管理好自己的包包"><a href="#如何管理好自己的包包" class="headerlink" title="如何管理好自己的包包"></a>如何管理好自己的包包</h3><ul>
<li>由于<code>Node</code>本身并没有太多的功能性<code>API</code>，所以市面上涌现出大量的第三方人员开发出来的<code>Package</code><br><img src="./img/npm.png" alt="www.npmjs.com"></li>
<li>包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理</li>
<li>这时候<code>NPM</code>诞生了</li>
</ul>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><ul>
<li><p>随着时间的发展，NPM 出现了两层概念：</p>
<ul>
<li>一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区</li>
<li>另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。</li>
</ul>
</li>
<li><p>官方链接： <a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a></p>
</li>
<li>国内加速镜像： <a href="https://npm.taobao.org/" target="_blank" rel="external">https://npm.taobao.org/</a></li>
</ul>
<h3 id="安装NPM"><a href="#安装NPM" class="headerlink" title="安装NPM"></a>安装NPM</h3><ul>
<li>NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM。</li>
<li>但是，Node 附带的 NPM 可能不是最新版本，最好用下面的命令，更新到最新版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install npm -g</div></pre></td></tr></table></figure>
<ul>
<li>默认安装到当前系统 Node 所在目录下。</li>
<li>由于之前使用 NVM 的方式安装的 Node 所以需要重新配置 NPM 的全局目录</li>
</ul>
<h3 id="配置NPM的全局目录"><a href="#配置NPM的全局目录" class="headerlink" title="配置NPM的全局目录"></a>配置NPM的全局目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config <span class="built_in">set</span> prefix [pathtonpm]</div></pre></td></tr></table></figure>
<ul>
<li>将NPM目录配置到其他目录时，必须将该目录放到环境变量中，否则无法再全局使用</li>
</ul>
<h3 id="常用NPM命令"><a href="#常用NPM命令" class="headerlink" title="常用NPM命令"></a>常用NPM命令</h3><ul>
<li><a href="https://docs.npmjs.com/" target="_blank" rel="external">https://docs.npmjs.com/</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">npm config [ls|list|<span class="built_in">set</span>|get] [name] [value]</div><div class="line">npm init [--yes|-y]</div><div class="line">npm search [name]</div><div class="line">npm info [name]</div><div class="line">npm install [--global|-g] [name]</div><div class="line">npm uninstall [--global|-g] [name]</div><div class="line">npm list [--global|-g]</div><div class="line">npm outdated [--global|-g]</div><div class="line">npm update [--global|-g] [name]</div><div class="line">npm run [task]</div><div class="line">npm cache [clean]</div></pre></td></tr></table></figure>
<hr>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="相关模块"><a href="#相关模块" class="headerlink" title="相关模块"></a>相关模块</h3><p>Node内核提供了很多与文件操作相关的模块，每个模块都提供了一些最基本的操作API，在NPM中也有社区提供的功能包</p>
<h5 id="fs："><a href="#fs：" class="headerlink" title="fs："></a>fs：</h5><p>基础的文件操作 API</p>
<h5 id="path："><a href="#path：" class="headerlink" title="path："></a>path：</h5><p>提供和路径相关的操作 API</p>
<h5 id="readline："><a href="#readline：" class="headerlink" title="readline："></a>readline：</h5><p>用于读取大文本文件，一行一行读</p>
<h5 id="fs-extra（第三方）："><a href="#fs-extra（第三方）：" class="headerlink" title="fs-extra（第三方）："></a>fs-extra（第三方）：</h5><p><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="external">https://www.npmjs.com/package/fs-extra</a> </p>
<h3 id="同步或异步调用"><a href="#同步或异步调用" class="headerlink" title="同步或异步调用"></a>同步或异步调用</h3><ul>
<li>fs模块对文件的几乎所有操作都有同步和异步两种形式</li>
<li>例如：readFile() 和 readFileSync()</li>
<li>区别：<ul>
<li>同步调用会阻塞代码的执行，异步则不会</li>
<li>异步调用会将读取任务下达到任务队列，直到任务执行完成才会回调</li>
<li>异常处理方面，同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">'sync'</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">var</span> data = fs.readFileSync(path.join(<span class="string">'C:\\Users\\iceStone\\Downloads'</span>, <span class="string">'H.mp4'</span>));</div><div class="line">  <span class="comment">// console.log(data);</span></div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">  <span class="keyword">throw</span> error;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'sync'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.time(<span class="string">'async'</span>);</div><div class="line">fs.readFile(path.join(<span class="string">'C:\\Users\\iceStone\\Downloads'</span>, <span class="string">'H.mp4'</span>), (error, data) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</div><div class="line">  <span class="comment">// console.log(data);</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'async'</span>);</div></pre></td></tr></table></figure>
<h3 id="路径模块"><a href="#路径模块" class="headerlink" title="路径模块"></a>路径模块</h3><p>在文件操作的过程中，都必须使用物理路径（绝对路径），path模块提供了一系列与路径相关的 API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'join用于拼接多个路径部分，并转化为正常格式'</span>);</div><div class="line"><span class="keyword">const</span> temp = path.join(__dirname, <span class="string">'..'</span>, <span class="string">'lyrics'</span>, <span class="string">'./友谊之光.lrc'</span>);</div><div class="line"><span class="built_in">console</span>.log(temp);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取路径中的文件名'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.basename(temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取路径中的文件名并排除扩展名'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.basename(temp, <span class="string">'.lrc'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取不同操作系统的路径分隔符'</span>);</div><div class="line"><span class="built_in">console</span>.log(process.platform + <span class="string">'的分隔符为 '</span> + path.delimiter);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'一般用于分割环境变量'</span>);</div><div class="line"><span class="built_in">console</span>.log(process.env.PATH.split(path.delimiter));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取一个路径中的目录部分'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.dirname(temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取一个路径中最后的扩展名'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.extname(temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'将一个路径解析成一个对象的形式'</span>);</div><div class="line"><span class="keyword">const</span> pathObject = path.parse(temp);</div><div class="line"><span class="built_in">console</span>.log(pathObject);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'将一个路径对象再转换为一个字符串的形式'</span>);</div><div class="line"><span class="comment">// pathObject.name = '我终于失去了你';</span></div><div class="line">pathObject.base = <span class="string">'我终于失去了你.lrc'</span>;</div><div class="line"><span class="built_in">console</span>.log(pathObject);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取一个路径是不是绝对路径'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(temp));</div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'../lyrics/爱的代价.lrc'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'将一个路径转换为当前系统默认的标准格式，并解析其中的./和../'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.normalize(<span class="string">'c:/develop/demo\\hello/../world/./a.txt'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取第二个路径相对第一个路径的相对路径'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.relative(__dirname, temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'以类似命令行cd命令的方式拼接路径'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.resolve(temp, <span class="string">'c:/'</span>, <span class="string">'./develop'</span>, <span class="string">'../application'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取不同平台中路径的分隔符（默认）'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.sep);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'允许在任意平台下以WIN32的方法调用PATH对象'</span>);</div><div class="line"><span class="comment">// console.log(path.win32);</span></div><div class="line"><span class="built_in">console</span>.log(path === path.win32);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'允许在任意平台下以POSIX的方法调用PATH对象'</span>);</div><div class="line"><span class="built_in">console</span>.log(path === path.posix);</div></pre></td></tr></table></figure>
<p>源码地址：<br><a href="https://github.com/nodejs/node/blob/master/lib/path.js" target="_blank" rel="external">https://github.com/nodejs/node/blob/master/lib/path.js</a></p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>Node中文件读取的方式主要有：</p>
<h4 id="fs-readFile-file-options-callback-error-data"><a href="#fs-readFile-file-options-callback-error-data" class="headerlink" title="fs.readFile(file[, options], callback(error, data))"></a>fs.readFile(file[, options], callback(error, data))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(<span class="string">'c:\\demo\1.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="fs-readFileSync-file-options"><a href="#fs-readFileSync-file-options" class="headerlink" title="fs.readFileSync(file[, options])"></a>fs.readFileSync(file[, options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">const</span> data = fs.readFileSync(<span class="string">'c:\\demo\1.txt'</span>, <span class="string">'utf8'</span>);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="comment">// 文件不存在，或者权限错误</span></div><div class="line">  <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fs-createReadStream-path-options"><a href="#fs-createReadStream-path-options" class="headerlink" title="fs.createReadStream(path[, options])"></a>fs.createReadStream(path[, options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> stream = fs.createReadStream(<span class="string">'c:\\demo\1.txt'</span>);</div><div class="line"><span class="keyword">let</span> data = <span class="string">''</span></div><div class="line">stream.on(<span class="string">'data'</span>, (trunk) =&gt; &#123;</div><div class="line">  data += trunk;</div><div class="line">&#125;);</div><div class="line">stream.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p><em>由于Windows平台下默认文件编码是GBK，在Node中不支持，可以通过<a href="https://github.com/ashtuchkin/iconv-lite" target="_blank" rel="external">iconv-lite</a>解决</em></p>
</blockquote>
<h3 id="Readline模块逐行读取文本内容"><a href="#Readline模块逐行读取文本内容" class="headerlink" title="Readline模块逐行读取文本内容"></a>Readline模块逐行读取文本内容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</div><div class="line">  <span class="attr">input</span>: fs.createReadStream(<span class="string">'sample.txt'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rl.on(<span class="string">'line'</span>, (line) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Line from file:'</span>, line);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>Node中文件写入的方式主要有：</p>
<h4 id="fs-writeFile-file-data-options-callback-error"><a href="#fs-writeFile-file-data-options-callback-error" class="headerlink" title="fs.writeFile(file, data[, options], callback(error))"></a>fs.writeFile(file, data[, options], callback(error))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(<span class="string">'c:\\demo\a.txt'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(), (error) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="fs-writeFileSync-file-data-options"><a href="#fs-writeFileSync-file-data-options" class="headerlink" title="fs.writeFileSync(file, data[, options])"></a>fs.writeFileSync(file, data[, options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  fs.writeFileSync(<span class="string">'c:\\demo\a.txt'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">  <span class="comment">// 文件夹不存在，或者权限错误</span></div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fs-createWriteStream-path-option"><a href="#fs-createWriteStream-path-option" class="headerlink" title="fs.createWriteStream(path[,option])"></a>fs.createWriteStream(path[,option])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> streamWriter = fs.createWriteStream(<span class="string">'c:\\demo\a.txt'</span>);</div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  streamWriter.write(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>&#125;</span>\n`</span>, (error) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h3 id="文件写入-1"><a href="#文件写入-1" class="headerlink" title="文件写入"></a>文件写入</h3><h4 id="fs-appendFile-file-data-options-callback-err"><a href="#fs-appendFile-file-data-options-callback-err" class="headerlink" title="fs.appendFile(file,data[,options],callback(err))"></a>fs.appendFile(file,data[,options],callback(err))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相比较之前文件流的方式，这种方式不会占用文件资源，append完成就会释放</span></div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  fs.appendFile(<span class="string">'c:\\demo\a.txt'</span>,<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>&#125;</span>\n`</span>, (error) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h4 id="fs-appendFileSync-file-data-options"><a href="#fs-appendFileSync-file-data-options" class="headerlink" title="fs.appendFileSync(file,data[,options])"></a>fs.appendFileSync(file,data[,options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  fs.appendFileSync(<span class="string">'c:\\demo\a.txt'</span>,<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>&#125;</span>\n`</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h3 id="其他常见文件操作"><a href="#其他常见文件操作" class="headerlink" title="其他常见文件操作"></a>其他常见文件操作</h3><h4 id="验证路径是否存在（过时的API）"><a href="#验证路径是否存在（过时的API）" class="headerlink" title="验证路径是否存在（过时的API）"></a>验证路径是否存在（过时的API）</h4><ul>
<li>fs.exists(path,callback(exists))</li>
<li>fs.existsSync(path) // =&gt; 返回布尔类型 exists</li>
</ul>
<h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><ul>
<li>fs.stat(path,callback(err,stats))</li>
<li>fs.statSync(path) // =&gt; 返回一个fs.Stats实例</li>
</ul>
<h4 id="移动文件或重命名文件或目录"><a href="#移动文件或重命名文件或目录" class="headerlink" title="移动文件或重命名文件或目录"></a>移动文件或重命名文件或目录</h4><blockquote>
<p>与命令行相同，重命名操作也可以实现文件移动</p>
</blockquote>
<ul>
<li>fs.rename(oldPath,newPath,callback)</li>
<li>fs.renameSync(oldPath,newPath)</li>
</ul>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ul>
<li>fs.unlink(path,callback(err))</li>
<li>fs.unlinkSync(path)</li>
</ul>
<h3 id="其他常见文件夹操作"><a href="#其他常见文件夹操作" class="headerlink" title="其他常见文件夹操作"></a>其他常见文件夹操作</h3><h4 id="创建一个目录"><a href="#创建一个目录" class="headerlink" title="创建一个目录"></a>创建一个目录</h4><ul>
<li>fs.mkdir(path[,model],callback)</li>
<li>fs.mkdirSync(path[,model])</li>
</ul>
<h4 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h4><ul>
<li>fs.rmdir(path,callback)</li>
<li>fs.rmdirSync(path)</li>
</ul>
<h4 id="读取一个目录"><a href="#读取一个目录" class="headerlink" title="读取一个目录"></a>读取一个目录</h4><ul>
<li>fs.readdir(path,callback(err,files))</li>
<li>fs.readdirSync(path) // =&gt; 返回files</li>
</ul>
<h3 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h3><h4 id="利用文件监视实现自动-markdown-文件转换"><a href="#利用文件监视实现自动-markdown-文件转换" class="headerlink" title="利用文件监视实现自动 markdown 文件转换"></a>利用文件监视实现自动 markdown 文件转换</h4><ul>
<li><p>相关链接：</p>
<ol>
<li><a href="https://github.com/chjj/marked" target="_blank" rel="external">https://github.com/chjj/marked</a></li>
<li><a href="https://github.com/Browsersync/browser-sync" target="_blank" rel="external">https://github.com/Browsersync/browser-sync</a> </li>
</ol>
</li>
<li><p>实现思路：</p>
<ol>
<li>利用<code>fs</code>模块的文件监视功能监视指定MD文件</li>
<li>当文件发生变化后，借助<code>marked</code>包提供的<code>markdown</code> to <code>html</code>功能将改变后的MD文件转换为HTML</li>
<li>再将得到的HTML替换到模版中</li>
<li>最后利用BrowserSync模块实现浏览器自动刷新</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line"><span class="keyword">var</span> bs = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> target = path.join(__dirname, process.argv[<span class="number">2</span>] || <span class="string">'./README.md'</span>);</div><div class="line"><span class="keyword">var</span> filename = path.basename(target, path.extname(target)) + <span class="string">'.html'</span>;</div><div class="line"><span class="keyword">var</span> targetHtml = path.join(path.dirname(target), filename);</div><div class="line"></div><div class="line">bs.init(&#123;</div><div class="line">  <span class="attr">server</span>: path.dirname(target),</div><div class="line">  <span class="attr">index</span>: filename,</div><div class="line">  <span class="attr">notify</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">bs.reload(filename);</div><div class="line"></div><div class="line"><span class="keyword">var</span> template = <span class="string">`&lt;!DOCTYPE html&gt;</span></div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset="UTF-8"&gt;</div><div class="line">  &lt;title&gt;&lt;/title&gt;</div><div class="line">  &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;article class="markdown"&gt;</div><div class="line">    &#123;&#123;&#123;body&#125;&#125;&#125;</div><div class="line">  &lt;/article&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">`;</div><div class="line"></div><div class="line">fs.readFile(path.join(__dirname, <span class="string">'./markdown.css'</span>), <span class="string">'utf8'</span>, (error, css) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</div><div class="line">  template = template.replace(<span class="string">'&#123;&#123;&#123;styles&#125;&#125;&#125;'</span>, css);</div><div class="line">  <span class="keyword">var</span> handler = <span class="function">(<span class="params">current, previous</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(target, <span class="string">'utf8'</span>, (error, content) =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> html = template.replace(<span class="string">'&#123;&#123;&#123;body&#125;&#125;&#125;'</span>, marked(content));</div><div class="line">      fs.writeFile(targetHtml, html, (error) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (!error) &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">`updated@<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>);</div><div class="line">          bs.reload(filename);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  handler();</div><div class="line">  fs.watchFile(target, &#123; <span class="attr">interval</span>: <span class="number">100</span> &#125;, handler);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h2 id="缓冲区处理"><a href="#缓冲区处理" class="headerlink" title="缓冲区处理"></a>缓冲区处理</h2><h3 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a>什么是缓冲区</h3><ul>
<li>缓冲区就是内存中操作数据的容器</li>
<li>只是数据容器而已</li>
<li>通过缓冲区可以很方便的操作二进制数据</li>
<li>而且在大文件操作时必须有缓冲区</li>
</ul>
<h3 id="为什么要有缓冲区"><a href="#为什么要有缓冲区" class="headerlink" title="为什么要有缓冲区"></a>为什么要有缓冲区</h3><ul>
<li>JavaScript是比较擅长处理字符串，但是早期的应用场景主要用于处理HTML文档，不会有太大篇幅的数据处理，也不会接触到二进制的数据。</li>
<li>而在Node中操作数据、网络通信是没办法完全以字符串的方式操作的，简单来说</li>
<li>所以在Node中引入了一个二进制的缓冲区的实现：Buffer</li>
</ul>
<hr>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node--get started]]></title>
      <url>https://yanlee26.github.io/2016/11/01/node--getstarted/</url>
      <content type="html"><![CDATA[<h1 id="Node–get-started"><a href="#Node–get-started" class="headerlink" title="Node–get started"></a>Node–get started</h1><blockquote>
<p>Node简介及配置、快速上手、核心特点、模块化</p>
</blockquote>
<h2 id="Node简介"><a href="#Node简介" class="headerlink" title="Node简介"></a>Node简介</h2><h3 id="客户端的JavaScript是怎样的"><a href="#客户端的JavaScript是怎样的" class="headerlink" title="客户端的JavaScript是怎样的"></a>客户端的JavaScript是怎样的</h3><ul>
<li><p>什么是 JavaScript？</p>
<ul>
<li>脚本语言</li>
<li>运行在浏览器中</li>
<li>一般用来做客户端页面的交互（Interactive）</li>
</ul>
</li>
<li><p>JavaScript 的运行环境？</p>
<ul>
<li>是不是运行在浏览器呢？</li>
<li>不够严谨</li>
<li>运行在浏览器内核中的 JS 引擎（engine）</li>
</ul>
</li>
<li><p>浏览器中的 JavaScript 可以做什么？</p>
<ul>
<li>操作DOM（对DOM的增删改、注册事件）</li>
<li>AJAX/跨域</li>
<li>BOM（页面跳转、历史记录、console.log()、alert()）</li>
<li>ECMAScript</li>
</ul>
</li>
<li><p>浏览器中的 JavaScript 不可以做什么？</p>
<ul>
<li>文件操作（文件和文件夹的CRUD）</li>
<li>没有办法操作系统信息</li>
<li>由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行）</li>
</ul>
</li>
<li><p>在开发人员能力相同的情况下编程语言的能力取决于什么？</p>
<ul>
<li>-语言本身？-</li>
<li>语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作</li>
<li>取决于运行该语言的平台（环境）</li>
<li>对于JS来说，我们常说的JS实际是ES，大部分能力都是由浏览器的执行引擎决定</li>
<li>BOM和DOM可以说是浏览器开放出来的接口</li>
<li><p>比如：Cordova中提供JS调用摄像头，操作本地文件的API</p>
</li>
<li><p>Java既是语言也是平台</p>
</li>
<li>Java运行在Java虚拟机（跨操作系统）</li>
<li><p>PHP既是语言也是平台（跨操作系统）</p>
</li>
<li><p>C#语言平台：.NET Framework（Windows）</p>
</li>
<li>C#可以运行在MONO这样的平台</li>
<li>因为有人需要将C#运行在Linux平台，所有出现了MONO</li>
</ul>
</li>
</ul>
<ul>
<li>JavaScript 只可以运行在浏览器中吗？<ul>
<li>不是</li>
<li>能运行在哪取决于，这个环境有没有特定平台</li>
</ul>
</li>
</ul>
<h3 id="什么是Node"><a href="#什么是Node" class="headerlink" title="什么是Node"></a>什么是Node</h3><ul>
<li>Node 就是 JavaScript 语言在服务器端的运行环境</li>
<li>所谓“运行环境（平台）”有两层意思：<ul>
<li>首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机；</li>
<li>其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。</li>
</ul>
</li>
</ul>
<h3 id="为什么是JavaScript"><a href="#为什么是JavaScript" class="headerlink" title="为什么是JavaScript"></a>为什么是JavaScript</h3><h3 id="Node的实现结构"><a href="#Node的实现结构" class="headerlink" title="Node的实现结构"></a>Node的实现结构</h3><h3 id="Node在当下Web开发领域的应用"><a href="#Node在当下Web开发领域的应用" class="headerlink" title="Node在当下Web开发领域的应用"></a>Node在当下Web开发领域的应用</h3><h3 id="哪些公司在用"><a href="#哪些公司在用" class="headerlink" title="哪些公司在用"></a>哪些公司在用</h3><h3 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h3><ul>
<li>Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架；</li>
<li>Node的实现结构；</li>
<li>Node可以用来开发服务端应用程序，Web系统；</li>
<li>基于Node的前端工具集</li>
</ul>
<hr>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装包的方式安装"><a href="#安装包的方式安装" class="headerlink" title="安装包的方式安装"></a>安装包的方式安装</h3><ul>
<li>安装包下载链接：<ul>
<li>Mac OSX： <a href="http://npm.taobao.org/mirrors/node/v5.7.0/node-v5.7.0.pkg" target="_blank" rel="external">darwin</a></li>
<li>Windows：<ul>
<li><a href="http://npm.taobao.org/mirrors/node/v5.7.0/node-v5.7.0-x64.msi" target="_blank" rel="external">x64</a></li>
<li><a href="http://npm.taobao.org/mirrors/node/v5.7.0/node-v5.7.0-x86.msi" target="_blank" rel="external">x86</a></li>
</ul>
</li>
</ul>
</li>
<li>安装操作：<ul>
<li>一路<em>Next</em></li>
</ul>
</li>
</ul>
<h3 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h3><ul>
<li>操作方式：<ul>
<li>重新下载最新的安装包；</li>
<li>覆盖安装即可；</li>
</ul>
</li>
<li>问题：<ul>
<li>以前版本安装的很多全局的工具包需要重新安装</li>
<li>无法回滚到之前的版本</li>
<li>无法在多个版本之间切换（很多时候我们要使用特定版本）</li>
</ul>
</li>
</ul>
<h3 id="NVM工具的使用"><a href="#NVM工具的使用" class="headerlink" title="NVM工具的使用"></a>NVM工具的使用</h3><blockquote>
<p>Node Version Manager（Node版本管理工具）</p>
</blockquote>
<p>由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理</p>
<h4 id="安装操作步骤"><a href="#安装操作步骤" class="headerlink" title="安装操作步骤"></a>安装操作步骤</h4><ol>
<li>下载：<a href="https://github.com/coreybutler/nvm-windows/releases/download/1.1.0/nvm-noinstall.zip" target="_blank" rel="external">nvm-windows</a></li>
<li>解压到一个全英文路径</li>
<li><p>编辑解压目录下的<code>settings.txt</code>文件（不存在则新建）</p>
<ul>
<li><code>root 配置为当前 nvm.exe 所在目录</code></li>
<li><code>path 配置为 node 快捷方式所在的目录</code></li>
<li><code>arch 配置为当前操作系统的位数（32/64）</code></li>
<li><code>proxy 不用配置</code></li>
</ul>
</li>
<li><p>配置环境变量 可以通过 window+r  : sysdm.cpl</p>
<ul>
<li><code>NVM_HOME = 当前 nvm.exe 所在目录</code></li>
<li><code>NVM_SYMLINK = node 快捷方式所在的目录</code></li>
<li><code>PATH += %NVM_HOME%;%NVM_SYMLINK%;</code></li>
<li>打开CMD通过<code>set [name]</code>命令查看环境变量是否配置成功</li>
<li>PowerShell中是通过<code>dir env:[name]</code>命令</li>
</ul>
</li>
<li><p>NVM使用说明：</p>
<ul>
<li><a href="https://github.com/coreybutler/nvm-windows/" target="_blank" rel="external">https://github.com/coreybutler/nvm-windows/</a></li>
</ul>
</li>
<li><p>NPM的目录之后使用再配置</p>
</li>
</ol>
<h3 id="配置Python环境"><a href="#配置Python环境" class="headerlink" title="配置Python环境"></a>配置Python环境</h3><blockquote>
<p>Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译<br>确保全局环境中可以使用python命令</p>
</blockquote>
<h3 id="环境变量的概念"><a href="#环境变量的概念" class="headerlink" title="环境变量的概念"></a>环境变量的概念</h3><blockquote>
<p>环境变量就是操作系统提供的系统级别用于存储变量的地方</p>
</blockquote>
<ul>
<li>Windows中环境变量分为系统变量和用户变量</li>
<li>环境变量的变量名是不区分大小写的</li>
<li>特殊值：<ul>
<li>PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下搜索</li>
</ul>
</li>
</ul>
<h3 id="Windows下常用的命令行操作"><a href="#Windows下常用的命令行操作" class="headerlink" title="Windows下常用的命令行操作"></a>Windows下常用的命令行操作</h3><ul>
<li>切换当前目录（change directory）：cd</li>
<li>创建目录（make directory）：mkdir</li>
<li>查看当前目录列表（directory）：dir<ul>
<li>别名：ls（list）</li>
</ul>
</li>
<li>清空当前控制台：cls<ul>
<li>别名：clear</li>
</ul>
</li>
<li>删除文件：del<ul>
<li>别名：rm</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：所有别名必须在新版本的 PowerShell 中使用</p>
</blockquote>
<hr>
<blockquote>
<p>事件驱动和非阻塞、模块化、核心模块、NPM</p>
</blockquote>
<hr>
<h2 id="事件驱动和非阻塞"><a href="#事件驱动和非阻塞" class="headerlink" title="事件驱动和非阻塞"></a>事件驱动和非阻塞</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// $.ajax()</span></div><div class="line"></div><div class="line"><span class="comment">// $.get('/users/list',&#123;order:'id'&#125;)</span></div><div class="line"></div><div class="line"><span class="comment">// $.get('/delete/user', &#123;id:10&#125;)</span></div><div class="line"><span class="comment">//   .success(function(data)&#123;</span></div><div class="line"><span class="comment">//     console.log(11);</span></div><div class="line"><span class="comment">//   &#125;)</span></div><div class="line"><span class="comment">//   .error(function(error)&#123;</span></div><div class="line">    </div><div class="line"><span class="comment">//   &#125;);</span></div><div class="line"></div><div class="line">$.get(<span class="string">''</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(err)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SCSS]]></title>
      <url>https://yanlee26.github.io/2016/09/24/scss/</url>
      <content type="html"><![CDATA[<h1 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h1><h3 id="get-started…"><a href="#get-started…" class="headerlink" title="get started…"></a>get started…</h3><ol>
<li>变量<blockquote>
<p>定义变量以便于维护</p>
</blockquote>
</li>
</ol>
<p><code>$fontStack:    Helvetica, sans-serif;
$primaryColor: #333;
body {
  font-family: $fontStack;
  color: $primaryColor;
}
// css
body {
  font-family: Helvetica, sans-serif;
  color: #333;
}</code></p>
<ol>
<li>嵌套<blockquote>
<p>选择器嵌套，层次分明</p>
</blockquote>
</li>
</ol>
<p>`<br>nav {<br>  ul {<br>    margin: 0;<br>    padding: 0;<br>    list-style: none;<br>  }<br>  li { display: inline-block; }<br>  a {<br>    display: block;<br>    padding: 6px 12px;<br>    text-decoration: none;<br>  }<br>}<br>//css<br>nav ul {<br>  margin: 0;<br>  padding: 0;<br>  list-style: none;<br>}</p>
<p>nav li {<br>  display: inline-block;<br>}</p>
<p>nav a {<br>  display: block;<br>  padding: 6px 12px;<br>  text-decoration: none;<br>}<br>`</p>
<ol>
<li>导入<blockquote>
<p>导入其它sass文件，优于css的@import</p>
</blockquote>
</li>
</ol>
<p><code>//_reset.scss
html,
body,
ul,
ol {
   margin: 0;
  padding: 0;
}
//base.scss
@import &#39;reset&#39;;
body {
  font-size: 100% Helvetica, sans-serif;
  background-color: #efefef;
}</code></p>
<ol>
<li>mixin<blockquote>
<p>让css3的编写锦上添花</p>
</blockquote>
</li>
</ol>
<p><code>@mixin box-sizing ($sizing) {
    -webkit-box-sizing:$sizing;     
       -moz-box-sizing:$sizing;
            box-sizing:$sizing;
}
.box-border{
    border:1px solid #ccc;
    @include box-sizing(border-box);
}
//css
.box-border {
  border: 1px solid #ccc;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}</code></p>
<ol>
<li>扩展/继承<blockquote>
<p>@extend 优雅实现代码组合声明</p>
</blockquote>
</li>
</ol>
<p>`<br>.message {<br>  border: 1px solid #ccc;<br>  padding: 10px;<br>  color: #333;<br>}<br>.success {<br>  @extend .message;<br>  border-color: green;<br>}<br>.error {<br>  @extend .message;<br>  border-color: red;<br>}<br>//css<br>.message, .success, .error, .warning {<br>  border: 1px solid #cccccc;<br>  padding: 10px;<br>  color: #333;<br>}</p>
<p>.success {<br>  border-color: green;<br>}</p>
<p>.error {<br>  border-color: red;<br>}</p>
<p>.warning {<br>  border-color: yellow;<br>}<br>`</p>
<ol>
<li>四则运算<br>`<br>.container { width: 100%; }</li>
</ol>
<p>article[role=”main”] {<br>  float: left;<br>  width: 600px / 960px * 100%;<br>}</p>
<p>aside[role=”complimentary”] {<br>  float: right;<br>  width: 300px / 960px * 100%;<br>}<br>//css<br>.container {<br>  width: 100%;<br>}</p>
<p>article[role=”main”] {<br>  float: left;<br>  width: 62.5%;<br>}</p>
<p>aside[role=”complimentary”] {<br>  float: right;<br>  width: 31.25%;<br>}<br>`</p>
<ol>
<li>颜色变换<br><code>$linkColor: #08c;
a {
 text-decoration:none;
 color:$linkColor;
 &amp;:hover{
   color:darken($linkColor,10%);
 }
}
//css
a {
text-decoration: none;
color: #0088cc;
}
a:hover {
color: #006699;
}</code><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li>
<li>文件后缀名<ul>
<li>sass:不使用{}及；</li>
<li>scss:同css，首选</li>
</ul>
</li>
<li>导入<code>@import</code><blockquote>
<p>导入css和css用法一样不再编译，导入scss会合并编译</p>
</blockquote>
</li>
<li>注释<code>标准注释/**/，编译到css；单行注释//不编译</code></li>
<li>变量<blockquote>
<p>$开头紧跟变量名，变量名值以：分隔，！表示默认值</p>
</blockquote>
</li>
</ol>
<p>`<br>$fontSize: 12px;<br>body{<br>    font-size:$fontSize;<br>}<br>$baseLineHeight:        2;</p>
<p>$baseLineHeight:        1.5 !default;<br>body{<br>    line-height: $baseLineHeight;<br>}<br>//css<br>body{<br>    line-height:2;<br>}<br>//特殊变量：变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用<br>$borderDirection:       top !default;<br>$baseFontSize:          12px !default;<br>$baseLineHeight:        1.5 !default;</p>
<p>//应用于class和属性<br>.border-#{$borderDirection}{<br>  border-#{$borderDirection}:1px solid #ccc;<br>}<br>//应用于复杂的属性值<br>body{<br>    font:#{$baseFontSize}/#{$baseLineHeight};<br>}<br>`</p>
<ol>
<li><p>多值变量</p>
<blockquote>
<p>多值类型分list和map类型，list类似js数组，map类似对象<br>`<br>$linkColor:         #08c #333 !default;//第一个值为默认值，第二个鼠标滑过值<br>a{<br>color:nth($linkColor,1);</p>
</blockquote>
<p>&amp;:hover{<br> color:nth($linkColor,2);<br>}<br>}<br>//css<br>a{<br>color:#08c;<br>}<br>a:hover{<br>color:#333;<br>}<br>$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);<br>@each $header, $size in $headings {<br>#{$header} {<br> font-size: $size;<br>}<br>}<br>//css<br>h1 {<br>font-size: 2em;<br>}<br>h2 {<br>font-size: 1.5em;<br>}<br>h3 {<br>font-size: 1.2em;<br>}<br>`</p>
</li>
<li>全局变量：！global</li>
<li>嵌套与挑出@at-root,@at-root (without: …)和@at-root (with: …)</li>
<li>混合@mixin<br>`<br>@mixin center-block {<br> margin-left:auto;<br> margin-right:auto;<br>}<br>.demo{<br> @include center-block;<br>}<br>@mixin opacity($opacity:50) {<br>opacity: $opacity / 100;<br>filter: alpha(opacity=$opacity);<br>}<br>@mixin opacity($opacity:50) {<br>opacity: $opacity / 100;<br>filter: alpha(opacity=$opacity);<br>}</li>
</ol>
<p>//css style<br>.opacity{<br>  @include opacity; //参数使用默认值<br>}<br>.opacity-80{<br>  @include opacity(80); //传递参数<br>}<br>//多个参数<br>@mixin horizontal-line($border:1px dashed #ccc, $padding:10px){<br>    border-bottom:$border;<br>    padding-top:$padding;<br>    padding-bottom:$padding;<br>}<br>.imgtext-h li{<br>    @include horizontal-line(1px solid #ccc);<br>}<br>.imgtext-h–product li{<br>    @include horizontal-line($padding:15px);<br>}<br>//@content<br>@mixin max-screen($res){<br>  @media only screen and ( max-width: $res )<br>  {<br>    @content;<br>  }<br>}</p>
<p>@include max-screen(480px) {<br>  body { color: red }<br>}<br>`</p>
<ol>
<li>继承@extent</li>
<li>占位选择器%<blockquote>
<p>如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中<br>不管是否使用了@extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过@extend调用。</p>
</blockquote>
</li>
</ol>
<p>`<br>%ir{<br>  color: transparent;<br>  text-shadow: none;<br>  background-color: transparent;<br>  border: 0;<br>}<br>%clearfix{<br>  @if $lte7 {<br>    *zoom: 1;<br>  }<br>  &amp;:before,<br>  &amp;:after {<br>    content: “”;<br>    display: table;<br>    font: 0/0 a;<br>  }<br>  &amp;:after {<br>    clear: both;<br>  }<br>}</p>
<p>#header{<br>  h1{<br>    @extend %ir;<br>    width:300px;<br>  }<br>}<br>.ir{<br>  @extend %ir;<br>}<br>//css</p>
<p>#header h1,<br>.ir{<br>  color: transparent;<br>  text-shadow: none;<br>  background-color: transparent;<br>  border: 0;<br>}<br>`</p>
<ol>
<li>函数<br>`<br>$baseFontSize:      10px !default;<br>$gray:              #ccc !defualt;        </li>
</ol>
<p>// pixels to rems<br>@function pxToRem($px) {<br>  @return $px / $baseFontSize * 1rem;<br>}</p>
<p>body{<br>  font-size:$baseFontSize;<br>  color:lighten($gray,10%);<br>}<br>.test{<br>  font-size:pxToRem(16px);<br>  color:darken($gray,10%);<br>}<br>`</p>
<ol>
<li>运算<br>$baseFontSize:          14px !default;<br>$baseLineHeight:        1.5 !default;<br>$baseGap:               $baseFontSize * $baseLineHeight !default;<br>$halfBaseGap:           $baseGap / 2  !default;<br>$samllFontSize:         $baseFontSize - 2px  !default;</li>
</ol>
<p>//grid<br>$_columns:                     12 !default;      // Total number of columns<br>$_column-width:                60px !default;   // Width of a single column<br>$_gutter:                      20px !default;     // Width of the gutter<br>$_gridsystem-width:            $_columns * ($_column-width + $_gutter); //grid system width<code>
</code></p>
<ol>
<li>条件和循环<br>`<br>$lte7: true;<br>$type: monster;<br>.ib{<br>display:inline-block;<br>@if $lte7 {<pre><code>*display:inline;
*zoom:1;
</code></pre>}<br>}<br>p {<br>@if $type == ocean {<br>color: blue;<br>} @else if $type == matador {<br>color: red;<br>} @else if $type == monster {<br>color: green;<br>} @else {<br>color: black;<br>}<br>}<br>//css<br>.ib{<br>display:inline-block;<br><em>display:inline;
</em>zoom:1;<br>}<br>p {<br>color: green;<br>}<br>//三目运算<br>if($condition, $if_true, $if_false)<br>//for:@for $var from <start> through <end>和@for $var from <start> to <end><br>@for $i from 1 through 3 {<br>.item-#{$i} { width: 2em * $i; }<br>}<br>//css<br>.item-1 {<br>width: 2em;<br>}<br>.item-2 {<br>width: 4em;<br>}<br>.item-3 {<br>width: 6em;<br>}<br>//each:@each $var in <list or="" map=""><br>$animal-list: puma, sea-slug, egret, salamander;<br>@each $animal in $animal-list {<br>.#{$animal}-icon {<br>background-image: url(‘/images/#{$animal}.png’);<br>}<br>}<br>`</list></end></start></end></start></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Prefesional JS]]></title>
      <url>https://yanlee26.github.io/2016/06/08/Prefessional%20JS/</url>
      <content type="html"><![CDATA[<h1 id="JS高级教程总结"><a href="#JS高级教程总结" class="headerlink" title="JS高级教程总结"></a>JS高级教程总结</h1><h3 id="Chapter3-基本概念"><a href="#Chapter3-基本概念" class="headerlink" title="Chapter3 基本概念"></a>Chapter3 基本概念</h3><ul>
<li>3.4数据类型</li>
</ul>
<ol>
<li>五种简单类型（基本数据类型）：<br>Null,Undefined,String,Number,Boolean，symbol（ES6）<blockquote>
<p>判断：<code>typeof</code></p>
</blockquote>
</li>
</ol>
<p>1.1 Undefined:undefined</p>
<blockquote>
<p>变量声明而未初始化（显式初始化变量是好习惯）</p>
</blockquote>
<p>1.2 Null:null</p>
<blockquote>
<p>空指针，此即typeof（null）===undefined的根本原因</p>
<ul>
<li>由于ES数据类型具有动态性，故没必要定义其它类型 </li>
</ul>
<ol>
<li>一种对象类型：Object（一组数据和功能的集合）<br>判断:<code>instanceof</code><br>ES 中Object类型是所有其它实例的基础，Object类型所<br>具有的所有属性和方法同样存在于具体对象中</li>
</ol>
</blockquote>
<p><code>constructor:保存用于创建当前对象的函数（构造函数即Object）
hasOwnProperty():检查给定的属性是否在当前对象实例中
isPrototypeOf():检查传入的对象是否是传入对象的原型
propertyIsEnumerable():是否可通过for-in枚举
toLocalString():返回对象字符串表示（与本区对应）
toString():返回对象字符串表示
valueOf():返回对象的字符串，数值或者布尔值表示。同toString</code></p>
<ul>
<li>3.5操作符</li>
</ul>
<ol>
<li>一元操作符<blockquote>
<p>1.递增递减：++a,a++: 前/后置操作时决定变量值在执行操作前/后改变<br>2.加减：a+=n,a-=n<br>3.位操作符：NOT(~),OR(|),AND(&amp;),XOR(^),(&lt;&lt;),(&gt;&gt;),(&gt;&gt;&gt;)<br>4.布尔操作符：!,&amp;&amp;,||<br>5.算术性操作符：+-<em>/<br>6.关系操作符：&gt;,&lt;<br>7.相等操作符 ：<br> a.相等与否（操作数成立则true）：==,!=<br> b.全等与否（比较之前不转换操作数）：===,!==<br>8.条件操作符：variable=boolean_expression?true_value:false_value<br>9.赋值操作符：+=，-=，</em>=，/=，%=，&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=<br>10.逗号操作符：var a,b,c</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>语句</p>
<blockquote>
<ol>
<li>if(condition) statement1 else statement2</li>
<li>do{statement}while(expression)</li>
<li>while(expression) statement</li>
<li>for(initialization;expression;post-loop-expression) statement</li>
<li>for(property in expression) statement</li>
<li>label:statement</li>
<li>break/continue:break 立即跳出循环（强制继续执行循环后语句），continue立即退出<br>循环（当前循环），但从循环顶部继续执行</li>
<li>with(expression) statement</li>
<li>switch(expression){<br>case value:statement1<br>break;<br>case value:statement2<br>break;<br>…<br>case default<br>break;<br>}</li>
</ol>
</blockquote>
</li>
<li><p>3.7 函数-可以封装任意条语句，在任何地方任何时候执行</p>
<blockquote>
<p>没有重载：可以为一函数编写两个定义，只要定义的签名（接受的参数类型和数量）不同即可<br>ES中函数没有签名，真正重载不可能做到只能模拟<br>function add(n){<br>return n+100<br>}<br>function add(n){<br>return n+200<br>}//覆盖掉上一个<br>var result=add(100);//300</p>
</blockquote>
</li>
</ul>
<h3 id="Chapter4-变量作用域及内存"><a href="#Chapter4-变量作用域及内存" class="headerlink" title="Chapter4 变量作用域及内存"></a>Chapter4 变量作用域及内存</h3><blockquote>
<p>JS 变量松散的本质决定了它只是在特定时间用于保存特定值的一个名字而已</p>
</blockquote>
<p>4.1 基本类型（简单的数据段）和引用类型（可能有多个值构成的对象）</p>
<blockquote>
<p>因可以操作保存在变量中的实际值，基本数据类型按值访问；<br>引用类型值保存在内存中，不同于其它语言，JS不允许直接访问内存中的位置（操作实际对象）。<br>当复制保存着某个变量时，操作的是对象的引用；但在为对象添加属性时，操作的是实际的对象<br>访问变量的方式有按值和按引用两种，而参数只能按值传递。ES中所有函数的参数都是按值传递的！<br><a href="https://q.cnblogs.com/q/39352/" target="_blank" rel="external">JS函数参数按值传递的</a><br><code>function setName(obj){obj.name=&#39;yl&#39;;obj={};obj.name=&#39;hello&#39;} 
var p={};setName(p);p.name;//&#39;yl&#39;
//即使在内部修改了参数的值，但原始的引用仍然不变。实际上，当函数内部重写obj时，该变量引用的就是
一个在函数执行完立即销毁的局部变量了。完全可以把ES函数的参数想象成局部变量</code><br>执行环境和作用域（execution context&amp; scope）<br>EC:决定了变量或函数有权访问的其它数据，决定了它们各自的行为；每个EC都有一个与之关联的变量对象（vo）<br>,环境中定义的所有变量和函数都保存在这个对象中。虽然无法访问该对象，但解析器在处理数据时会在后台使用它。<br>某个执行环境中的所有代码执行完毕后，该环境被销毁，其中的所有变量和函数定义也随之而去。<br>每个函数都有自己的执行环境，当执行流进入一个函数时，函数环境就会被推入一个环境栈中；函数执行之后，栈将其<br>弹出，把控制权返回给之前的执行环境。<br>Scope:当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）,以保证对执行环境有权访问的<br>所有变量和函数的有序访问。其前端始终是当前执行的代码所在环境的变量对象。全局执行环境的变量对象始终都是作用<br>域链中的最后一个对象。<br>这些环境之间的联系是线性的有次序的，每个环境都可以向上搜索sc，以查询变量和函数名；但反之不行。<br>那sc可以延长吗？ 可以。。。<br>利用try-catch,with语句</p>
</blockquote>
<p>4.2 无块级作用域</p>
<blockquote>
<p>1.声明变量：使用var声明的变量会自动被添加到最近的执行环境中（在函数内部是局部环境，with语句中是<br>函数环境，如果忘记var则被添加到全局环境）2.查询标识符：当在某个环境中为了读取或写入而引用一个标识符<br> 时，必须通过搜索来确定标识符实际代表什么。</p>
</blockquote>
<p>4.3 垃圾回收GC</p>
<blockquote>
<p>标记清除(mark-sweep)和引用计数(reference-counting)<br>mark-sweep:变量进入环境即将变量标记为‘进入环境’，逻辑上永远无法释放进入环境变量所占用的内存；当变量<br>离开时，记‘离开环境’</p>
</blockquote>
<h3 id="Chapter-5-引用类型"><a href="#Chapter-5-引用类型" class="headerlink" title="Chapter 5 引用类型"></a>Chapter 5 引用类型</h3><blockquote>
<p>引用类型的值（对象）是引用类型的一个实例，ES中引用类型是用于将数据和功能组织在一起的一种数据结构。<br>常被不妥当地称为类，有时候也称对象定义。</p>
</blockquote>
<p>5.1 Object<br>5.2 Array</p>
<ul>
<li>检测：Array.isArray();instanceof Array</li>
<li>转换：toString(),join()方法</li>
<li>栈方法：push,pop</li>
<li>队列方法：shift,unshift</li>
<li>排序sort(),reverse()</li>
<li>操作方法：concat(),splice()<br>  a. delete:splice(0,2);b:insert:splice(0,2,’red’,’blue’);c:replace:splice(2,1,’a’,’b’)</li>
<li>位置方法：indexOf(),lastIndexOf()</li>
<li>迭代方法：every(),filter(),map(),forEach(),some()</li>
<li>归并：reduce(),reduceRight()<br>5.3 Date:<br>Date.parse():接收一个表示日期字符串的参数，然后尝试解析成毫秒数<br>Date.UTC()：同样返回时间戳，在构建时与parse使用不同的信息。<blockquote>
<p>日期和时间都是基于本地时区而非GMT来创建</p>
</blockquote>
</li>
</ul>
<p>5.4 RegExp<br>5.5 Function</p>
<blockquote>
<p>ES中函数即对象，每个函数都是Function的一个实例，函数名是指向函数对象的一个指针，与其它引用类型一样有属性和方法</p>
<ul>
<li>5.5.1 没有重载<br>上述重载案例与下边等价：<br><code>var add=function(n){return n+100};
add=function(n){return n+200}//覆盖上个</code></li>
<li>5.5.2函数声明与函数表达式<br>js引擎（解析器）会率先读取函数声明，并使其在执行任何代码之前可用；而对<br>函数表达式则同解析普通语句一样，等到解析器执行到其所在代码行，才被解释执行。</li>
<li>5.5.3 作为值的函数（ES中函数也是变量，所以可作为值使用）<br>`<br>function createComparisonFunction(propertyName) {<pre><code>return function(object1, object2){
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
</code></pre></li>
</ul>
</blockquote>
<pre><code>        if (value1 &lt; value2){
            return -1;
        } else if (value1 &gt; value2){
            return 1;
        } else {
            return 0;
        }
    };
}
var data = [{name: &quot;Zachary&quot;, age: 28}, {name: &quot;Nicholas&quot;, age: 29}];
data.sort(createComparisonFunction(&quot;name&quot;));
alert(data[0].name);  //Nicholas
data.sort(createComparisonFunction(&quot;age&quot;));
alert(data[0].name);  //Zachary     
</code></pre><p>`</p>
<ul>
<li>5.5.4 函数内部属性：arguments，this</li>
<li>5.5.5 函数属性和方法<blockquote>
<p>每个函数都包含两个属性：length（函数希望接收的参数个数）和prototype（对ES中引用类型而言，prototype保存了<br>其所有实例的属性和方法，即toString(),valueOf()等方法实际上保存在prototype名下，只不过通过各自对象的实例访问）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>每个函数都包含两个非继承而来的方法：call(),apply():用途是在特定作用域中调用函数，实际上是设置函数体内this指向。<br>ES5中还有一个bind方法，用于创建一个函数实例，其this值会被绑定到<br>传给bind函数的值。</p>
<p>另外每个函数继承的toString(),toLocalString()，valueOf()始终返回函数代码</p>
</blockquote>
<p><code>function sayColor=function(){alert(this.color)}
window.color=&#39;red&#39;;
var o={color:&#39;blue&#39;};
var objSayColor=sayColor.bind(o);
objSayColor();//&#39;blue&#39;</code></p>
<ul>
<li>5.5.6 基本包装对象<blockquote>
<p>ES提供了三个特殊的引用类型（Boolean,Number,String），与其它引用类型类似但也具有各自基本类型相应的行为<br>注意：引用类型和基本类型主要区别就是对象生命周期：使用new操作符创建的引用类型实例，在执行流离开当前作用域之前<br>一直保存在内存中。而自动创建的基本包装对象，只存在于一行代码执行的瞬间，然后立即销毁。即我们不能给基本类型添加<br>属性和方法。<br>Object构造函数如工厂方法一样，根据传入值的类型返回基本包装对象实例</p>
</blockquote>
</li>
</ul>
<p><code>var obj=new Object(&#39;hello&#39;);obj instanceOf String;//true</code></p>
<ul>
<li>5.6.1 Boolean <blockquote>
<p>Boolean实例重写了valueOf()方法并返回true/false；重写了toString()方法，返回’true’/‘false’<br>注意：布尔表达式中所有对象都会被转换为true<br>`</p>
</blockquote>
</li>
</ul>
<p>var a=new Boolean(true)<br>undefined<br>a<br>Boolean {[[PrimitiveValue]]: true}<br>a.toString()<br>“true”<br>a.valueOf()<br>true<br>`</p>
<ul>
<li>5.6.2 Number<blockquote>
<p>方法：toFixed(),toExponential(),toPrecision()</p>
</blockquote>
</li>
<li>5.6.3 String</li>
</ul>
<ol>
<li>字符方法<blockquote>
<p>charAt(),charCodeAt()</p>
</blockquote>
</li>
<li>字符操作方法<blockquote>
<p>concat(),slice(),subString(),substr(),</p>
</blockquote>
</li>
<li>字符串位置方法<blockquote>
<p>indexOf(),lastIndexOf()</p>
</blockquote>
</li>
<li>trim(),trimLeft(),trimRight()方法</li>
<li>大小写转换方法<blockquote>
<p>toLocalUpperCase(),toUpperCase(),toLowerCase()</p>
</blockquote>
</li>
<li>模式匹配方法<blockquote>
<p>search(),replace(),match(),split()</p>
</blockquote>
</li>
<li>localeCompare()方法，fromCharCode()方法</li>
</ol>
<ul>
<li>5.7 单体内置对象<blockquote>
<p>定义：由ES实现提供的不依赖于宿主环境的对象，即在ES程序执行之前既存在了</p>
</blockquote>
</li>
</ul>
<ol>
<li>Global对象（兜底对象，任何不属于其它对象的属性和方法都是它的属性和方法）<blockquote>
<p>如isNaN()，isFinite(),parseInt(),parseFloat(),encodeURI(),encodeURIComponent()<br>eval(),window对象，Math对象（min(),max(),ceil(),floor(),random()）</p>
</blockquote>
</li>
</ol>
<h3 id="Chapter-6-面向对象-Object-Oriented-Programing"><a href="#Chapter-6-面向对象-Object-Oriented-Programing" class="headerlink" title="Chapter 6 面向对象 Object Oriented Programing"></a>Chapter 6 面向对象 Object Oriented Programing</h3><blockquote>
<p>ES对象：包含基本值，对象或函数的无序属性的集合。</p>
</blockquote>
<p>6.1.1 属性类型（数据属性+访问器属性）</p>
<ol>
<li>数据属性：</li>
</ol>
<ul>
<li>[[Configurable]]:是否可配置，delete(true)</li>
<li>[[Enumerable]]: 是否可枚举，for-in(true)</li>
<li>[[Writable]]:是否可写(true)</li>
<li>[[Writable]]:包含这个属性的数据值（undefined）<blockquote>
<p>ES5中Object.defineProperty(object,propertyName,descriptor)方法，包含属性所在对象，属性名，描述符对象三个参数，可以修改对象的默认特性。<br>注意：一旦把属性定义为不可配置的就再也甭能把它设置成可配置的了。</p>
</blockquote>
</li>
</ul>
<ol>
<li>访问器特性，对象的属性：<blockquote>
<p>不包含数据值，包含一对getter，setter函数（非必须），有以下四个特性。访问器属性不能直接定义，必须用<br>Object.defineProperty()定义，Object.defineProperties()可以定义多个属性</p>
</blockquote>
</li>
</ol>
<ul>
<li>[[Configurable]]:同上(true)</li>
<li>[[Enumerable]]:同上(true)</li>
<li>[[Get]]:读取属性时调用的函数（undefined）</li>
<li><p>[[Set]]:写入属性时调用的函数（undefined）<br>`<br>var book = {</p>
<pre><code>    _year: 2004,
    edition: 1
};
Object.defineProperty(book, &quot;year&quot;, {
    get: function(){
        return this._year;
    },
    set: function(newValue){

        if (newValue &gt; 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;

        }
    }
});

book.year = 2005;
alert(book.edition);   //2
</code></pre><p>`<br>6.1.3 读取属性特性</p>
<blockquote>
<p>Object.getOwnPropertyDescriptor()方法，两个参数属性所在的对象+读取其描述符的属性名，返回一对象.<br>JS中可以针对任何对象（BOM，DOM），使用该方法。<br>`<br>var descriptor = Object.getOwnPropertyDescriptor(book, “_year”);</p>
<pre><code>alert(descriptor.value);          //2004
alert(descriptor.configurable);   //false
alert(typeof descriptor.get);     //&quot;undefined&quot;
var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);
alert(descriptor.value);          //undefined
alert(descriptor.enumerable);     //false
alert(typeof descriptor.get);     //&quot;function&quot;`
</code></pre></blockquote>
</li>
</ul>
<p>6.2 创建对象<br>6.2.1 工厂模式—用函数来封装以特定接口创建对象的细节</p>
<blockquote>
<p>特点：虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题(怎样知道对象类型)。<br><code>function createPerson(name, age, job){
            var o = new Object();
            o.name = name;
            o.age = age;
            o.job = job;
            o.sayName = function(){
                alert(this.name);
            };    
            return o;
        }
        var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.sayName();   //&quot;Nicholas&quot;
        person2.sayName();   //&quot;Greg&quot;</code></p>
</blockquote>
<p>6.2.2 构造函数模式—如Object，Array这样的原生构造函数，运行时会自动出现在EC中，也可创建自定义的。<br><code>function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = function(){
                alert(this.name);
            };    
        }
        var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.sayName();   //&quot;Nicholas&quot;
        person2.sayName();   //&quot;Greg&quot;
        alert(person1 instanceof Object);  //true
        alert(person1 instanceof Person);  //true
        alert(person2 instanceof Object);  //true
        alert(person2 instanceof Person);  //true
        alert(person1.constructor == Person);  //true
        alert(person2.constructor == Person);  //true
        alert(person1.sayName == person2.sayName);  //false</code></p>
<blockquote>
<p>特点：没有显式创建对象，没有return语句，直接将属性和方法赋给this，首字母大写，必须使用new构建实例。<br>优点：可以将构造函数的实例标识为一种特定的类型；<br>缺点：每个方法都要在每个实例上创建一遍，不同实例上同名函数是不同的。<br><code>this.sayName=new Function(&#39;alert(this.name)&#39;);//与声明函数逻辑上等价
person1.sayName===person2.sayName;//false
//优化，但此时全局函数有些名不副实
this.sayName=sayName;
function sayName(){}</code></p>
</blockquote>
<p>6.2.3 原型模式</p>
<blockquote>
<p>我们创建的每个函数，都有一个指向一个对象的且是一个指针的prototype属性，其作用是包含可以有特定<br>类型所有实例共享的属性和方法。即prototype通过调用构造函数而创建的那个实例的原型对象。此时可以将所有实例共享其所包含的属性和方法。<br>优点：让任意实例共享其原型对象所包含的所有属性和方法。<br>缺点：省略了为构造函数传递初始化参数这一环节，导致所有实例默认获得相同属性，对于包含引用类型的属性而言，问题不可忽视</p>
</blockquote>
<p>`<br>//原型模式案例<br>function Person(){<br>        }<br>        Person.prototype.name = “Nicholas”;<br>        Person.prototype.age = 29;<br>        Person.prototype.job = “Software Engineer”;<br>        Person.prototype.sayName = function(){<br>            alert(this.name);<br>        };</p>
<pre><code>var person1 = new Person();
person1.sayName();   //&quot;Nicholas&quot;

var person2 = new Person();
person2.sayName();   //&quot;Nicholas&quot;

alert(person1.sayName == person2.sayName);  //true

alert(Person.prototype.isPrototypeOf(person1));  //true
alert(Person.prototype.isPrototypeOf(person2));  //true

//only works if Object.getPrototypeOf() is available
if (Object.getPrototypeOf){
    alert(Object.getPrototypeOf(person1) == Person.prototype);  //true
    alert(Object.getPrototypeOf(person1).name);  //&quot;Nicholas&quot;
}
//虽然可以通过实例访问原型中的值，但不能通过对象实例重写原型中的值。只是‘屏蔽’
person1.name = &quot;Greg&quot;;
alert(person1.name);   //&quot;Greg&quot; – from instance
alert(person2.name);   //&quot;Nicholas&quot; – from prototype
//使用delete操作符完全可以删除该属性
delete person1.name;
alert(person1.name);   //&quot;Nicholas&quot; - from the prototype
//hasOwnProperty（）,in操作符结合
function hasPrototypeProperty(object,name){return !object.hasOwnProperty(name)&amp;&amp;(name in object)}
//ES5中的Object.keys()方法用于取得对象上所有可枚举的对象属性，接收一个对象为参数返回一个包含所有可枚举属性的字符串数组
var keys=Object.keys(Person.prototype)
//简化的原型语法,对象字面量形式创建的对象，但此时constructor不再指向Person了
//此种写法本质上重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object）
Person.prototype={
constructor:Person,//加上此句话重设constructor，此举导致constructor的[[Enumerable]]被设置为true，默认false
 name:&apos;Tom&apos;,
 age:&apos;18&apos;,
 say:function(){}
}
//要消除此bug还需要再加这句话
Object.defineProperty(Person.prptotype,&apos;constructor&apos;,{
enumerable:false,
value:Person
})
//原生对象的原型
Array.prototype===[].__proto__
String.prototype===&apos;&apos;.__proto__
Object.prototype==={}.__proto__
//此方法困境
 Person.prototype = {
            constructor: Person,
            name : &quot;Nicholas&quot;,
            age : 29,
            job : &quot;Software Engineer&quot;,
            friends : [&quot;Shelby&quot;, &quot;Court&quot;],
            sayName : function () {
                alert(this.name);
            }
        };
        var person1 = new Person();
        var person2 = new Person();
        person1.friends.push(&quot;Van&quot;);
        alert(person1.friends);    //&quot;Shelby,Court,Van&quot;
        alert(person2.friends);    //&quot;Shelby,Court,Van&quot;
        alert(person1.friends === person2.friends);  //true
</code></pre><p>`<br>6.2.4 组合使用构造函数和原型模式—用途广泛，认可度最高，首选</p>
<p><code>function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];
        }
        Person.prototype = {
            constructor: Person,
            sayName : function () {
                alert(this.name);
            }
        };
        var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.friends.push(&quot;Van&quot;);
        alert(person1.friends);    //&quot;Shelby,Court,Van&quot;
        alert(person2.friends);    //&quot;Shelby,Court&quot;
        alert(person1.friends === person2.friends);  //false
        alert(person1.sayName === person2.sayName);  //true</code><br>6.2.5 动态原型模式</p>
<blockquote>
<p>把所有信息封装在构造函数中，通过构造函数初始化原型，保持了同时使用构造函数和原型的优点。即<br>可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型.<br>谨记：此时不能使用对象字面量重写原型，否则会切断实例与新原型之间的联系</p>
</blockquote>
<p>`<br>function Person(name, age, job){</p>
<pre><code>    //properties
    this.name = name;
    this.age = age;
    this.job = job;

    //methods
    if (typeof this.sayName != &quot;function&quot;){

        Person.prototype.sayName = function(){
            alert(this.name);
        };

    }
}
var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
friend.sayName();
</code></pre><p>`<br>6.2.6 寄生构造函数模式</p>
<blockquote>
<p>返回的对象与构造函数或者构造函数与原型属性之间没关系。</p>
</blockquote>
<p>`<br>function SpecialArray(){       </p>
<pre><code>    //create the array
    var values = new Array();

    //add the values
    values.push.apply(values, arguments);

    //assign the method
    values.toPipedString = function(){
        return this.join(&quot;|&quot;);
    };

    //return it
    return values;        
}

var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);
alert(colors.toPipedString()); //&quot;red|blue|green&quot;
alert(colors instanceof SpecialArray);
</code></pre><p>`<br>6.2.7 稳妥构造函数模式</p>
<p><code>function Person(name,age,job){
var o=new Object;
o.sayName=function(){alert(name)}
return o
}
var p1=new Person(&#39;yl&#39;,26,&#39;software engineer&#39;);
p1.sayName();//&#39;yl&#39;</code><br>6.3 继承（接口继承和实现继承（ES仅支持此继承））—依赖原型链继承<br>6.3.1 原型链</p>
<blockquote>
<p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<p>`<br> function SuperType(){<br>            this.property = true;<br>        }</p>
<pre><code>SuperType.prototype.getSuperValue = function(){
    return this.property;
};

function SubType(){
    this.subproperty = false;
}

//inherit from SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function (){
    return this.subproperty;
};

var instance = new SubType();
alert(instance.getSuperValue());   //true

alert(instance instanceof Object);      //true
alert(instance instanceof SuperType);   //true
alert(instance instanceof SubType);     //true

alert(Object.prototype.isPrototypeOf(instance));    //true
alert(SuperType.prototype.isPrototypeOf(instance)); //true
alert(SubType.prototype.isPrototypeOf(instance));   //true
</code></pre><p>`<br>6.3.2 借用构造函数</p>
<p>`<br> function SuperType(){<br>            this.colors = [“red”, “blue”, “green”];<br>        }</p>
<pre><code>function SubType(){  
    //inherit from SuperType
    SuperType.call(this);
}
//传递参数
 function SubType(){  
            //inherit from SuperType passing in an argument
            SuperType.call(this, &quot;Nicholas&quot;);

            //instance property
            this.age = 29;
        }

var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);    //&quot;red,blue,green,black&quot;

var instance2 = new SubType();
alert(instance2.colors);    //&quot;red,blue,green&quot;
</code></pre><p>`<br>6.3.3 组合继承</p>
<blockquote>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承<br>`<br>function SuperType(name){<br>            this.name = name;<br>            this.colors = [“red”, “blue”, “green”];<br>        }</p>
</blockquote>
<pre><code>SuperType.prototype.sayName = function(){
    alert(this.name);
};

function SubType(name, age){  
    SuperType.call(this, name);

    this.age = age;
}

SubType.prototype = new SuperType();

SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType(&quot;Nicholas&quot;, 29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);  //&quot;red,blue,green,black&quot;
instance1.sayName();      //&quot;Nicholas&quot;;
instance1.sayAge();       //29

var instance2 = new SubType(&quot;Greg&quot;, 27);
alert(instance2.colors);  //&quot;red,blue,green&quot;
instance2.sayName();      //&quot;Greg&quot;;
instance2.sayAge();       //27
</code></pre><p>`<br>6.3.4 原型式继承</p>
<p>`<br>var person = {<br>            name: “Nicholas”,<br>            friends: [“Shelby”, “Court”, “Van”]<br>        };</p>
<pre><code>var anotherPerson = Object.create(person);
anotherPerson.name = &quot;Greg&quot;;
anotherPerson.friends.push(&quot;Rob&quot;);

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = &quot;Linda&quot;;
yetAnotherPerson.friends.push(&quot;Barbie&quot;);

alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;
</code></pre><p>`<br>6.3.5 寄生式继承</p>
<p>`</p>
<p>`<br>6.3.6 寄生组合式继承</p>
<p>`<br>function object(o){<br>            function F(){}<br>            F.prototype = o;<br>            return new F();<br>        }</p>
<pre><code>function inheritPrototype(subType, superType){
    var prototype = object(superType.prototype);   //create object
    prototype.constructor = subType;               //augment object
    subType.prototype = prototype;                 //assign object
}

function SuperType(name){
    this.name = name;
    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
};

function SubType(name, age){  
    SuperType.call(this, name);

    this.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType(&quot;Nicholas&quot;, 29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);  //&quot;red,blue,green,black&quot;
instance1.sayName();      //&quot;Nicholas&quot;;
instance1.sayAge();       //29
var instance2 = new SubType(&quot;Greg&quot;, 27);
alert(instance2.colors);  //&quot;red,blue,green&quot;
instance2.sayName();      //&quot;Greg&quot;;
instance2.sayAge();       //27
</code></pre><p>`</p>
<h3 id="Chapter-7-函数表达式-与函数声明的区别"><a href="#Chapter-7-函数表达式-与函数声明的区别" class="headerlink" title="Chapter 7 函数表达式(与函数声明的区别)"></a>Chapter 7 函数表达式(与函数声明的区别)</h3><p>7.1 递归<br> arguments.callee是一个指向正在执行函数的指针，实现递归<br>`</p>
<p>function factorial(num){<br>                if (num &lt;= 1){<br>                    return 1;<br>                } else {<br>                    //return num<em>factorial(num-1)<br>                    return num </em> arguments.callee(num-1);<br>                }<br>            }<br>            var anotherFactorial = factorial;<br>            factorial = null;<br>            //alert(anotherFactorial(4));  //error<br>            alert(anotherFactorial(4));  //24<br>            // //严格模式下debug—使用命名函数表达式<br>            var factorial=(function f(num){<br>            if(num&lt;-1){return 1}<br>            else{return num*f(num-1)}<br>            })<br>`<br>7.2 闭包closure</p>
<blockquote>
<p>匿名函数与闭包：前者-创建一个函数并赋值给变量；后者-有权访问另一个函数作用域中变量的函数（在一个函数内创建另一函数）。<br>原理：明白作用域链的概念，当某函数被调用时，会创建一个EC及相应的作用域链；<br>然后使用arguments和其它命名参数的值来初始化函数的活动对象（activation object）<br>此时，外部函数作用域链处于第二位，再外的第三位，。。。，最外到全局执行环境。<br>其实，作用域链包含两级变量对象–本地活动对象和全局变量对象，其本质是一个指向<br>变量对象的指针列表，仅仅引用并不包含变量对象。</p>
</blockquote>
<p>7.2.1 闭包与变量</p>
<blockquote>
<p>闭包的副作用：只能取得包含函数中任何变量的最后一个值。</p>
</blockquote>
<p><code>function createFunctions(){
                var result = new Array();
                for (var i=0; i &lt; 10; i++){
                    result[i] = function(){
                        return i;
                    };
                }
                return result;
            }
        var funcs = createFunctions();
            //every function outputs 10
            //原因：每个函数作用域链中都保存着createFunctions()函数的活动对象，它们引用的是
            同一个变量i。当createFunction（）函数返回后，i都是10.
            for (var i=0; i &lt; funcs.length; i++){
                document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);
            }
        //解决方案如下：创建一个匿名函数强制让闭包行为符合预期（函数参数是按值传递的）
        for (var i=0; i &lt; 10; i++){
                            result[i] = function(num){
                                return function(){
                                    return num;
                                };
                            }(i);
                        }
        //或者用ES6语法变var i为let i</code><br>7.2.2 关于this对象</p>
<blockquote>
<p>this对象是在运行时基于函数的执行环境绑定的：在全局下this===window；当函数被作为某个对象的方法<br>调用时，this===调用其的对象。但匿名函数的作用域具有全局性，其this对象通常指向window；除非通过call（）<br>apply()改变。</p>
</blockquote>
<p>`<br>var name = “The Window”;<br>    var object = {<br>        name : “My Object”,<br>        getNameFunc : function(){<br>            //var that=this;<br>            return function(){<br>                return this.name;<br>                //return that.name;<br>            };<br>        }<br>    };<br>alert(object.getNameFunc()());  //“The Window”<br>//细微变化可能改变this<br>var name=’window’;<br>var obj={name:’obj’,getName:function(){return this.name}}<br>obj.getName();//‘obj’<br>(obj.getName)();//‘obj’<br>(obj.getName=obj.getName)();//‘window’,this得不到维持</p>
<p>`</p>
<blockquote>
<p>原因分析：每个函数在调用时都会自动取得两个特殊变量this和arguments；内部函数在搜索<br>此二变量时只会搜索到其活动对象为之，故永不可能直接访问外部函数中此二变量。一种解决方式是把外部作用<br>域中this对象保存在闭包中。如上注释部分。</p>
</blockquote>
<p>7.2.3 内存泄漏</p>
<blockquote>
<p>闭包会引用包含函数的整个活动对象！即使闭包不直接引用ele，包含函数的活动对象也仍然<br>会保存一个引用。<br><code>function assignHandler(){
    var ele=document.getElementById(&#39;xx&#39;);
    var id=ele.id;//抽出闭包中循环引用的变量
    ele.onclick=function(){}
    ele=null;//清除对dom对象的引用
}</code></p>
</blockquote>
<p>7.2.4 模仿块级作用域</p>
<blockquote>
<p>JS 从不会告诉你是否声明了同一个变量；只会无视后续声明（会执行声明的初始化），匿名函数可以<br>模仿块级作用域并避免此问题。并且只要做到闭包中没有指向匿名函数的引用，就可以减少闭包占用内存的问题。<br><code>(function(){//block scope})();
var someFunction=function(){//block scope}
function(){//block scope}();//error ,函数声明不能跟（），js将function当作函数声明的开始</code></p>
</blockquote>
<p>7.2.5 private variables私有变量</p>
<blockquote>
<p>事实上，JS中没有私有成员的概念；所有对象的属性都是公有的。但有个私有变量的概念—任何在函数<br>中定义的变量。<br>特权方法（privileged method）: 有权访问私有变量和私有函数的公有方法。有以下两种<br>但在函数中定义特权有个缺点：必须使用构造函数模式实现，其缺点是每个实例都会创建一组新方法，使用静态私有变量<br>可以避免此问题（私有变量和函数是由实例共享的，作为一个闭包总是保存着对包含作用域的引用）。</p>
</blockquote>
<p>`<br>//模式一：在构造函数中定义特权方法，将特权方法作为闭包（有权访问在构造函数中的所有属性和方法）<br>function MyObject(){<br>    //私有变量和私有函数<br>    var privateVariable=10;<br>    function privateFunction(){<br>        return false;<br>    }<br>    //特权方法<br>    this.publicMethod=functionn(){<br>        privateVariable++;<br>        return privateFunciton();<br>    }<br>}<br>// 使用静态私有变量<br>(function(){<br>    var name = “”;<br>    Person = function(value){<br>        name = value;<br>    };<br>    Person.prototype.getName = function(){<br>        return name;<br>    };<br>    Person.prototype.setName = function (value){<br>        name = value;<br>    };<br>})();<br>var person1 = new Person(“Nicholas”);<br>alert(person1.getName());   //“Nicholas”<br>person1.setName(“Greg”);<br>alert(person1.getName());   //“Greg”<br>var person2 = new Person(“Michael”);<br>alert(person1.getName());   //“Michael”<br>alert(person2.getName());   //“Michael”</p>
<p>`</p>
<ol>
<li><p>4.2 模块模式</p>
<blockquote>
<p>上述模式用于为自定义类型创建私有变量和特权方法，而模块模式则是为单例创建私有变量和特权的方法。<br>`</p>
<pre><code>function BaseComponent(){
}
</code></pre></blockquote>
<pre><code>function OtherComponent(){
}

var application = function(){

    //private variables and functions
    var components = new Array();

    //initialization
    components.push(new BaseComponent());

    //public interface
    return {
        getComponentCount : function(){
            return components.length;
        },

        registerComponent : function(component){
            if (typeof component == &quot;object&quot;){
                components.push(component);
            }
        }
    };
}();

application.registerComponent(new OtherComponent());
//增强的模块模式
function BaseComponent(){
            }

            function OtherComponent(){
            }

            var application = function(){

                //private variables and functions
                var components = new Array();

                //initialization
                components.push(new BaseComponent());

                //create a local copy of application
                var app = new BaseComponent();

                //public interface
                app.getComponentCount = function(){
                    return components.length;
                };

                app.registerComponent = function(component){
                    if (typeof component == &quot;object&quot;){
                        components.push(component);
                    }
                };

                //return it
                return app;
            }();
            alert(application instanceof BaseComponent);
            application.registerComponent(new OtherComponent());
            alert(application.getComponentCount());  //2
</code></pre><p>`</p>
<h3 id="Chapter-8-BOM"><a href="#Chapter-8-BOM" class="headerlink" title="Chapter 8 BOM"></a>Chapter 8 BOM</h3></li>
<li>1 window对象</li>
<li><p>1.1 global scope</p>
<blockquote>
<p>定义的全局变量和在window上直接定义的变量细微差别就是前者不可以用delete操作符删除<br>var a=’hello’;window.b=’world’;delete window.a;//false;delete window.b;//true<br>因var 添加的window属性的[[Configurable]]===false</p>
</blockquote>
</li>
<li><p>1.2 窗口关系及框架</p>
</li>
<li>1.3 窗口位置<br>`<br>//使用下边代码可以跨浏览器取得窗口左边和上边位置。<br>var leftPos = (typeof window.screenLeft == “number”) ? <pre><code>                  window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == &quot;number&quot;) ? 
                  window.screenTop : window.screenY;
alert(&quot;Left: &quot; + leftPos);
alert(&quot;Top: &quot; + topPos);
</code></pre><code>8.1.4 窗口大小</code><br>var pageWidth = window.innerWidth,<pre><code>    pageHeight = window.innerHeight;
if (typeof pageWidth != &quot;number&quot;){
    if (document.compatMode == &quot;CSS1Compat&quot;){
        pageWidth = document.documentElement.clientWidth;
        pageHeight = document.documentElement.clientHeight;
    } else {
        pageWidth = document.body.clientWidth;
        pageHeight = document.body.clientHeight;
    }
}
alert(&quot;Width: &quot; + pageWidth);
alert(&quot;Height: &quot; + pageHeight);
</code></pre>`</li>
<li>1.5 导航和打开<br><code>window.open();
// 接收四个参数：URL，窗口目标，一个特性字符串，布尔值</code><br>8.1.6 setInterval()和setTimeOut()<br>8.1.7 系统对话框：alert(),confirm(),prompt()<br>8.2 location 对象<br><code>window.location===document.location</code></li>
<li>3 navigator对象</li>
<li>4 screen对象</li>
<li><p>5 history对象</p>
<h3 id="Chapter-9-客户端检查"><a href="#Chapter-9-客户端检查" class="headerlink" title="Chapter 9 客户端检查"></a>Chapter 9 客户端检查</h3><h3 id="Chapter-10-DOM"><a href="#Chapter-10-DOM" class="headerlink" title="Chapter 10 DOM"></a>Chapter 10 DOM</h3><blockquote>
<p>DOM是针对HTML和XML文档的一个API，描绘了一个层次化的节点树，允许开发人员增删改<br>查页面的一部分。注意IE中的DOM对象都是以COM对象的形式实现的。</p>
</blockquote>
</li>
<li><p>1 节点层次</p>
<blockquote>
<p>DOM树：DOM可以将HTML，XML文档描述成一个由多层次节点构成的结构。节点分几种不同的类型，<br>每种类型分别表示文档中不同的信息及标记。每个节点都有自己的特点数据和方法且与其它节点存在<br>关系，由此构成了层次，所有页面标记则表现为一个以特定节点为根节点的树形结构。每一段标记<br>都可以通过树中一个节点来表示（html元素由元素节点表示，attribute由属性节点表示，documentType由文档<br>类型节点表示，commit由注释节点表示）。</p>
</blockquote>
</li>
<li><p>1.1 Node类型（12种）</p>
<ol>
<li><strong>Node.ELEMENT_NODE(1)</strong>;</li>
<li><strong>Node.ATTRIBUTE_NODE(2)</strong>;</li>
<li><strong>Node.TEXT_NODE(3);</strong></li>
<li>Node.ENTITY_REFERENCE_NODE(5);</li>
<li>Node.ENTITY_NODE(6);</li>
<li>Node.PROCESSING_INSTRUCTION_NODE(7);</li>
<li><strong>Node.COMMIT_NODE(8);</strong></li>
<li><strong>Node.DOCUMENT_NODE(9);</strong></li>
<li><strong>Node.DOCUMENT_TYPE_NODE(10);</strong></li>
<li>Node.DOCUMENT_FRAGMENT_NODE(11);</li>
<li>Node.NOTATION_NODE(12);<h3 id="Chapter11-DOM扩展"><a href="#Chapter11-DOM扩展" class="headerlink" title="Chapter11 DOM扩展"></a>Chapter11 DOM扩展</h3><blockquote>
<p>DOM扩展主要是selectorsAPI和H5</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<ul>
<li>querySelector()</li>
<li>querySelectorAll()</li>
<li>matchesSelector()</li>
<li>元素遍历<ol>
<li>childElementCount:返回子元素（不含文本节点和注释）个数；</li>
<li>firstElementChild:指向首子元素；</li>
<li>lastElementChild:指向首尾元素；</li>
<li>previousElementSibling:指向前一个同辈元素；</li>
<li>nextElementSibling:指向后一个同辈元素；</li>
</ol>
</li>
</ul>
<ol>
<li><p>3HTML5</p>
<blockquote>
<p>H5规范围绕如何使用新增标记定义了大量的JS API。其中一些与DOM重叠，定义了浏览器应该支持的DOM扩展</p>
</blockquote>
</li>
<li><p>3.1与类相关的扩充</p>
</li>
</ol>
<ul>
<li>getElementByClassName():返回带有指定类的所有元素的NodeList；</li>
<li>classList():<ol>
<li>div.classList.remove(‘user’):删除类集中某类</li>
<li>div.classList.add(‘user’):添加类集中某类</li>
<li>div.classList.toggle(‘user’):切换类集中某类</li>
<li>div.classList.contains(‘user’):查询类集中某类</li>
</ol>
</li>
</ul>
<ol>
<li>3.2焦点管理<br><code>var btn=document.getElementById(&#39;my-button&#39;);
btn.focus();
document.hasFocus();//true
//通过检查文档是否活得了焦点来判断用户是否在与页面交互</code></li>
<li>3.3 HTMLDocument的变化</li>
</ol>
<ul>
<li>readyState属性：loading（加载中）,complete(已完成)</li>
<li>compatMode兼容模式<br><code>alert(document.compatMode==&#39;CSS1Compat&#39;?&#39;Standards Mode&#39;:&#39;Quicks Mode&#39;)</code></li>
<li>head 属性<br><code>var head=document.head||document.getElementsByTagName(&#39;head&#39;[0])</code></li>
</ul>
<ol>
<li>3.4 字符集属性<br><code>document.charset;//UTF-8</code></li>
<li>3.5自定义数据属性data-<blockquote>
<p>目的是为元素提供与渲染无关的信息，或者提供语义信息，可以任意添加随便命名，但要以data-开头。</p>
</blockquote>
</li>
</ol>
<p>11 .3.6插入标记</p>
<blockquote>
<p>DOM操作的福音：虽然DOM操作可以实现细致入微的控制，但非常繁琐，使用插入标记<br>技术直接插入html字符串不仅简单而且高效。但多说浏览器中插入的script脚本并不会<br>执行（除非指定defer属性且位于（微软所谓的）作用域之后）</p>
</blockquote>
<ul>
<li>innerHTML<br><code>document.querySelector(&#39;div&#39;).innerHTML=&#39;&lt;script defer&gt;alert(&quot;hi&quot;)&lt;/script&gt;&#39;</code></li>
<li>outerHTML</li>
<li>insertAdjacentHTML()<h3 id="Chapter12-DOM2和DOM3"><a href="#Chapter12-DOM2和DOM3" class="headerlink" title="Chapter12 DOM2和DOM3"></a>Chapter12 DOM2和DOM3</h3><h3 id="Chapter13-事件处理程序"><a href="#Chapter13-事件处理程序" class="headerlink" title="Chapter13 事件处理程序"></a>Chapter13 事件处理程序</h3></li>
</ul>
<ol>
<li>2.2 DOM0级事件处理程序<blockquote>
<p>介绍：传统方式，将一个函数赋值给一个事件处理程序属性。特点：简单，跨<br>浏览器。首先要取得要操作对象的引用。<br>DOM0级事件处理程序被称为元素的方法，因此时事件处理程序是在元素作用域中执行的。</p>
</blockquote>
</li>
</ol>
<p><code>var btn=document.getElementById(&#39;xx&#39;);
btn.onclick=functin(){}；
btn.onclick=null;//删除事件处理程序</code></p>
<ol>
<li>2.3 DOM2级事件处理程序<blockquote>
<p>DOM2定义了两个方法用于指定和删除处理程序的操作：addEventListener()和removeEventListener()<br>所有DOM节点都包含这两个方法且接受三个参数：事件名，函数，布尔值（true:捕获，false冒泡）<br>多数情况下将事件处理程序添加到事件流的冒泡阶段，可以最大限度地兼容各种浏览器。<br><code>btn.addEventListener(&#39;click&#39;,function(){
},false);
btn.removeEventListener(&#39;click&#39;,function(){
},false);</code></p>
</blockquote>
</li>
<li>2.4IE事件处理程序<br><code>btn.attach(&#39;onclick&#39;,function(){});
btn.detach(&#39;onclick&#39;,function(){});</code></li>
<li>2.5跨浏览器事件处理程序</li>
<li>3事件对象<blockquote>
<p>触发DOM上某事件时会产生一个包含与事件相关信息的事件对象。<br>只有在事件处理程序执行期间，event对象才会存在，否则立即销毁。</p>
</blockquote>
</li>
</ol>
<p>`<br>btn.onclick=function(event){alert(event.type)}<br>btn.addEventListener(‘click’,function(event){alert(event.type)}<br>//stopPropagation用于阻止事件在DOM上传播（捕获或冒泡）<br>var btn = document.getElementById(“myBtn”);<br>        btn.onclick = function(event){<br>            alert(“Clicked”);<br>            event.stopPropagation();<br>        };</p>
<pre><code>document.body.onclick = function(event){
    alert(&quot;Body clicked&quot;);
};
</code></pre><p>`</p>
<ol>
<li>4事件类型</li>
<li>4.1 UI事件：不一定与用户操作有关的事件。包括DOMActive(非html事件),load,unload,abort<br>error,select,resize,scroll事件。<br><code>var isSurpported=document.implementation.hasFeature(&#39;HTMLEventts&#39;,&#39;2.0&#39;);
var isSurpported=document.implementation.hasFeature(&#39;UIEvent&#39;,&#39;3.0&#39;);</code></li>
<li>4.2 焦点事件：blur,focusIn,focusOut,focus</li>
<li>4.3 鼠标与滚轮事件：click,dbclick,mousedown,mouseenter,mouseleave,mousemove,<br>mouseout,mouseover,mouseup</li>
<li>4.4键盘与文本事件：keydowm,keyup,keypress</li>
<li>4.5 复合事件</li>
<li>4.6 变动事件</li>
<li>4.7 HTML5事件：contextmenu,beforeunload,DOMContentloaded,readystatechange<br>pageshow,pagehide,haschange</li>
<li>4.8 设备事件</li>
<li>4.9 触摸与手势事件touchEvents</li>
</ol>
<ul>
<li>触摸事件<ol>
<li>touchstart</li>
<li>touchmove</li>
<li>touchend</li>
<li>touchcancel</li>
</ol>
</li>
<li>手势事件<ol>
<li>gesturestart</li>
<li>gesturechange</li>
<li>gestureend</li>
</ol>
</li>
</ul>
<ol>
<li>5 内存和性能<blockquote>
<p>每个函数都是对象，会占用内存，内存中对象越多性能越差；必须事先指定所有事件<br>处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。解决之道是使用事件委托或<br>移除事件处理程序。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>事件委托：只需在DOM树中尽量最高的层次上添加一个事件处理程序<br>`<br>(function(){<br>var list = document.getElementById(“myLinks”);</p>
<pre><code>EventUtil.addHandler(list, &quot;click&quot;, function(event){
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    switch(target.id){
        case &quot;doSomething&quot;:
            document.title = &quot;I changed the document&apos;s title&quot;;
            break;

        case &quot;goSomewhere&quot;:
            location.href = &quot;http://www.wrox.com&quot;;
            break;

        case &quot;sayHi&quot;:
            alert(&quot;hi&quot;);
            break;
    }
});
</code></pre><p>  })();<br>  btn.onclick=function(){</p>
<pre><code>//过河
btn.onclick=null;//拆桥
//...
</code></pre><p>  }<br>`</p>
</li>
</ul>
<ol>
<li>6模拟事件</li>
</ol>
<ul>
<li><p>DOM中的事件模拟：document.createEvent()方法创建对象。<br>`<br>(function(){</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
var btn2 = document.getElementById(&quot;myBtn2&quot;);

EventUtil.addHandler(btn, &quot;click&quot;, function(event){
    alert(&quot;Clicked!&quot;);
    alert(event.screenX);   //100
});

EventUtil.addHandler(btn2, &quot;click&quot;, function(event){
    //create event object
    var event = document.createEvent(&quot;MouseEvents&quot;);
    //initialize the event object
    event.initMouseEvent(&quot;click&quot;, true, true, document.defaultView, 0, 100, 0, 0, 0, false, 
                         false, false, false, 0, btn2);
    //fire the event
    btn.dispatchEvent(event);
});
</code></pre><p>  })();<br>`</p>
<h3 id="Chapter-14-表单脚本"><a href="#Chapter-14-表单脚本" class="headerlink" title="Chapter 14 表单脚本"></a>Chapter 14 表单脚本</h3></li>
<li><p>自动切换焦点<br>`<br>  <body></body></p>
<pre><code>&lt;form method=&quot;post&quot; action=&quot;http://www.nczonline.net&quot;&gt;
    &lt;p&gt;Enter your telephone number:&lt;/p&gt;
    &lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; size=&quot;3&quot; maxlength=&quot;3&quot; &gt;
    &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; size=&quot;3&quot; maxlength=&quot;3&quot; &gt;
    &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; size=&quot;4&quot; maxlength=&quot;4&quot; &gt;

    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function(){

    function tabForward(event){            
        event = EventUtil.getEvent(event);
        var target = EventUtil.getTarget(event);

        if (target.value.length == target.maxLength){
            var form = target.form;

            for (var i=0, len=form.elements.length; i &lt; len; i++) {
                if (form.elements[i] == target) {
                    if (form.elements[i+1]){
                        form.elements[i+1].focus();
                    }
                    return;
                }
            }
        }
    }

    var textbox1 = document.getElementById(&quot;txtTel1&quot;),
        textbox2 = document.getElementById(&quot;txtTel2&quot;),
        textbox3 = document.getElementById(&quot;txtTel3&quot;);

    EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward);        
    EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward);        
    EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);        

})();
&lt;/script&gt;
</code></pre><p>`</p>
</li>
<li><ol>
<li><p>4 表单序列化<br>`<br>function serialize(form){        </p>
<pre><code>var parts = [],
    field = null,
    i,
    len,
    j,
    optLen,
    option,
    optValue;

for (i=0, len=form.elements.length; i &lt; len; i++){
    field = form.elements[i];

    switch(field.type){
        case &quot;select-one&quot;:
        case &quot;select-multiple&quot;:

            if (field.name.length){
                for (j=0, optLen = field.options.length; j &lt; optLen; j++){
                    option = field.options[j];
                    if (option.selected){
                        optValue = &quot;&quot;;
                        if (option.hasAttribute){
                            optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text);
                        } else {
                            optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text);
                        }
                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue));
                    }
                }
            }
            break;

        case undefined:     //fieldset
        case &quot;file&quot;:        //file input
        case &quot;submit&quot;:      //submit button
        case &quot;reset&quot;:       //reset button
        case &quot;button&quot;:      //custom button
            break;

        case &quot;radio&quot;:       //radio button
        case &quot;checkbox&quot;:    //checkbox
            if (!field.checked){
                break;
            }
            /* falls through */

        default:
            //don&apos;t include form fields without names
            if (field.name.length){
                parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value));
            }
    }
}        
return parts.join(&quot;&amp;&quot;);
</code></pre><p>  }</p>
<p>  var btn = document.getElementById(“serialize-btn”);<br>  EventUtil.addHandler(btn, “click”, function(event){</p>
<pre><code>var form = document.forms[0];
alert(serialize(form));
</code></pre><p>  });<br>`</p>
<h3 id="Chapter-15-Canvas"><a href="#Chapter-15-Canvas" class="headerlink" title="Chapter 15 Canvas"></a>Chapter 15 Canvas</h3><h3 id="Chapter-16-HTML5脚本编程"><a href="#Chapter-16-HTML5脚本编程" class="headerlink" title="Chapter 16 HTML5脚本编程"></a>Chapter 16 HTML5脚本编程</h3></li>
</ol>
</li>
<li><ol>
<li>1 cross-document messaging XDM: 在来自不同域的页面间传递消息。</li>
</ol>
</li>
<li><ol>
<li>2 原生拖放(事件)<ol>
<li>dragestart；</li>
<li>drag;</li>
<li>dragend;</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>3 媒体元素</li>
</ol>
</li>
<li><ol>
<li>4 历史状态管理<h3 id="Chapter17-错误与调试"><a href="#Chapter17-错误与调试" class="headerlink" title="Chapter17 错误与调试"></a>Chapter17 错误与调试</h3></li>
</ol>
</li>
<li>17.2 错误处理<br>  错误类型：<ol>
<li>Error：基类型，供开发人员抛出自定义错误</li>
<li>EvalError：错误会使用eval()函数抛出<br><code>new eval();eval=foo;</code></li>
<li>RangeError：错误超出相应范围时触发<br><code>var items1=new Array(-20);var items2=new Array(Number.MAX_VALUE);</code></li>
<li>ReferenceError：找不到对象时抛出<br><code>var obj=x;</code></li>
<li>SyntaxError：语法错误<br><code>eval(&quot;a++b&quot;)</code></li>
<li>TypeError：类型错误，变量中保存意外类型或者访问不存在的方法时。<br><code>var o=new 12;alert(&#39;love&#39; in true);Function.prototype.toString.call(&#39;name&#39;)</code></li>
<li>URIError：使用encodeURI()或者decodeURI()格式错误时抛出。<br><code>//想知道错误类型可以如此利用try-catch语句
try{
someFunction();
}catch(error){
if(error instanceof TypeError){}
else if(error instanceof SyntaxError){}
else{...}
}</code><h3 id="Chapter-18-JS与XML"><a href="#Chapter-18-JS与XML" class="headerlink" title="Chapter 18 JS与XML"></a>Chapter 18 JS与XML</h3><h3 id="Chapter-19-E4X"><a href="#Chapter-19-E4X" class="headerlink" title="Chapter 19 E4X"></a>Chapter 19 E4X</h3><h3 id="Chapter-20-JSON"><a href="#Chapter-20-JSON" class="headerlink" title="Chapter 20 JSON"></a>Chapter 20 JSON</h3><blockquote>
<p>JSON:Javascript Object Notation,JS对象表示法，JS的利用了JS中的一些<br>模式来表示结构化数据的一个严格的子集。仅是一种数据格式不是一种语言。</p>
</blockquote>
</li>
</ol>
</li>
<li>JSON语法：三种类型<ol>
<li>简单值：与JS相同的语法，可在JSON中表示字符串，布尔值，数值和null（不支持undefined）</li>
<li>对象：一种无序的键值对的复杂数据结构类型，值可以是简单值也可以是对象。</li>
<li>数组：一种有序的值的列表的复杂的数据结构类型，通过索引访问元素。<br>JSON不支持变量，函数或者对象实例，仅仅是一种表示结构化数据的格式，虽与JS中表示数据的<br>某些语法相同，但并不局限于JS范畴。</li>
</ol>
</li>
<li><ol>
<li><p>2解析与序列化<br>`<br>JSON.parse();<br>JSON.stringify();<br>toJSON();<br>var book = {<br>title: “Professional JavaScript”,<br>authors: [<br>  “Nicholas C. Zakas”<br>],<br>edition: 3,<br>year: 2011,<br>toJSON: function(){<br>  return this.title;<br>}<br>};<br>var jsonText = JSON.stringify(book, [“title”, “edition”]);</p>
<pre><code>var jsonText = JSON.stringify(book, function(key, value){
    switch(key){
        case &quot;authors&quot;:
            return value.join(&quot;,&quot;)

        case &quot;year&quot;:
            return 5000;

        case &quot;edition&quot;:
            return undefined;

        default:
            return value;
    }
});
</code></pre><p>var jsonText=JSON.stringify(book,null,4);<br>//toJSON()作为函数过滤器的补充，把一个对象传给JSON.stringify()，序列化顺序如下：<br>//1. (存在toJSON)?调用该方法:返回对象本身；<br>// 2.若提供了第二个参数则应用该函数过滤器（传入步骤1的值）<br>//3.对上一步返回的每一个值序列化<br>//4. 若传入了第三个参数则执行相应格式化<br>var book = {</p>
<pre><code>            &quot;title&quot;: &quot;Professional JavaScript&quot;,
             &quot;authors&quot;: [
                 &quot;Nicholas C. Zakas&quot;
             ],
             edition: 3,
             year: 2011,
             releaseDate: new Date(2011, 11, 1)
        };
var jsonText = JSON.stringify(book);
</code></pre><p>  //{“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”],”edition”:3,”year”:2011,”releaseDate”:”2011-11-30T16:00:00.000Z”}<br>var bookCopy = JSON.parse(jsonText, function(key, value){<br> if (key == “releaseDate”){</p>
<pre><code>//return undefined;
return new Date(value);
</code></pre><p> } else {</p>
<pre><code>return value;
</code></pre><p> }<br>});<br>console.log(“releaseDate” in bookCopy);<br>console.log(bookCopy.releaseDate.getFullYear());//2011<br>`</p>
<h3 id="Chapter-21-Ajax与Comet"><a href="#Chapter-21-Ajax与Comet" class="headerlink" title="Chapter 21 Ajax与Comet"></a>Chapter 21 Ajax与Comet</h3><blockquote>
<p>Ajax:Asynchronous JS + XML:能够向服务器请求额外的数据而无须刷新页面，带来更好的用户体验。<br>其核心是XMLHttpRequest(XHR)对象,其为向服务器发送请求和解析服务器响应提供了流畅的接口。能够<br>以异步方式从服务器取得更多的信息。虽然名字中包含XML，但Ajax通信与数据格式无关；无须刷新整个<br>页面即可从服务器取得数据，不局限于XML。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>`<br>function createXHR(){<br>            if (typeof XMLHttpRequest != “undefined”){<br>                return new XMLHttpRequest();<br>            } else if (typeof ActiveXObject != “undefined”){<br>                if (typeof arguments.callee.activeXString != “string”){<br>                    var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                                    “MSXML2.XMLHttp”],<br>                        i, len;</p>
<pre><code>            for (i=0,len=versions.length; i &lt; len; i++){
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex){
                    //skip
                }
            }
        }

        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error(&quot;No XHR object available.&quot;);
    }
}
//如果XHR对象存在就可以写下边代码了
var xhr = createXHR();
//URL是相对执行代码的当前页面，open方法并非真正发送请求而是启动一个备发送的请求
xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);
//send()接收一个参数作为请求主题发送数据，颥不需要发送则必须传入null
//responseText:作为响应主题被返回的文本
//responseXML:如响应内容类型是&apos;text/xml&apos;或&apos;application/xml&apos;该属性将保存包含着相应数据
的XML DOM文档
//status:响应的http状态
//statusText：http状态说明
xhr.send(null);
if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
    alert(xhr.statusText);
    alert(xhr.responseText);
} else {
    alert(&quot;Request was unsuccessful: &quot; + xhr.status);
}
</code></pre><p>`</p>
<h3 id="Chapter22-高级技巧"><a href="#Chapter22-高级技巧" class="headerlink" title="Chapter22 高级技巧"></a>Chapter22 高级技巧</h3><ul>
<li><ol>
<li>1.4函数绑定bind()</li>
</ol>
</li>
<li><ol>
<li>1.5函数柯里化（function curring）</li>
</ol>
</li>
<li><ol>
<li>2防篡改对象<ol>
<li>2.1 不可扩展对象<ol>
<li>Object.preventExtensions();</li>
<li>Object.extensible()</li>
</ol>
</li>
<li>2.2密封对象：Object.seal()</li>
<li>2.3冻结对象:Object.freeze() <h3 id="Chapter-23-离线存储与客户端存储"><a href="#Chapter-23-离线存储与客户端存储" class="headerlink" title="Chapter 23 离线存储与客户端存储"></a>Chapter 23 离线存储与客户端存储</h3><blockquote>
<p>开发离线web应用步骤：</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol>
<li>确保应用知道设备能否上网；</li>
<li>应用必须能够访问一定的资源；</li>
<li>必须有一块本地空间用于保存数据，能否上网都不妨碍读写。<br>`<br>EventUtil.addHandler(window, “online”, function(){<pre><code>    document.getElementById(&quot;status&quot;).innerHTML = &quot;Online&quot;;
});
EventUtil.addHandler(window, &quot;offline&quot;, function(){
    document.getElementById(&quot;status&quot;).innerHTML = &quot;Offline&quot;;
});
</code></pre>`</li>
<li>3数据存储<h3 id="Good-Practise"><a href="#Good-Practise" class="headerlink" title="Good Practise"></a>Good Practise</h3></li>
</ol>
<ul>
<li>可维护性<ol>
<li>可理解性：其他人可以接手代码并理解它的意图和一般途径，无须作者的完整解释</li>
<li>直观性：一目了然，不管其操作过程多么复杂</li>
<li>可适应性：以一种数据上的变化不要求完全重写的方法撰写</li>
<li>可扩展性：架构上已考虑未来允许对核心功能的扩展</li>
<li>可调试性：当有地方出错时，提供足够信息来尽可能直接反馈问题所在</li>
</ol>
</li>
<li>代码约定<ol>
<li>可读性：<ol>
<li>函数和方法：每个要有注释，描述其目的和用于完成任务所可能使用的算法</li>
<li>大段代码：描述下任务的注释</li>
<li>复杂算法： </li>
<li>hack：处理兼容性等问题</li>
</ol>
</li>
<li>变量和命名<ol>
<li>变量名为名词（car，person）；</li>
<li>函数名以动词开始（getName）,返回布尔值的以is开头</li>
<li>使用合乎逻辑的名字</li>
</ol>
</li>
<li>变量类型透明<ol>
<li>初始化：var found=false,count=-1,name=’’</li>
<li>匈牙利标记法指定变量类型： var bFound,iCount,sName,pPerson</li>
<li>使用注释</li>
</ol>
</li>
</ol>
</li>
<li><p>松散耦合</p>
<ol>
<li>解耦html/JS</li>
<li>解耦css/JS</li>
<li><p>解耦应用逻辑/事件处理程序:分离原则</p>
<ol>
<li>勿将event对象传给其它方法，只传给来自event对象中所需的数据；</li>
<li>任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；</li>
<li>任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。</li>
</ol>
<p>`<br>function validateValue(value){<br> value=5*parseInt(value);<br> if(value&gt;10){</p>
<pre><code>//
</code></pre><p> }<br>}<br>function handleKeyPress(){<br> event=EventUtil.getEvent(event);<br> if(event.keyCode==13){</p>
<pre><code>//
</code></pre><p> }<br>}<br>`</p>
</li>
</ol>
</li>
<li>编程事件<ol>
<li>尊重对象所有权<ol>
<li>不要为实例或原型添加属性，方法</li>
<li>不要重定义已存在的方法</li>
</ol>
</li>
<li>避免全局变量<ol>
<li>单一的全局量的延伸便是命名空间的概念<br>YAHOO.util.DOM,YAHOO.util.Event,YAHOO.lang</li>
</ol>
</li>
<li>避免与null比较</li>
<li>使用常量：将数据和使用逻辑分离<ol>
<li>重复值：任何在多处用到的值都应是常量；</li>
<li>用户界面字符串</li>
<li>URLs</li>
<li>任何可能会改变的值</li>
</ol>
</li>
</ol>
</li>
<li>性能<ol>
<li>注意作用域<ol>
<li>避免全局查找</li>
<li>避免with</li>
</ol>
</li>
<li>选择正确的方法<ol>
<li>避免没必要的查找</li>
<li>优化循环</li>
<li>展开循环</li>
<li>避免双重解释</li>
<li>其它注意事项<ol>
<li>原生方法较快：</li>
<li>switch语句较快</li>
<li>位运算符较快</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>最小化语句树<ol>
<li>多个变量声明</li>
<li>插入迭代值</li>
<li>使用数组和对象字面量</li>
</ol>
</li>
<li>优化DOM交互<ol>
<li>最小化现场更新</li>
<li>使用innerHTML</li>
<li>使用事件代理</li>
<li>注意HTMLCollection</li>
</ol>
</li>
<li>部署<ol>
<li>构建过程<ol>
<li>知识产权问题</li>
<li>文件大小</li>
<li>代码组织</li>
</ol>
</li>
<li>验证</li>
<li>压缩<ol>
<li>文件压缩<ol>
<li>删除所有空白</li>
<li>删除所有注释</li>
<li>缩短变量名<br>2.HTTP 压缩<h3 id="Chapter25-新兴API"><a href="#Chapter25-新兴API" class="headerlink" title="Chapter25 新兴API"></a>Chapter25 新兴API</h3><h3 id="ES-Harmony"><a href="#ES-Harmony" class="headerlink" title="ES Harmony"></a>ES Harmony</h3></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>一般性变化<ol>
<li>常量：const</li>
<li>块级作用域及其它作用域<br> let关键字：使用let定义的变量在定义它的代码之外没有定义。</li>
</ol>
</li>
<li>函数<ol>
<li>剩余参数与分布函数<br>`<br>function sum(n1,n2,…ns){<br> var result=n1+n2;<br> for(let i=0,len=ns.length;i&lt;len;i++){<pre><code>result+=n[i]
</code></pre> }<br> return result;<br>}<br>var result=sum(…[1,2,3,4,4]);<br>var result=sum.apply(this,[1,3,4,4,5])<br>`</li>
<li>默认参数值<br><code>function sum(n1,n2=0){
 return n1+n2;
}</code></li>
<li>生成器<br>`<br>function myNumbers(){<br> for(var i=0;i&lt;10;i++){<pre><code>yield i*2;
</code></pre> }<br>}<br>var generator=myNumbers()<br>`</li>
</ol>
</li>
<li>数组及其它<ol>
<li>迭代器<br><code>var colors=[&#39;yellow&#39;,&#39;blue&#39;,&#39;red&#39;];
var iterator=new Iterator(colors)</code></li>
<li>数组领悟<br><code>var numbers=[1,3,4,4,5];
var duplicate=[i for each (i in numbers) if(i%2==0)]</code></li>
<li>解构赋值<br><code>var value1=5,value2=10;
[value1,value2]=[value2,value1]</code></li>
</ol>
</li>
<li>新对象类型<ol>
<li>代理对象<br><code>var proxy=Proxy.create(handler);
var proxy=Proxy.create(handler,myObject);</code><br>捕捉器7种：<ol>
<li>getOwnPropertyDescriptor</li>
<li>getPropertyDescriptor</li>
<li>getOwnPropertyNames</li>
<li>getPropertyName</li>
<li>defineProperty</li>
<li>delete</li>
<li>fix<br>派生捕捉器6种</li>
<li>has</li>
<li>hasOwn</li>
<li>get</li>
<li>set</li>
<li>enumerate</li>
<li>keys</li>
</ol>
</li>
<li>代理函数<br><code>var proxy=Proxy.createFunction(handler,function(){}.function(){})</code></li>
<li>映射map与集合set<br><code>var map=new Map();
map.set(&#39;name&#39;,&#39;Yl&#39;);
map.has(&#39;name&#39;);//true
var set=new Set();
set.add(&#39;name&#39;);
set.has(&#39;name&#39;);//true
set.delete(&#39;name&#39;)</code></li>
<li>weakMap<br><code>var key={},map=new WeakMap();
map.set(key,&#39;hello&#39;);
//解除对键的引用而删除该值
key=null</code></li>
<li>StructType</li>
<li>ArrayType</li>
</ol>
</li>
<li>类<br>`<br>class Person {<br>  constructor(name,age){<pre><code>public name=name;
//public age=age;
private age=age;
get title(){
    return innerTitle=&apos;&apos;
}
set title(value){
    innerTitle=value;
}
</code></pre>  }<br>  sayName(){<pre><code>alert(this.name)
</code></pre>  }<br>  getOlder(years){<pre><code>alert(this.age+=years)
</code></pre>  }<br>}<br>`<ol>
<li>私有成员</li>
<li>getter,setter</li>
<li>继承<br><code>class Employee extends Person
class Employee prototype basePerson</code></li>
</ol>
</li>
<li>模块<br>  `<br>  module MyModule={<pre><code>export let myobject={};
export function hello(){};
function goodbye(){}
</code></pre>  }<br>  import myobject from MyModule<br>  import * from MyModule<br>  //直接使用<br>  console.log(MyModule.hello)<br>  <code>外部模块</code><br>  module MyModule from ‘a.js’<br>  import myobject from MyModule<br>  `<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><code>use strit</code></li>
<li>变量：禁止意外创建全局变量</li>
<li>对象：<ol>
<li>为只读属性赋值==&gt;TypeError</li>
<li>对不可配置的属性使用delete==&gt;TypeError</li>
<li>为不可扩展的对象添加属性==&gt;TypeError</li>
<li>使用对象字面量时属性名必须唯一</li>
</ol>
</li>
<li>函数<ol>
<li>命名函数的参数必须唯一</li>
<li>淘汰了arguments.callee,arguments.caller</li>
</ol>
</li>
<li>eval():在包含上下文中不再创建变量或函数</li>
<li>eval与arguments：不可作为变量引用</li>
<li>抑制this：函数的this始终是指定值，无论指定值是什么</li>
<li>其它：禁用with语句</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Framework resharpe]]></title>
      <url>https://yanlee26.github.io/2016/06/04/framework/</url>
      <content type="html"><![CDATA[<h1 id="js-常用封装总结"><a href="#js-常用封装总结" class="headerlink" title="js 常用封装总结"></a>js 常用封装总结</h1><p>`<br>//自制框架<br>//定义一个对象 - 名字是$$<br>var $$ = function () {<br>};<br>//第二种写法<br>$$.prototype = {<br>    $q:function (str) {<br>        return document.querySelector(str)<br>    },<br>    $qa:function (str) {<br>        return document.querySelectorAll(str)<br>    },<br>    $id: function (str) {<br>        return document.getElementById(str)<br>    },<br>    $tag: function (tag) {<br>        return document.getElementsByTagName(tag)<br>    },<br>    //去除左边空格<br>    ltrim: function (str) {<br>        return str.replace(/(^\s<em>)/g, ‘’);<br>    },<br>    //去除右边空格<br>    rtrim: function (str) {<br>        return str.replace(/(\s</em>$)/g, ‘’);<br>    },<br>    //去除空格<br>    trim: function (str) {<br>        return str.replace(/(^\s<em>)|(\s</em>$)/g, ‘’);<br>    },<br>    //ajax<br>    myAjax: function (URL, fn) {<br>        var xhr = createXHR();    //返回了一个对象，这个对象IE6兼容。<br>        xhr.onreadystatechange = function () {<br>            if (xhr.readyState === 4) {<br>                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) {<br>                    fn(xhr.responseText);<br>                } else {<br>                    alert(“错误的文件！”);<br>                }<br>            }<br>        };<br>        xhr.open(“get”, URL, true);<br>        xhr.send();<br>        //闭包形式，因为这个函数只服务于ajax函数，所以放在里面<br>        function createXHR() {<br>            if (typeof XMLHttpRequest != “undefined”) {<br>                return new XMLHttpRequest();<br>            } else if (typeof ActiveXObject != “undefined”) {<br>                if (typeof arguments.callee.activeXString != “string”) {<br>                    var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                            “MSXML2.XMLHttp”<br>                        ],<br>                        i, len;<br>                    for (i = 0, len = versions.length; i &lt; len; i++) {<br>                        try {<br>                            new ActiveXObject(versions[i]);<br>                            arguments.callee.activeXString = versions[i];<br>                            break;<br>                        } catch (ex) {<br>                            //skip<br>                        }<br>                    }<br>                }<br>                return new ActiveXObject(arguments.callee.activeXString);<br>            } else {<br>                throw new Error(“No XHR object available.”);<br>            }<br>        }<br>    },<br>    //tab<br>    tab: function (id) {<br>        var box = document.getElementById(id);<br>        var spans = box.getElementsByTagName(‘span’);<br>        var lis = box.getElementsByTagName(‘li’);<br>        for (var i = 0; i &lt; spans.length; i++) {<br>            spans[i].index = i;<br>            spans[i].onmouseover = function () {<br>                for (var i = 0; i &lt; spans.length; i++) {<br>                    spans[i].className = ‘’;<br>                    lis[i].className = ‘’;<br>                }<br>                this.className = ‘select’;<br>                lis[this.index].className = ‘select’;<br>            }<br>        }<br>    },<br>    //简单的数据绑定formateString<br>    formateString: function (str, data) {<br>        return str.replace(/@((\w+))/g, function (match, key) {<br>            return typeof data[key] === “undefined” ? ‘’ : data[key]<br>        });<br>    },<br>    //给一个对象扩充功能<br>    extendMany: function () {<br>        var key, i = 0, len = arguments.length, target = null, copy;<br>        if (len === 0) {<br>            return;<br>        } else if (len === 1) {<br>            target = this;<br>        } else {<br>            i++;<br>            target = arguments[0];<br>        }<br>        for (; i &lt; len; i++) {<br>            for (key in arguments[i]) {<br>                copy = arguments[i][key];<br>                target[key] = copy;<br>            }<br>        }<br>        return target;<br>    },<br>    extend: function (tar, source) {<br>        for (var i in source) {<br>            tar[i] = source[i];<br>        }<br>        return tar;<br>    },<br>    random: function (begin, end) {<br>        return Math.floor(Math.random() <em> (end - begin)) + begin;<br>    },<br>    isNumber: function (val) {<br>        return typeof val === ‘number’ &amp;&amp; isFinite(val)<br>    },<br>    isBoolean: function (val) {<br>        return typeof val === “boolean”;<br>    },<br>    isString: function (val) {<br>        return typeof val === “string”;<br>    },<br>    isUndefined: function (val) {<br>        return typeof val === “undefined”;<br>    },<br>    isObj: function (str) {<br>        if (str === null || typeof str === ‘undefined’) {<br>            return false;<br>        }<br>        return typeof str === ‘object’;<br>    },<br>    isNull: function (val) {<br>        return val === null;<br>    },<br>    isArray: function (arr) {<br>        if (arr === null || typeof arr === ‘undefined’) {<br>            return false;<br>        }<br>        return arr.constructor === Array;<br>    }<br>};<br>//在框架中实例化<br>$$ = new $$();<br>$$.extend($$, {<br>    $id: function(id) {<br>        return document.getElementById(id);<br>    },<br>    $tag: function(tag, context) {<br>        if (typeof context == ‘string’) {<br>            context = $$.$id(context);<br>        }<br>        if (context) {<br>            return context.getElementsByTagName(tag);<br>        } else {<br>            return document.getElementsByTagName(tag);<br>        }<br>    },<br>    $class: function(className, context) {<br>        var i = 0,<br>            len, dom = [],<br>            arr = [];<br>        if ($$.isString(context)) {<br>            context = document.getElementById(context);<br>        } else {<br>            context = document;<br>        }<br>        if (context.getElementsByClassName) {<br>            return context.getElementsByClassName(className);<br>        } else {<br>            dom = context.getElementsByTagName(‘</em>‘);<br>            for (i; len = dom.length, i &lt; len; i++) {<br>                if (dom[i].className) {<br>                    arr.push(dom[i]);<br>                }<br>            }<br>        }<br>        return arr;<br>    },<br>    $group: function(content) {<br>        var result = [],<br>            doms = [];<br>        var arr = $$.trim(content).split(‘,’);<br>        for (var i = 0, len = arr.length; i &lt; len; i++) {<br>            var item = $$.trim(arr[i])<br>            var first = item.charAt(0)<br>            var index = item.indexOf(first)<br>            if (first === ‘.’) {<br>                doms = $$.$class(item.slice(index + 1));<br>                pushArray(doms, result)<br>            } else if (first === ‘#’) {<br>                doms = [$$.$id(item.slice(index + 1))] ;<br>                pushArray(doms, result)<br>            } else {<br>                doms = $$.$tag(item);<br>                pushArray(doms, result)<br>            }<br>        }<br>        return result;<br>        function pushArray(doms, result) {<br>            for (var j = 0, domlen = doms.length; j &lt; domlen; j++) {<br>                result.push(doms[j])<br>            }<br>        }<br>    },<br>    $cengci: function(select) {<br>        var sel = $$.trim(select).split(‘ ‘);<br>        var result = [];<br>        var context = [];<br>        for (var i = 0, len = sel.length; i &lt; len; i++) {<br>            result = [];<br>            var item = $$.trim(sel[i]);<br>            var first = sel[i].charAt(0)<br>            var index = item.indexOf(first)<br>            if (first === ‘#’) {<br>                pushArray([$$.$id(item.slice(index + 1))]);<br>                context = result;<br>            } else if (first === ‘.’) {<br>                if (context.length) {<br>                    for (var j = 0, contextLen = context.length; j &lt; contextLen; j++) {<br>                        pushArray($$.$class(item.slice(index + 1), context[j]));<br>                    }<br>                } else {<br>                    pushArray($$.$class(item.slice(index + 1)));<br>                }<br>                context = result;<br>            } else {<br>                if (context.length) {<br>                    for (var j = 0, contextLen = context.length; j &lt; contextLen; j++) {<br>                        pushArray($$.$tag(item, context[j]));<br>                    }<br>                } else {<br>                    pushArray($$.$tag(item));<br>                }<br>                context = result;<br>            }<br>        }</p>
<pre><code>    return context;
    function pushArray(doms) {
        for (var j = 0, domlen = doms.length; j &lt; domlen; j++) {
            result.push(doms[j])
        }
    }
},
$select: function(str) {
    var result = [];
    var item = $$.trim(str).split(&apos;,&apos;);
    for (var i = 0, glen = item.length; i &lt; glen; i++) {
        var select = $$.trim(item[i]);
        var context = [];
        context = $$.$cengci(select);
        pushArray(context);

    }
    return result;
    function pushArray(doms) {
        for (var j = 0, domlen = doms.length; j &lt; domlen; j++) {
            result.push(doms[j])
        }
    }
},
$all: function(selector, context) {
    context = context || document;
    return context.querySelectorAll(selector);
},
</code></pre><p>});<br>$$.extend($$, {<br>    css: function(context, key, value) {<br>        console.log(‘dfdfd’)<br>        var dom = $$.isString(context) ? $$.$all(context) : context;<br>        //Èç¹ûÊÇÊý×é<br>        if (dom.length) {<br>            //ÏÈ¹Ç¼Ü¹Ç¼Ü – Èç¹ûÊÇ»ñÈ¡Ä£Ê½ – Èç¹ûÊÇÉèÖÃÄ£Ê½<br>            //Èç¹ûvalue²»Îª¿Õ£¬Ôò±íÊ¾ÉèÖÃ<br>            if (value) {<br>                for (var i = dom.length - 1; i &gt;= 0; i–) {<br>                    setStyle(dom[i], key, value);<br>                }<br>                //            Èç¹ûvalueÎª¿Õ£¬Ôò±íÊ¾»ñÈ¡<br>            } else {<br>                return getStyle(dom[0]);<br>            }<br>            //Èç¹û²»ÊÇÊý×é<br>        } else {<br>            if (value) {<br>                setStyle(dom, key, value);<br>            } else {<br>                return getStyle(dom);<br>            }<br>        }</p>
<pre><code>    function getStyle(dom) {
        if (dom.currentStyle) {
            return dom.currentStyle[key];
        } else {
            return getComputedStyle(dom, null)[key];
        }
    }

    function setStyle(dom, key, value) {
        dom.style[key] = value;
    }
},
cssNum: function(context, key) {
    return parseFloat($$.css(context, key))
},
show: function(content) {
    var doms = $$.$all(content)
    for (var i = 0, len = doms.length; i &lt; len; i++) {
        $$.css(doms[i], &apos;display&apos;, &apos;block&apos;);
    }
},
hide: function(content) {
    var doms = $$.$all(content)
    for (var i = 0, len = doms.length; i &lt; len; i++) {
        $$.css(doms[i], &apos;display&apos;, &apos;none&apos;);
    }
},
Width: function(id) {
    return $$.$id(id).clientWidth
},
Height: function(id) {
    return $$.$id(id).clientHeight
},
scrollWidth: function(id) {
    return $$.$id(id).scrollWidth
},
scrollHeight: function(id) {
    return $$.$id(id).scrollHeight
},
scrollTop: function(id) {
    return $$.$id(id).scrollTop
},
scrollLeft: function(id) {
    return $$.$id(id).scrollLeft
},
screenHeight: function() {
    return window.screen.height
},
screenWidth: function() {
    return window.screen.width
},
wWidth: function() {
    return document.documentElement.clientWidth
},
wHeight: function() {
    return document.documentElement.clientHeight
},
wScrollHeight: function() {
    return document.body.scrollHeight
},
wScrollWidth: function() {
    return document.body.scrollWidth
},
wScrollTop: function() {
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    return scrollTop
},
wScrollLeft: function() {
    var scrollLeft = document.body.scrollLeft || (document.documentElement &amp;&amp; document.documentElement.scrollLeft);
    return scrollLeft
}
</code></pre><p>})<br>$$.extend($$, {<br>    attr: function(content, key, value) {<br>        var dom = $$.$all(content);<br>        if (dom.length) {<br>            if (value) {<br>                for (var i = 0, len = dom.length; i &lt; len; i++) {<br>                    dom[i].setAttribute(key, value);<br>                }<br>            } else {<br>                return dom[0].getAttribute(key);<br>            }<br>        } else {<br>            if (value) {<br>                dom.setAttribute(key, value);<br>            } else {<br>                return dom.getAttribute(key);<br>            }<br>        }<br>    },<br>    addClass: function(context, name) {<br>        var doms = $$.$all(context);<br>        if (doms.length) {<br>            for (var i = 0, len = doms.length; i &lt; len; i++) {<br>                addName(doms[i]);<br>            }<br>        } else {<br>            addName(doms);<br>        }<br>        function addName(dom) {<br>            dom.className = dom.className + ‘ ‘ + name;<br>        }<br>    },<br>    removeClass: function(context, name) {<br>        var doms = $$.$all(context);<br>        if (doms.length) {<br>            for (var i = 0, len = doms.length; i &lt; len; i++) {<br>                removeName(doms[i]);<br>            }<br>        } else {<br>            removeName(doms);<br>        }<br>        function removeName(dom) {<br>            dom.className = dom.className.replace(name, ‘’);<br>        }<br>    },<br>    hasClass: function(context, name) {<br>        var doms = $$.$all(context)<br>        var flag = true;<br>        for (var i = 0, len = doms.length; i &lt; len; i++) {<br>            flag = flag &amp;&amp; check(doms[i], name)<br>        }</p>
<pre><code>    return flag;
    //ÅÐ¶¨µ¥¸öÔªËØ
    function check(element, name) {
        return -1 &lt; (&quot; &quot; + element.className + &quot; &quot;).indexOf(&quot; &quot; + name + &quot; &quot;)
    }
},
getClass: function(id) {
    var doms = $$.$all(id)
    return $$.trim(doms[0].className).split(&quot; &quot;)
}
</code></pre><p>})<br>$$.extend($$, {<br>    html: function(context, value) {<br>        var doms = $$.$all(context);<br>        if (value) {<br>            for (var i = 0, len = doms.length; i &lt; len; i++) {<br>                doms[i].innerHTML = value;<br>            }<br>        } else {<br>            return doms[0].innerHTML<br>        }<br>    }<br>});<br>$$.extend($$, {<br>    on: function (id, type, fn) {<br>        var dom = $$.isString(id) ? document.getElementById(id) : id;<br>        if (dom.addEventListener) {<br>            dom.addEventListener(type, fn, false);<br>        } else if (dom.attachEvent) {<br>            dom.attachEvent(‘on’ + type, fn);<br>        }<br>    },<br>    un: function (id, type, fn) {<br>        var dom = $$.isString(id) ? document.getElementById(id) : id;<br>        if (dom.removeEventListener) {<br>            dom.removeEventListener(type, fn);<br>        } else if (dom.detachEvent) {<br>            dom.detachEvent(type, fn);<br>        }<br>    },<br>    click: function (id, fn) {<br>        this.on(id, ‘click’, fn);<br>    },<br>    mouseover: function (id, fn) {<br>        this.on(id, ‘mouseover’, fn);<br>    },<br>    mouseout: function (id, fn) {<br>        this.on(id, ‘mouseout’, fn);<br>    },<br>    hover: function (id, fnOver, fnOut) {<br>        if (fnOver) {<br>            this.on(id, “mouseover”, fnOver);<br>        }<br>        if (fnOut) {<br>            this.on(id, “mouseout”, fnOut);<br>        }<br>    },<br>    delegate: function (pid, eventType, selector, fn) {<br>        //参数处理<br>        var parent = $$.$id(pid);<br>        function handle(e) {<br>            var target = $$.GetTarget(e);<br>            if (target.nodeName.toLowerCase() === selector || target.id === selector || target.className.indexOf(selector) != -1) {<br>                fn.call(target);<br>            }<br>        }<br>        parent[eventType] = handle;<br>    },<br>    //事件基础<br>    getEvent: function (event) {<br>        return event ? event : window.event;<br>    },<br>    //获取目标<br>    GetTarget: function (event) {<br>        var e = $$.getEvent(event);<br>        return e.target || e.srcElement;<br>    },<br>    //组织默认行为<br>    preventDefault: function (event) {<br>        var event = $$.getEvent(event);<br>        if (event.preventDefault) {<br>            event.preventDefault();<br>        } else {<br>            event.returnValue = false;<br>        }<br>    },<br>    //阻止冒泡<br>    stopPropagation: function (event) {<br>        var event = $$.getEvent(event);<br>        if (event.stopPropagation) {<br>            event.stopPropagation();<br>        } else {<br>            event.cancelBubble = true;<br>        }<br>    }<br>})<br>$$.extend($$, {<br>    eq: function() {},<br>    first: function() {},<br>    last: function() {},<br>    append: function() {},<br>    empty: function() {},<br>    remove: function() {},<br>    clone: function() {}<br>});<br>$$.extend($$, {<br>    sjson: function(json) {<br>        return JSON.stringify(json);<br>    },<br>    json: function(str) {<br>        return eval(str);<br>    }<br>});<br>$$.cache = {<br>    data: [],<br>    get: function(key) {<br>        console.log(‘111’)<br>        var value = null;<br>        console.log(this.data)<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (key == item.key) {<br>                value = item.value;<br>            }<br>        }<br>        console.log(‘get’ + value)<br>        return value;<br>    },<br>    add: function(key, value) {<br>        var json = { key: key, value: value };<br>        this.data.push(json);<br>    },<br>    delete: function(key) {<br>        var status = false;<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (item.key.trim() == key) {<br>                this.data.splice(i, 1);<br>                status = true;<br>                break;<br>            }<br>        }<br>        return status;<br>    },<br>    update: function(key, value) {<br>        var status = false;<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (item.key.trim() === key.trim()) {<br>                item.value = value.trim();<br>                status = true;<br>                break;<br>            }<br>        }<br>        return status;<br>    },<br>    isExist: function(key) {<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (key === item.key) {<br>                return true;<br>            } else {<br>                return false;<br>            }<br>        }<br>    }<br>}<br>$$.cookie = {<br>    setCookie: function(name, value, days, path) {<br>        var name = escape(name);<br>        var value = escape(value);<br>        var expires = new Date();<br>        expires.setTime(expires.getTime() + days <em> 24 </em> 60 <em> 60 </em> 1000);<br>        path = path == “” ? “” : “;path=” + path;<br>        _expires = (typeof hours) == “string” ? “” : “;expires=” + expires.toUTCString();<br>        document.cookie = name + “=” + value + _expires + path;<br>    },<br>    getCookie: function(name) {<br>        var name = escape(name);<br>        var allcookies = document.cookie;<br>        name += “=”;<br>        var pos = allcookies.indexOf(name);<br>        if (pos != -1) {<br>            var start = pos + name.length;<br>            var end = allcookies.indexOf(“;”, start);<br>            if (end == -1) end = allcookies.length;<br>            var value = allcookies.substring(start, end);<br>            return unescape(value);<br>        } else return “”;<br>    },<br>    deleteCookie: function(name, path) {<br>        var name = escape(name);<br>        var expires = new Date(0);<br>        path = path == “” ? “” : “;path=” + path;<br>        document.cookie = name + “=” + “;expires=” + expires.toUTCString() + path;<br>    }<br>}<br>$$.store = (function() {<br>    var api = {},<br>        win = window,<br>        doc = win.document,<br>        localStorageName = ‘localStorage’,<br>        globalStorageName = ‘globalStorage’,<br>        storage;<br>    api.set = function(key, value) {};<br>    api.get = function(key) {};<br>    api.remove = function(key) {};<br>    api.clear = function() {};</p>
<pre><code>if (localStorageName in win &amp;&amp; win[localStorageName]) {
    storage = win[localStorageName];
    api.set = function(key, val) { storage.setItem(key, val) };
    api.get = function(key) {
        return storage.getItem(key) };
    api.remove = function(key) { storage.removeItem(key) };
    api.clear = function() { storage.clear() };

} else if (globalStorageName in win &amp;&amp; win[globalStorageName]) {
    storage = win[globalStorageName][win.location.hostname];
    api.set = function(key, val) { storage[key] = val };
    api.get = function(key) {
        return storage[key] &amp;&amp; storage[key].value };
    api.remove = function(key) { delete storage[key] };
    api.clear = function() {
        for (var key in storage) { delete storage[key] } };

} else if (doc.documentElement.addBehavior) {
    function getStorage() {
        if (storage) {
            return storage }
        storage = doc.body.appendChild(doc.createElement(&apos;div&apos;));
        storage.style.display = &apos;none&apos;;
        // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
        // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
        storage.addBehavior(&apos;#default#userData&apos;);
        storage.load(localStorageName);
        return storage;
    }
    api.set = function(key, val) {
        var storage = getStorage();
        storage.setAttribute(key, val);
        storage.save(localStorageName);
    };
    api.get = function(key) {
        var storage = getStorage();
        return storage.getAttribute(key);
    };
    api.remove = function(key) {
        var storage = getStorage();
        storage.removeAttribute(key);
        storage.save(localStorageName);
    }
    api.clear = function() {
        var storage = getStorage();
        var attributes = storage.XMLDocument.documentElement.attributes;;
        storage.load(localStorageName);
        for (var i = 0, attr; attr = attributes[i]; i++) {
            storage.removeAttribute(attr.name);
        }
        storage.save(localStorageName);
    }
}
return api;
</code></pre><p>})();<br>var store = (function () {<br>    var api               = {},<br>        win               = window,<br>        doc               = win.document,<br>        localStorageName  = ‘localStorage’,<br>        globalStorageName = ‘globalStorage’,<br>        storage;<br>    api.set    = function (key, value) {};<br>    api.get    = function (key)        {};<br>    api.remove = function (key)        {};<br>    api.clear  = function ()           {};<br>    if (localStorageName in win &amp;&amp; win[localStorageName]) {<br>        storage    = win[localStorageName];<br>        api.set    = function (key, val) { storage.setItem(key, val) };<br>        api.get    = function (key)      { return storage.getItem(key) };<br>        api.remove = function (key)      { storage.removeItem(key) };<br>        api.clear  = function ()         { storage.clear() };</p>
<pre><code>} else if (globalStorageName in win &amp;&amp; win[globalStorageName]) {
    storage    = win[globalStorageName][win.location.hostname];
    api.set    = function (key, val) { storage[key] = val };
    api.get    = function (key)      { return storage[key] &amp;&amp; storage[key].value };
    api.remove = function (key)      { delete storage[key] };
    api.clear  = function ()         { for (var key in storage ) { delete storage[key] } };

} else if (doc.documentElement.addBehavior) {
    function getStorage() {
        if (storage) { return storage }
        storage = doc.body.appendChild(doc.createElement(&apos;div&apos;));
        storage.style.display = &apos;none&apos;;
        // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
        // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
        storage.addBehavior(&apos;#default#userData&apos;);
        storage.load(localStorageName);
        return storage;
    }
    api.set = function (key, val) {
        var storage = getStorage();
        storage.setAttribute(key, val);
        storage.save(localStorageName);
    };
    api.get = function (key) {
        var storage = getStorage();
        return storage.getAttribute(key);
    };
    api.remove = function (key) {
        var storage = getStorage();
        storage.removeAttribute(key);
        storage.save(localStorageName);
    }
    api.clear = function () {
        var storage = getStorage();
        var attributes = storage.XMLDocument.documentElement.attributes;;
        storage.load(localStorageName);
        for (var i=0, attr; attr = attributes[i]; i++) {
            storage.removeAttribute(attr.name);
        }
        storage.save(localStorageName);
    }
}
return api;
</code></pre><p>})();<br>Function.prototype.before = function( func ) {<br>    var <strong>self = this;<br>    return function() {<br>        if ( func.apply( this, arguments ) === false ) {<br>            return false;<br>        }<br>        return </strong>self.apply( this, arguments );<br>    }<br>}<br>Function.prototype.after = function( func ) {<br>    var <strong>self = this;<br>    return function() {<br>        var ret = </strong>self.apply( this, arguments );<br>        if( ret === false) {<br>            return false;<br>        }<br>        func.apply( this, arguments );<br>        return ret;<br>    }<br>}<br>`</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[道德经：人生之向导，智慧之源泉]]></title>
      <url>https://yanlee26.github.io/2016/06/04/bibleInLife/</url>
      <content type="html"><![CDATA[<h1 id="【道德经】"><a href="#【道德经】" class="headerlink" title="【道德经】"></a><center>【道德经】</center></h1><blockquote>
<p>老子</p>
<p>###【第一章】<br>　　道可道，非常道。名可名，非常名。<br>　　无名天地之始；有名万物之母。<br>　　故常无，欲以观其妙；常有，欲以观其徼。<br>　　此两者，同出而异名，同谓之玄。玄之又玄，众妙之门。</p>
<p>###【第二章】<br>　　天下皆知美之为美，斯恶已。皆知善之为善，斯不善已。<br>　　有无相生，难易相成，长短相形，高下相盈，音声相和，前后相随。恒也。<br>　　是以圣人处无为之事，行不言之教；万物作而弗始，生而弗有，为而弗恃，功成而不居。夫唯弗居，是以不去。</p>
<p>###【第三章】<br>　　不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。<br>　　是以圣人之治，虚其心，实其腹，弱其志，强其骨。常使民无知无欲。使夫智者不敢为也。为无为，则无不治。</p>
<p>###【第四章】<br>　　道冲，而用之或不盈。渊兮，似万物之宗；湛兮，似或存。吾不知谁之子，象帝之先[1]。</p>
<p>###【第五章】<br>　　天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。<br>　　天地之间，其犹橐龠乎？虚而不屈，动而愈出。<br>　　多言数穷，不如守中。</p>
<p>###【第六章】<br>　　谷神不死，是谓玄牝。玄牝之门，是谓天地根。绵绵若存，用之不勤。</p>
<p>###【第七章】<br>　　天长地久。天地所以能长且久者，以其不自生，故能长生。<br>　　是以圣人后其身而身先；外其身而身存。非以其无私邪？故能成其私。</p>
<p>###【第八章】<br>　　上善若水。水善利万物而不争，处众人之所恶，故几于道。<br>　　居善地，心善渊，与善仁，言善信，政善治，事善能，动善时。夫唯不争，故无尤。</p>
<p>###【第九章】<br>　　持而盈之，不如其已；<br>　　揣而锐之，不可长保。<br>　　金玉满堂，莫之能守；<br>　　富贵而骄，自遗其咎。<br>　　功遂身退，天之道也。</p>
<p>###【第十章】<br>　　载营魄抱一，能无离乎？<br>　　专气致柔，能如婴儿乎？<br>　　涤除玄鉴，能如疵乎？<br>　　爱国治民，能无为乎？<br>　　天门开阖，能为雌乎？<br>　　明白四达，能无知乎？<br>    生之蓄之，生而不有，为而不恃，长而不宰，是谓玄德。</p>
<p> ###【第十一章】<br>　　三十辐，共一毂，当其无，有车之用。<br>　　埏埴以为器，当其无，有器之用。<br>　　凿户牖以为室，当其无，有室之用。<br>　　故有之以为利，无之以为用。</p>
<p>###【第十二章】<br>　　五色令人目盲；<br>    五音令人耳聋；<br>    五味令人口爽；<br>    驰骋畋猎，令人心发狂；<br>    难得之货，令人行妨。<br>    是以圣人为腹不为目，故去彼取此。</p>
<p>###【第十三章】<br>　　宠辱若惊，贵大患若身。<br>　　何谓宠辱若惊？宠为下，得之若惊，失之若惊，是谓宠辱若惊。<br>　　何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患？<br>　　故贵以身为天下，若可寄天下；爱以身为天下，若可托天下。</p>
<p>###【第十四章】<br>　　视之不见，名曰夷；听之不闻，名曰希；搏之不得，名曰微。此三者不可致诘[1]，故混而为一。其上不曒，其下不昧。绳绳兮不可名，复归于物。是谓无状之状，无物之象，是谓惚恍。迎之不见其首，随之不见其后。<br>　　执古之道，以御今之有。能知古始，是谓道纪。</p>
<p>###【第十五章】<br>　　古之善为道者，微妙玄通，深不可识。夫唯不可识，故强为之容：<br>　　豫兮若冬涉川；<br>　　犹兮若畏四邻；<br>　　俨兮其若客；<br>　　涣兮若冰之将释；<br>　　敦兮其若朴；<br>　　旷兮其若谷；<br>　　混兮其若浊；<br>　　（澹兮其若海；<br>　　□兮若无止。）<br>　　孰能浊以静之？徐清；孰能安以动之？徐生。<br>　　保此道者，不欲盈。夫唯不盈，故能蔽而新成。</p>
</blockquote>
<p>###【第十六章】<br>　　致虚极，守静笃。万物并作，吾以观复。<br>　　夫物芸芸，各复归其根。归根曰静，静曰复命。复命曰常[1]，知常曰明。不知常，妄作凶。<br>　　知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。</p>
<p>###【第十七章】<br>　　太上，不知有之；其次，亲而誉之；其次，畏之；其次，侮之。信不足焉，有不信焉。<br>　　悠兮其贵言。功成事遂，百姓皆谓：「我自然」。</p>
<p>###【第十八章】<br>　　大道废，有仁义；智慧出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。</p>
<p>###【第十九章】<br>　　绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有。<br>　　　　此三者以为文，不足。故令有所属：见素抱朴，少思寡欲，绝学无忧。</p>
<p>###【第二十章】<br>　　唯之与阿，相去几何？美之与恶，相去若何？人之所畏，不可不畏。<br>　　荒兮，其未央哉！<br>　　众人熙熙，如享太牢，如春登台。<br>　　我独泊兮，其未兆；<br>　　沌沌兮，如婴儿之未孩；<br>　　累累兮，若无所归。<br>　　众人皆有馀，而我独若遗。我愚人之心也哉！<br>　　俗人昭昭，我独昏昏。<br>　　俗人察察，我独闷闷。<br>　　澹兮其若海，　兮若无止。<br>　　众人皆有以，而我独顽且鄙。<br>　　我独异于人，而贵食母。</p>
<p>###【第二十一章】<br>　　孔德之容，惟道是从。<br>　　道之为物，惟恍惟惚。惚兮恍兮，其中有象；恍兮惚兮，其中有物。窈兮冥兮，其中有精；其精甚真，其中有信。<br>　　自今及古，其名不去，以阅众甫。吾何以知众甫之状哉？以此。</p>
<p>###【第二十二章】<br>　　曲则全，枉则直，洼则盈，敝则新，少则多，多则惑。<br>　　是以圣人抱一为天下式[1]。不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。<br>　　夫唯不争，故天下莫能与之争。古之所谓「曲则全」者，岂虚言哉！诚全而归之。</p>
<p>###【第二十三章】<br>　　希言自然。<br>　　故飘风不终朝，骤雨不终日。孰为此者？天地。天地尚不能久，而况于人乎？故从事于道者，同于道；德者，同于德；失者，同于失。同于道者，道亦乐得之；同于德者，德亦乐得之；同于失者，失亦乐得之。<br>　　信不足焉，有不信焉。</p>
<p>###【第二十四章】<br>　　企者不立；跨者不行；自见者不明；自是者不彰；自伐者无功；自矜者不长。<br>　　其在道也，曰：馀食赘形。物或恶之，故有道者不处。</p>
<p>###【第二十五章】<br>　　有物混成，先天地生。寂兮寥兮，独立而不改，周行而不殆，可以为天地母。吾不知其名，强字之曰道，强为之名曰大。大曰逝，逝曰远，远曰反。<br>　　故道大，天大，地大，人亦大。域中有四大，而人居其一焉。<br>　　人法地，地法天，天法道，道法自然。</p>
<p>###【第二十六章】<br>　　重为轻根，静为躁君。<br>　　是以君子终日行不离辎重。虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？<br>　　轻则失根，躁则失君。</p>
<p>###【第二十七章】<br>　　善行无辙迹，善言无瑕谪；善数不用筹策；善闭无关楗而不可开，善结无绳约而不可解。<br>　　是以圣人常善救人，故无弃人；常善救物，故无弃物。是谓袭明。<br>　　故善人者，不善人之师；不善人者，善人之资。不贵其师，不爱其资，虽智大迷，是谓要妙。</p>
<p>###【第二十八章】<br>　　知其雄，守其雌，为天下溪。为天下溪，常德不离，复归于婴儿。<br>　　知其白，知其白，守其黑，为天下式。为天下式，常德不忒，复归于无极。<br>　　知其荣，守其辱，为天下谷。为天下谷，常德乃足，复归于朴。<br>　　朴散则为器，圣人用之，则为官长。<br>　　故大智不割。</p>
<p> ###【第二十九章】<br>　　将欲取天下而为之，吾见其不得已。天下神器，不可为也，不可执也。为者败之，执者失之。是以圣人无为，故无败；无执，故无失。<br>　　夫物或行或随；或嘘或吹；或强或羸；或载或隳。<br>　　是以圣人去甚，去奢，去泰。</p>
<p> ###【第三十章】<br>　　以道佐人主者，不以兵强天下。其事好远。师之所处，荆棘生焉。大军之后，必有凶年。<br>　　善有果而已，不以取强。果而勿矜，果而勿伐，果而勿骄。果而不得已，果而勿强。<br>　　物壮则老，是谓不道，不道早已。</p>
<p>###【第三十一章】<br>　　兵者不祥之器，非君子之器。不得已而用之，恬淡为上，胜而不美。而美 之者，是乐杀人。夫乐杀人者，则不可得志于天下矣。<br>　　夫兵者，不祥之器，物或恶之，故有道者不处。君子居则贵左，用兵则贵右。吉事尚左， 凶事尚右。偏将军居左，上将军居右，言以丧礼处之。杀人之众，以悲哀泣之，战胜以丧 礼处之。</p>
<p>###【第三十二章】<br>　　道常无名。朴虽小，天下莫能臣。侯王若能守之，万物将自宾。<br>　　天地相合，以降甘露，民莫之令而自均。<br>　　始制有名，名亦既有，夫亦将知止，知止可以不殆。<br>　　譬道之在天下，犹川谷之于江海。</p>
<p> ###【第三十三章】<br>　　知人者智，自知者明。<br>　　胜人者有力，自胜者强。<br>　　知足者富。<br>　　强行者有志。<br>　　不失其所者久。<br>　　死而不亡者寿。</p>
<p> ###【第三十四章】<br>　　大道泛兮，其可左右。万物恃之以生而不辞，功成而不有。衣养万物而不为主，可名于小；万物归焉而不为主，可名为大。以其终不自为大，故能成其大。</p>
<p>###【第三十五章】<br>　　执大象，天下往。往而不害，安平泰。<br>　　乐与饵，过客止。道之出口，淡乎其无味，视之不足见，听之不足闻，用之不足既。</p>
<p> ###【第三十六章】<br>　　将欲歙之，必故张之；将欲弱之，必故强之；将欲废之，必故兴之；将欲取之，必故与之。是谓微明。<br>　　柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。</p>
<p>###【第三十七章】<br>　　道常无为而无不为。侯王若能守之，万物将自化。化而欲作，吾将镇之以无名之朴。镇之以无名之朴，夫将不欲。不欲以静，天下将自正。</p>
<p>###【第三十八章】<br>　　上德不德，是以有德；下德不失德，是以无德。<br>　　上德无为而无以为；下德无为而有以为。<br>　　上仁为之而无以为；上义为之而有以为。<br>　　上礼为之而莫之应，则攘臂而扔之。<br>　　故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首。<br>　　前识者，道之华，而愚之始。是以大丈夫处其厚，不居其薄；处其实，不居其华。故去彼取此。</p>
<p>###【第三十九章】<br>　　昔之得一者：天得一以清；地得一以宁；神得一以灵；谷得一以生；侯得一以为天下正。<br>　　其致之也，谓天无以清，将恐裂；地无以宁，将恐废；神无以灵，将恐歇；谷无以盈，将恐竭；万物无以生，将恐灭；侯王无以正，将恐蹶。<br>　　故贵以贱为本，高以下为基。是以侯王自称孤、寡、不谷。此非以贱为本邪？非乎？故致誉无誉。是故不欲琭琭如玉，珞珞如石。</p>
<p>###【第四十章】<br>　　反者道之动[1]；弱者道之用。<br>　　天下万物生于有，有生于无。</p>
<blockquote>
<p>反，有相反、返归二意。二意相通：反于世界，返归于道。详见第三部一章一则”反”。</p>
</blockquote>
<p>###【第四十一章】<br>　　上士闻道，勤而行之。中士闻道，若存若亡。下士闻道，大笑之。不笑不足以为道。故建言有之：<br>　　明道若昧，进道若退，夷道若类，<br>　　上德若谷，大白若辱，<br>　　广德若不足，建德若偷，质真若渝，<br>　　大方无隅，大器晚成，<br>　　大音希声，大象无形。<br>　　道隐无名。夫唯道，善贷且成。 </p>
<p> ###【第四十二章】<br>　　道生一，一生二，二生三，三生万物[1]。<br>　　万物负阴而抱阳，冲气以为和[2]。<br>　　人之所恶，唯孤、寡、不谷，而王公以为称。<br>　　故物或损之而益，或益之而损。<br>　　人之所教，我亦教之：强梁者不得其死，吾将以为教父。</p>
<blockquote>
<p>[1]后人的解释要么依据唯物辩证法，要么依据阴阳学说，均非本意，在《》其他任何一章中也找不到任何一节来证明。庄子对此早有精妙的解释，在通篇中都可以找到佐证。庄子说：”既然是｀一＇了，还有什么好说的呢？然而，既然称之为｀一＇了，岂不是已经说出口了吗？这个｀一＇，与我们对它的言说，就是｀二＇了。｀二＇，再加上｀一＇原本的存在，就是｀三＇。所以从无到有，到｀三＇为止（《大宗师》）”。庄子所说的三个”一”，很绕口，其实就是”道的表像、道的名份、道的实在”这三者。此处译文即根据庄子，以道解道。王弼亦明显参考了庄子。道的名、实、像及其三者的关系，在《》一、四、六、九、十四、二十一 、二十五、三十二、四十一和四十二章等，都有论及。详见第一部二章一节之三”辨析一二三”，五章三节之二”名实像、三合一”、之三”谈名实像”。<br>[2]道是「其上不　、其下不昧」的纯粹光明，是「一」。万物却有向光与背光的两面，故曰「抱阳而负阴」。向道与背道这两面相互激荡，靠「气」（灵？）而平和。</p>
<p>###【第四十三章】<br>　　天下之至柔，驰骋天下之至坚。无有入无间。<br>　　吾是以知无为之有益。<br>　　不言之教，无为之益，天下希及之。</p>
<p>###【第四十四章】<br>　　名与身孰亲？身与货孰多？得与亡孰病？<br>　　甚爱必大费；多藏必厚亡。<br>　　故知足不辱，知止不殆，可以长久。</p>
<p>###【第四十五章】<br>　　大成若缺，其用不弊。大盈若冲，其用不穷。<br>　　大直若屈，大巧若拙，大辩若讷。<br>　　静胜躁，寒胜热。清静，为天下正。</p>
<p>###【第四十六章】<br>　　天下有道，却走马以粪。天下无道，戎马生于郊。<br>　　祸莫大于不知足；咎莫大于欲得。故知足之足，常足矣。</p>
<p>###【第四十七章】<br>　　不出户，知天下；不窥牖，见天道。其出弥远，其知弥少。<br>　　是以圣人不行而知，不见而明，不为而成。</p>
<p>###【第四十八章】<br>　　为学日益，为道日损。损之又损，以至于无为。<br>　　无为而无不为。取天下常以无事，及其有事，不足以取天下。</p>
<p>###【第四十九章】<br>　　圣人常无心[1]，以百姓心为心。<br>　　善者，吾善之；不善者，吾亦善之；德善。<br>　　信者，吾信之；不信者，吾亦信之；德信。<br>　　圣人在天下，歙歙焉[2]，为天下浑其心，百姓皆注其耳目，圣人皆孩之。<br>[1]「无常心」，有本作「常无心」、「无心」，即无私心。马王堆本「常」为「恒」，「无恒心」亦即不固执一己之心。<br>[2]「歙」，音「吸」，纳气入内。「歙歙焉」，有灵气运行、并非人意之状。</p>
<p>###【第五十章】<br>　　出生入死。生之徒，十有三；死之徒，十有三；人之生，动之于死地，亦十有三[1]。<br>　　夫何故？以其生之厚。盖闻善摄生者，路行不遇兕虎，入军不被甲兵；兕无所投其角，虎无所用其爪，兵无所容其刃。夫何故？以其无死地。<br>[1]从韩非子注。不论生死，人皆有四肢九窍；送生致死，亦以此四肢九窍。联系上句「出生入死」的总概括，以及后面的「夫何故？以其生生之厚」的总结论，此意顺达。有人将「十有三」译为「十分之三」，不和此章深意。</p>
<p>###【第五十一章】<br>　　道生之，德畜之[1]，物形之，势成之。<br>　　是以万物莫不尊道而贵德。<br>　　道之尊，德之贵，夫莫之命而常自然。<br>　　故道生之，德畜之；长之育之；成之熟之；养之覆之。生而不有，为而不恃，长而不宰。是谓玄德。<br>[1]「德」，有品德、恩德、得著、感德、属性等意。用于大道者，当是恩德。</p>
<p>###【第五十二章】<br>　　天下有始，以为天下母。既得其母，以知其子，复守其母，没身不殆。<br>　　塞其兑，闭其门，终身不勤。开其兑，济其事，终身不救。见小曰明，守柔曰强。用其光，复归其明，无遗身殃；是为袭常。</p>
<p>###【第五十三章】<br>　　使我介然有知，行于大道，唯施是畏。<br>　　大道甚夷，而人好径。朝甚除，田甚芜，仓甚虚；服文采，带利剑，厌饮食，财货有馀；是为盗夸。非道也哉！</p>
<p>###【第五十四章】<br>　　善建者不拔，善抱者不脱，子孙以祭祀不辍。<br>　　修之于身，其德乃真；修之于家，其德乃馀；修之于乡，其德乃长；修之于邦，其德乃丰；修之于天下，其德乃普。<br>　　故以身观身，以家观家，以乡观乡，以邦观邦，以天下观天下。吾何以知天下然哉？以此。</p>
<p>###【第五十五章】<br>　　含「德」之厚，比于赤子。毒虫不螫，猛兽不据，玃鸟不搏。骨弱筋柔而握固。未知牝牡之合而全作，精之至也。终日号而不嗄，和之至也。<br>　　知和曰「常」，知常曰「明」。益生曰祥。心使气曰强。物壮则老，谓之不道，不道早已。</p>
<p>###【第五十六章】<br>　　知者不言，言者不知。<br>　　塞其兑，闭其门，挫其锐，解其纷，和其光，同其尘，是谓玄同。<br>　　故不可得而亲，不可得而疏，不可得而利，不可得而害，不可得而贵，不可得而贱。故为 天下贵。</p>
<p>###【第五十七章】<br>　　以正治国，以奇用兵，以无事取天下。吾何以知其然哉？以此：<br>　　天下多忌讳，而民弥贫；人多利器，国家滋昏；人多伎巧，奇物滋起；法令滋彰，盗贼多有。<br>　　故圣人云：「我无为，而民自化；我好静，而民自正；我无事，而民自富；我无欲，而民自朴。」</p>
<p>###【第五十八章】<br>　　其政闷闷，其民淳淳。其政察察，其民缺缺。<br>　　祸兮福之所倚，福兮祸之所伏。孰知其极？<br>　　正复为奇，善复为妖。人之迷，其日固久。<br>　　是以圣人方而不割，廉而不刿，直而不肆，光而不耀。</p>
<p>###【第五十九章】<br>　　治人事天，莫若啬。<br>　　夫为啬，是谓早服；早服谓之重积德；重积德则无不克；无不克则莫知其极；莫知其极，可以有国；有国之母，可以长久；是谓深根固柢，长生久视之道。</p>
<p>###【第六十章】<br>　　治大国，若烹小鲜。<br>　　以道莅天下，其鬼不神；非其鬼不神，其神不伤人；非其神不伤人，圣人亦不伤人。夫两不相伤，故德交归焉。</p>
<p>###【第六十一章】<br>　　大国者若下流，天下之交，天下之牝。牝常以静胜牡，以静为下。<br>　　故大国以下小国，则取小国。小国以下大国，则取大国。故或下以取，或下而取。大国不 过欲兼蓄人，小国不过欲入事人。夫两者各得其所欲，大者宜为下。</p>
<p>###【第六十二章】<br>　　道者万物之奥[1]。善人之宝，不善人之所保[2]。<br>　　美言可以市尊，美行可以加人。人之不善，何弃之有？故立天子，置三公，虽有拱璧以先驷马，不如坐进此道。<br>　　古之所以贵此道者何？不曰：求以得，有罪以免邪？故为天下贵。<br>[1]”奥”字，河上公注为”藏”，王弼注为”庇荫”，马王堆汉墓出土的帛书甲、乙本均作”注”，读作”主”。其实，道作为万物之”主”，已将”保藏、庇荫”万物的意思涵括进去了。<br>[2]”保”字,任继愈和陈鼓应的译文，均依河上公”道者，不善人之所宝倚也”，说”道也是恶人所要处处保持的”。</p>
<p>###【第六十三章】<br>　　为无为，事无事，味无味。<br>　　大小多少，抱怨以德。<br>　　图难于其易，为大于其细。天下难事，必作于易，天下大事，必作于细。<br>　　是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难。是以圣人犹难之，故终无难矣。</p>
<p>###【第六十四章】<br>　　其安易持，其未兆易谋。其脆易泮，其微易散。为之于未有，治之于未乱。<br>　　合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。<br>　　为者败之，执者失之。是以圣人无为故无败，无执故无失。<br>　　民之从事，常于几成而败之。慎终如始，则无败事。<br>　　是以圣人欲不欲，不贵难得之货；学不学，复众人之所过。以辅万物之自然，而不敢为。 </p>
<p> ###【第六十五章】<br>　　古之善为道者，非以明民，将以愚之。<br>　　民之难治，以其智多。故以智治国，国之贼；不以智治国，国之福。<br>　　知此两者亦稽式。常知稽式，是谓「玄德」。「玄德」深矣，远矣，与物反矣，然后乃至大顺。</p>
<p>###【第六十六章】<br>　　江海之所以能为百谷王者，以其善下之，故能为百谷王。<br>　　是以圣人欲上民，必以言下之；欲先民，必以身后之。是以圣人处上而民不重，处前而民不害。是以天下乐推而不厌。以其不争，故天下莫能与之争。</p>
<p>###【第六十六章】<br>　　江海之所以能为百谷王者，以其善下之，故能为百谷王。<br>　　是以圣人欲上民，必以言下之；欲先民，必以身后之。是以圣人处上而民不重，处前而民不害。是以天下乐推而不厌。以其不争，故天下莫能与之争。</p>
<p>###【第六十七章】<br>　　天下皆谓我道大，似不肖。夫唯大，故似不肖。若肖，久矣其细也夫！<br>　　我有三宝，持而保之。一曰慈，二曰俭，三曰不敢为天下先。<br>　　慈故能勇；俭故能广；不敢为天下先，故能成器长。<br>　　今舍慈且勇；舍俭且广；舍后且先；死矣！<br>　　夫慈以战则胜，以守则固。天将救之，以慈卫之。</p>
<p>###【第六十八章】<br>　　善为士者，不武；善战者，不怒；善胜敌者，不与；善用人者，为之下。是谓不争之德，是谓用人之力，是谓配天古之极。</p>
<p>###【第六十九章】<br>　　用兵有言：「吾不敢为主，而为客；不敢进寸，而退尺。」是谓行无行；攘无臂；扔无敌；执无兵。<br>　　祸莫大于轻敌，轻敌几丧吾宝。<br>　　故抗兵相若，哀者胜矣。</p>
<p>###【第七十章】<br>　　吾言甚易知，甚易行。天下莫能知，莫能行。<br>　　言有宗，事有君。夫唯无知，是以不我知。<br>　　知我者希，则我者贵。是以圣人被褐而怀玉。</p>
<p>###【第七十一章】<br>　　知不知，尚矣；不知知，病也。圣人不病，以其病病。夫唯病病，是以不病。</p>
<p>###【第七十二章】<br>　　民不畏威，则大威至。<br>　　无狎其所居，无厌其所生。夫唯不厌，是以不厌。<br>　　是以圣人自知不自见；自爱不自贵。故去彼取此。</p>
<p>###【第七十三章】<br>　　勇于敢则杀，勇于不敢则活。此两者，或利或害。天之所恶，孰知其故？<br>　　天之道，不争而善胜，不言而善应，不召而自来，繟然而善谋。天网恢恢，疏而不失。</p>
<p>###【第七十四章】<br>　　民不畏死，奈何以死惧之？若使民常畏死，而为奇者，吾得执而杀之，孰敢？<br>　　常有司杀者杀。夫代司杀者杀，是谓代大匠斲，夫代大匠斲者，希有不伤其手矣。</p>
<p>###【第七十五章】<br>　　民之饥，以其上食税之多，是以饥。<br>　　民之难治，以其上之有为，是以难治。<br>　　民之轻死，以其上求生之厚，是以轻死。<br>　　夫唯无以生为者，是贤于贵生。</p>
<p>###【第七十六章】<br>　　人之生也柔弱，其死也坚强。<br>　　草木之生也柔脆，其死也枯槁。<br>　　故坚强者死之徒，柔弱者生之徒。<br>　　是以兵强则灭，木强则折。<br>　　强大处下，柔弱处上。</p>
<p>###【第七十七章】<br>　　天之道，其犹张弓欤？高者抑之，下者举之；有馀者损之，不足者补之。<br>　　天之道，损有馀而补不足。人之道，则不然，损不足以奉有馀。<br>　　孰能有馀以奉天下？唯有道者。<br>　　是以圣人为而不恃，功成而不处，其不欲见贤。</p>
<p>###【第七十八章】<br>　　天下莫柔弱于水，而攻坚强者莫之能胜，以其无以易之。<br>　　弱之胜强，柔之胜刚，天下莫不知，莫能行。<br>　　是以圣人云：「受国之垢，是谓社稷主；受国不祥，是为天下王[1]。」正言若反。</p>
<p>###【第七十九章】<br>　　和大怨，必有馀怨；报怨以德，安可以为善？<br>　　是以圣人执左契，而不责于人。有德司契，无德司彻[1]。<br>　　天道无亲，常与善人。</p>
<p>###【第八十章】<br>　　小国寡民。使有什伯之器而不用；使民重死而不远徙。虽有舟舆，无所乘之，虽有甲兵，无所陈之。<br>　　使民复结绳而用之。甘其食，美其服，安其居，乐其俗。邻国相望，鸡犬之声相闻，民至老死，不相往来。</p>
<p> ###【第八十一章】<br>　　信言不美，美言不信。<br>　　善者不辩，辩者不善。<br>　　知者不博，博者不知。<br>　　圣人不积，既以为人己愈有，既以与人己愈多。<br>　　天之道，利而不害；圣人之道，为而不争。<br>老子：<br>　　中国先秦时期思想家，道家学派创始人。关于的姓字，历来说法不一。《庄子》称他为老聃，书中的内篇《德充符》，外篇《天地》、《天运》、《田子方》、《知北游》等都把视为前辈，这是战国中晚期道家学派笔下的。秦汉之际成书的《礼记》中《曾子问》篇也把视为与孔子同时代的知礼守礼的长者。《史记韩非列传》大体上把描写为道家，其中搀入老莱子和太史儋两个名字。也有学者认为可能「老」是的姓或氏，其名为聃，故称老聃。但其他一些学者对《》一书是否为老聃所作也有疑问。当今学术界不少人认为其人可能生活于春秋末年，《》一书却是战国时期的作品。但探讨哲学，只能以《》一书为依据。<br>　　哲学思想<br>　　道是思想体系的核心，他说：「道生一，一生二，二生三，三生万物」（《》四十二章），认为一切由道生出。关于道，《》有多种解释。①道的特征是「无状之状，无象之象」。《》第二十一章说：「道之为物，惟恍惟惚，惚兮恍兮，其中有象；恍兮惚兮，其中有物。」第十四章又说：「无状之状，无象之象，是谓惚恍。」②道是世界万物的本原。第二十五章说：「有物混成，先天地生，寂兮寥兮，独立而不改，周行而不殆，可以为天下母。」③道是无。第四十章说：「天下万物生于有，有生于无。」在这里生于「无」即是生于「道」，「道」就是「无」。<br>　　朴素辩证法思想<br>　　认为自然界和人类社会都是变动不居的。他观察到天地间万物万事存在着互相矛盾的两个对立面，例如有无、刚柔、强弱、祸福、兴废等等，它们都是互相依存、互相联结的。所以说：「有无相生，难易相成，长短相形。」还说：「贵以贱为本，高以下为基」，「祸兮福所倚，福兮祸所伏」，表明了对立面双方的同一性。还认识到对立面不是一成不变的，它们在向相反的一面转化，他说：「正复为奇，善复为妖」，「曲则全，枉则直，洼则盈，敝则新，少则得，多则惑」。承认转化，但强调「圣人之道，为而不争」，「以其不争，故天下莫能与之争」。<br>　　的辩证法思想在军事战略战术的运用方面也很突出。在战术上，他主张「以奇用兵」，还要注意「将欲弱之，以固强之」，「将欲夺之，必固与之」。在战略上，他提出「柔弱胜刚强」的指导思想，他说天下没有比水更柔弱的东西，但攻坚的力量莫过于它。这种战略思想有防止盲目骄傲的一面，但也具有极大的片面性。<br>　　认识论<br>　　否认人的认识来源于感觉经验，「不出户，知天下；不窥牖，知天道。其出弥远，其知弥少。是以圣人不行而知，不见而名，不为而成」。他还宣扬「涤除玄览」的直观方法，教人们洗心内照。他站在统治者的立场上，反对启迪民智，要人们做到「绝圣弃智」，「绝学无忧」。他认为，「古之善为道者，非以明民，将以愚之。民之难治，以其智多」。因此，主张「常使民无知无欲」。<br>　　社会历史观<br>　　主张「小国寡民，使民有什伯之器而不用，使民重死而不远徙。虽有舟舆，无所乘之；虽有甲兵，无所陈之；使人复结绳而用之」，「邻国相望，鸡犬之声相闻，民至老死不相往来」。他向往结绳记事的原始社会，认为在这种社会中人民会「甘其食，美其服，安其居，乐其俗」，表现出复古倒退的消极思想。<br>　　对中国哲学的影响<br>　　首先提出了「道」这一最高的哲学概念，以「道」为天地万物存在的本原，对于历代的思想家曾产生过深刻的影响。战国末年的韩非，利用并改造了关于「道」的学说，认为「道」是万事万物的总法则。战国时期形成到汉初盛行的道家学派的黄老之学，也利用的「道」缔造自己的学说体系。将「道」和法家思想直接联系起来。导源于的黄老自然主义对无神论思想产生了很大的影响。东汉唯物主义者王充著《论衡》，亦取道家自然之说。<br>　　东汉时，道教形成，五斗米道规定信徒诵习《》五千文。道教发挥《》原有长生久视之说，河上公《章句》着重宣扬「自然长生之道」。《想尔注》亦言「不知长生之道，身皆尸行耳」。练形长生，成为道教哲学的中心思想。魏晋玄学盛行时，《》为三玄之一，何晏作《道德论》，王弼撰《注》，发挥唯心主义本体论。</p>
<h2 id="魏晋以后，引道入儒，儒、道合流，思想对后世儒家特别是革新派改良派如王安石、魏源、严复等产生一定影响。2000多年来，对哲学历代有各种各样的解说和注评，有的接近原著本义，有的不拘原著，肆意发挥。哲学作为中国古代思想的重要遗产，它在哲学、政治、人生诸方面，都曾发生过积极的或消极的重大影响。"><a href="#魏晋以后，引道入儒，儒、道合流，思想对后世儒家特别是革新派改良派如王安石、魏源、严复等产生一定影响。2000多年来，对哲学历代有各种各样的解说和注评，有的接近原著本义，有的不拘原著，肆意发挥。哲学作为中国古代思想的重要遗产，它在哲学、政治、人生诸方面，都曾发生过积极的或消极的重大影响。" class="headerlink" title="　　魏晋以后，引道入儒，儒、道合流，思想对后世儒家特别是革新派改良派如王安石、魏源、严复等产生一定影响。2000多年来，对哲学历代有各种各样的解说和注评，有的接近原著本义，有的不拘原著，肆意发挥。哲学作为中国古代思想的重要遗产，它在哲学、政治、人生诸方面，都曾发生过积极的或消极的重大影响。"></a>　　魏晋以后，引道入儒，儒、道合流，思想对后世儒家特别是革新派改良派如王安石、魏源、严复等产生一定影响。2000多年来，对哲学历代有各种各样的解说和注评，有的接近原著本义，有的不拘原著，肆意发挥。哲学作为中国古代思想的重要遗产，它在哲学、政治、人生诸方面，都曾发生过积极的或消极的重大影响。</h2><p>【《老子》：”祸兮福之所倚，福兮祸之所伏”】<br>　　“祸兮福之所倚，福兮祸之所伏。”意思是，祸是造成福的前提，而福又含有祸的因素。也就是说，好事和坏事是可以互相转化的，在一定的条件下，福就会变成祸，祸也能变成福。说的这句名言，是很有道理的。<br>　　是中国，也是全世界最早具有辩证法思想的哲学家之一。关于其人、其书及其”道论”历来有争论。根据司马迁在《史记》一书中给他写的一个简单的传记来看，他是春秋时著名的思想家、道家学派的创始人。，姓李名耳，字聃，楚国苦县（今河南鹿邑县）厉乡曲仁里人。””是人们对他的称呼，”老”是年高德重的意思，”子”是古代对男子的美称。他的生卒年月不详。<br>　　做过周朝的”守藏室史”（相当于现在的国家图书馆馆长或历史博物馆馆长），所以他谙于掌故，熟于礼制，不仅有丰富的历史知识，并有广泛的自然科学知识。<br>　　公元前520年，周王室发生争夺王位的内战，这年4月，周景王卒，大夫刘耿立王子猛为悼王。王子朝杀悼王自立。晋人攻王子朝，立王子匄为敬王。这次内战达5年之久，公元前516年，王子朝失败，席卷周室典籍，逃奔楚国；所掌握的图书亦被带走。于是，遂被罢免而归居。形势的变化，使的地位发生变化，使他的思想起了大转变，由守礼转向反礼。<br>　　由于身受奴隶主贵族当权者的迫害，为了避免祸害，不得不”自隐无名”，流落四方，后来，他西行去秦国。经过函谷关（今河南灵宝县西南）时，关令尹喜知道将远走隐去，便请留言。于是写下了5000字的《》。相传出关时，骑着青牛飘然而去。<br>　　的思想主张，大都保存在《》一书中。《》共81章，分上下两篇，共5000多字。因为它所讲的是道与德的问题，后来人们又称它为《道德经》。现在我们所见到的《》一书，并不是的原著，因有战国时人增益的文字，但其中的主要思想却是属于的。<br>　　《》一书，文词简短，艰深难懂，因此后人作了许多注解。最通行的有西汉时道学家河上公（姓名不详）注，三国时魏国哲学家王弼注，还有清朝时魏源的《本义》，等等。下面我们就通过《》这本书，来了解的哲学和政治思想。<br>　　“道”是天地万物的本源。是我国第一个力图从自然本身来解释世界，而不求助于超自然的主宰──天帝的意志的哲学家。在之前，人们以为宇宙间的万物都有神在统治着，最高的神就是天，又称天帝。这种观念，到了社会大变革的春秋时期才开始了变化。就是较早的从哲学方面有意识地、明确地否认天帝的思想家。他在《周易》的基础上，进一步阐明”道”是天地万物的本源。”道论”的中心思想是：”道即自然，自然即道”。他说，”道”是万物之母：”道可道，非常道。名可名，非常名。无，名天地之始。<br>　　有，名万物之母。”（《第一章》）这就是说，作为宇宙的本源就是道，它是永远存在的。道的运行是自由的、必然的，即按其自身的规律而运行。天地万物都是由它产生的，它是宇宙的母体。<br>　　认为，道产生了天地，德是道的性能，天地生养着万物，万物各成其形，各备其用。所以万物没有不尊道而贵德的。道的尊崇，德的贵重，不是有谁给它爵位，而是自然而然的。所以道产生天地，德畜养万物，长育万物，成熟万物，覆盖万物。他说：”道生之，德畜之，物形之，器成之。<br>　　是以万物莫不尊道而贵德。道之尊，德之贵，夫莫之爵，而常自然。故道生之，德畜之，长之育之，亭之毒之，盖之覆之。”（《第五十一章》）这样，遂把自然创造的根源归于自然本身，从而摧毁了一切超自然的主宰，一切宗教和唯心论的基础。因此，的天道自然观，在当时有很大的进步意义，它打倒了宗教的天帝，否认了鬼神的威灵。当然，的”道论”刚从传统的宗教解放出来，还未能完全摆脱宗教的影响；他的自然决定论，使人完全听命于自然，轻视了人对自然界的反作用。后来有的哲学家把它发展为定命论，为害颇大。<br>　　“无为而治”。的”道论”，基本上可概括为”天道自然观”。所以的人生哲学和政治哲学基本上是人当法道，顺其自然。至于如何治理国家呢？他认为最好是采取”无为而治”的办法，让人民去过自由自在的生活，用无所作为听其自然发展的办法，来达到治理好国家的目的。在看来，无为正是有所作为，”无为而无不为”，就是这个意思。反对用刑、礼、智这些来治理国家，他反对加重人民税收，反对拥有强大的兵力，他说过：”乐杀人者，则不可以得志于天下。”（《第三十一章》）他同时也反对工商业，反对知识和文化。他说：”绝圣弃智，民利百倍。绝仁弃义，民复孝慈。绝巧弃利，盗贼无有。此三者以为文不足。故令有所属。见素抱扑，少私寡欲，绝学无忧。”（《第十九章》）在看来，人类社会不要”圣智”、”仁义”、”巧利”，国家就大治了。这三种东西不足以治国，最好的办法是，使人们着意于”朴素”，少有”私欲”，不求知识，就可以没有忧患了。<br>　　的社会历史观是不现实的，他为了反对当时的剥削制度，从而反对一切社会制度。为了反对剥削阶级的文化，从而反对一切文化。为了反对欺诈，从而反对一切知识。这是他消极的一面。他以为只有抛弃了智慧，人民才有百倍的利益，只有抛弃了文化学问，才能免于忧虑，这种愚民政策，也被后世的统治阶级所利用。<br>　　那么，所向往的理想世界是什么呢？是小国寡民的原始社会。他说：”小国寡民，使民有什伯之器而不用，使民重死而不远徙。虽有舟舆，无所乘之。虽有甲兵，无所陈之。<br>　　使民复结绳而用之。甘其食，美其服，安其居，乐其俗，邻国相望，鸡犬之声闻，民至老死不相往来。”（《第八十章》）<br>　　这一设想，在一定程度上反映了当时人民迫切要求休养生息和减轻剥削的愿望。说过，人民为什么过着饥寒的生活呢？是因为他们的君主取赋税多的缘故。”民之饥，以其上食税之多”（《第七十五章》）。又说”民不畏死，奈何以死惧之？”（《第七十四章》）这反映了政治思想中的进步因素。但是，小国寡民的理想，却是幻想，它是违反社会历史发展规律的。但我们应当看到，的这一举动是抨击奴隶社会制度的不合理，它对后世的进步思想家、空想的社会改革家却有着深远的影响。<br>　　相反相成。学说的精髓，是他光辉的辩证法思想。观察了自然界的变化，生与死、新与旧的相互关系，观察了社会历史与政治的成与败、福与祸等对立的双方的相互关系，发现了事物内部所具有的一些辩证规律。《》一书中，还深刻地论证了相反相成和物极必反的道理。说过，有和无是彼此相生的，难和易是彼此相成的，长和短只有彼此比较才能显现出来，不同的声音产生谐和，前后互相对立而有了顺序。总之，承认事物是在矛盾中发展的。<br>　　物极必反，是说事物在变化中向它相反的方面过渡，到了一定的时候就完全成为相反的东西。因此，一再告诫统治者，必须去掉那些极端的、过分的措施，否则，就会使事物走向另一个极端，结果就会丧失天下。他认为，高明的统治者必须懂得以柔弱胜刚强的道理。为了证明以弱胜强，以柔胜刚的道理，他举了许多的例子。他经常用水来比喻自然力量的伟大，比喻人类高尚的品质。他说：”天下莫柔弱于水，而攻坚强者莫之能胜。其无以易之。柔之胜刚，弱之胜强，天下莫不知，莫能行。”（《第七十八章》）意思是说，天下万物没有比水更柔弱的了，而攻击坚强的力量没有能胜过水的，这个事实是无法改变的。柔的战胜刚的，弱的战胜强的，天下没有人不懂的，可是没有人能做到。又举军队强大了就会破灭，树木强大就会摧折的例子。但他把弱能胜强，柔能胜刚，当作绝对的规律，没能认识到这种互相转化不是无条件的，而是有条件的。尽管如此，认为在发展过程中柔弱的是不可战胜的，这对于促使人们认识新生的力量是不可战胜的道理是有着积极意义的。所处的时代，是动荡不安、战争频繁的春秋末期，正是由奴隶社会向封建社会过渡的时代，他提出这一观点，也具有积极的现实意义。<br>　　还初步意识到量的积累可以引起质的变化。他说过，大树是由细小的萌芽产生的；九层的高台，是由一堆泥土筑起的；千里的远行，必须从脚下的第一步开始。（见《第六十四章》）<br>　　当然，的自然辩证观是直观的、原始的、朴素的、缺乏科学的论证。同时，他的辩证观还缺乏不可调和的斗争精神。这是他受了时代和阶级的限制。尽管如此，《》一书中上述的这些光辉的思想火花，是很值得我们珍视的一份历史遗产。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Events]]></title>
      <url>https://yanlee26.github.io/2016/03/03/events/</url>
      <content type="html"><![CDATA[<h1 id="web-events-值均为script"><a href="#web-events-值均为script" class="headerlink" title="web events(值均为script)"></a>web events(值均为script)</h1><h3 id="事件类型（DOM3级）"><a href="#事件类型（DOM3级）" class="headerlink" title="事件类型（DOM3级）"></a>事件类型（DOM3级）</h3><table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UI事件</td>
<td style="text-align:center">用户与页面上元素交互</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">焦点事件</td>
<td style="text-align:center">元素得失焦点触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">鼠标事件</td>
<td style="text-align:center">用户用鼠标与页面交互</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">滚轮事件</td>
<td style="text-align:center">用户用鼠标滚轮与页面交互</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">文本事件</td>
<td style="text-align:center">用户在文档中输入文本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">键盘事件</td>
<td style="text-align:center">用户用键盘与页面交互</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">合成事件</td>
<td style="text-align:center">当为IME(输入法编辑器)输入字符时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">变动事件</td>
<td style="text-align:center">底层DOM结构变动时触发</td>
</tr>
</tbody>
</table>
<h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><ol>
<li>window事件属性（适用于body标签）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onafterprint</td>
<td style="text-align:center">在打印文档之后运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onbeforeprint</td>
<td style="text-align:center">在文档打印之前运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onbeforeonload</td>
<td style="text-align:center">在文档加载之前运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:center">当窗口失去焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:center">当错误发生时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:center">当窗口获得焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onhaschange</td>
<td style="text-align:center">当文档改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:center">当文档加载时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmessage</td>
<td style="text-align:center">当触发消息时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onoffline</td>
<td style="text-align:center">当文档离线时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ononline</td>
<td style="text-align:center">当文档上线时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpagehide</td>
<td style="text-align:center">当窗口隐藏时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpageshow</td>
<td style="text-align:center">当窗口可见时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpopstate</td>
<td style="text-align:center">当文档执行再执行操作（redo）时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onresize</td>
<td style="text-align:center">当调整窗口大小时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onstorage</td>
<td style="text-align:center">当文档加载加载时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onundo</td>
<td style="text-align:center">当 Web Storage 区域更新时（存储空间中的数据发生变化时）</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onunload</td>
<td style="text-align:center">当用户离开文档时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>form事件属性(适用于所有h5元素，常用于表单)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:center">当元素失去焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onchange</td>
<td style="text-align:center">当元素改变时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">oncontextmenu</td>
<td style="text-align:center">当触发上下文菜单时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:center">当元素获得焦点时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onformchange</td>
<td style="text-align:center">当表单改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onforminput</td>
<td style="text-align:center">当表单获得用户输入时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">oninput</td>
<td style="text-align:center">当元素获得用户输入时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">oninvalid</td>
<td style="text-align:center">当元素无效时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onreset</td>
<td style="text-align:center">当表单重置时运行脚本。HTML 5 不支持</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onselect</td>
<td style="text-align:center">当选取元素时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onsubmit</td>
<td style="text-align:center">当提交表单时运行脚本</td>
</tr>
</tbody>
</table>
<ol>
<li>keyboard事件(适用于所有h5元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onkeydown</td>
<td style="text-align:center">当按下按键时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onkeypress</td>
<td style="text-align:center">当按下并松开按键时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onkeyup</td>
<td style="text-align:center">当松开按键时运行脚本</td>
</tr>
</tbody>
</table>
<ol>
<li>mouse事件(适用于所有h5元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onclick</td>
<td style="text-align:center">当单击鼠标时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ondblclick</td>
<td style="text-align:center">当双击鼠标时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ondrag</td>
<td style="text-align:center">当拖动元素时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragend</td>
<td style="text-align:center">当拖动操作结束时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragenter</td>
<td style="text-align:center">当元素被拖动至有效的拖放目标时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragleave</td>
<td style="text-align:center">当元素离开有效拖放目标时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragover</td>
<td style="text-align:center">当元素被拖动至有效拖放目标上方时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragstart</td>
<td style="text-align:center">当拖动操作开始时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondrop</td>
<td style="text-align:center">当被拖动元素正在被拖放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onmousedown</td>
<td style="text-align:center">当按下鼠标按钮时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmousemove</td>
<td style="text-align:center">当鼠标指针移动时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseout</td>
<td style="text-align:center">当鼠标指针移出元素时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseover</td>
<td style="text-align:center">当鼠标指针移至元素之上时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseup</td>
<td style="text-align:center">当松开鼠标按钮时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmousewheel</td>
<td style="text-align:center">当转动鼠标滚轮时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onscroll</td>
<td style="text-align:center">当滚动元素滚动元素的滚动条时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>media事件(适用于所有h5元素,常用于媒体元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onabort</td>
<td style="text-align:center">当发生中止事件时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">oncanplay</td>
<td style="text-align:center">当媒介能够开始播放但可能因缓冲而需要停止时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">oncanplaythrough</td>
<td style="text-align:center">当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondurationchange</td>
<td style="text-align:center">当媒介长度改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onemptied</td>
<td style="text-align:center">当媒介资源元素突然为空时（网络错误、加载错误等）运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onended</td>
<td style="text-align:center">当媒介已抵达结尾时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:center">当在元素加载期间发生错误时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadeddata</td>
<td style="text-align:center">当加载媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadedmetadata</td>
<td style="text-align:center">当媒介元素的持续时间以及其他媒介数据已加载时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadstart</td>
<td style="text-align:center">当浏览器开始加载媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpause</td>
<td style="text-align:center">当媒介数据暂停时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onplay</td>
<td style="text-align:center">当媒介数据将要开始播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onplaying</td>
<td style="text-align:center">当媒介数据已开始播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onprogress</td>
<td style="text-align:center">当浏览器正在取媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onratechange</td>
<td style="text-align:center">当媒介数据的播放速率改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onreadystatechange</td>
<td style="text-align:center">当就绪状态（ready-state）改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onseeked</td>
<td style="text-align:center">当媒介元素的定位属性 [1] 不再为真且定位已结束时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onseeking</td>
<td style="text-align:center">当媒介元素的定位属性为真且定位已开始时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onstalled</td>
<td style="text-align:center">当取回媒介数据过程中（延迟）存在错误时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onsuspend</td>
<td style="text-align:center">当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ontimeupdate</td>
<td style="text-align:center">当媒介改变其播放位置时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onvolumechange</td>
<td style="text-align:center">当媒介改变音量亦或当音量被设置为静音时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onwaiting</td>
<td style="text-align:center">当媒介已停止播放但打算继续播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>其它事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onshow</td>
<td style="text-align:center">当 <menu> 元素在上下文显示时触发</menu></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ontoggle</td>
<td style="text-align:center">当用户打开或关闭 <details> 元素时触发</details></td>
</tr>
</tbody>
</table>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><blockquote>
<p> 理解click的300ms的延迟响应<br>   Click事件在移动手机开发中有300ms的延迟，因为在手机早期，浏览器系统有放大和缩放功能，用户在屏幕上点击两次之后，<br>   系统会触发放大或者缩放功能，因此系统做了一个处理，当触摸一次后，在300ms这段时间内有没有触摸第二次，<br>   如果触摸了第二次的话，说明是触发放大或缩放功能，否则的话是click事件。因此当click时候，所有用户必须等待于300ms后才<br>   会触发click事件。所以当在移动端使用click事件的时候，会感觉到有300ms的迟钝。</p>
</blockquote>
<ol>
<li>touch事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">touchstart</td>
<td style="text-align:center">当手指放在屏幕上触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchmove</td>
<td style="text-align:center">当手指在屏幕上滑动时，连续地触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchend</td>
<td style="text-align:center">当手指从屏幕上离开时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchcancel</td>
<td style="text-align:center">当系统停止跟踪时触发; 该事件暂时使用不到</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touches</td>
<td style="text-align:center">表示当前跟踪的触摸操作的touch对象的数组</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">targetTouches</td>
<td style="text-align:center">特定于事件目标的touch对象的数组</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">changedTouches</td>
<td style="text-align:center">上次触摸以来发生了什么改变的touch对象的数组</td>
</tr>
</tbody>
</table>
<ol>
<li>gesture事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">gesturestart</td>
<td style="text-align:center">当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">gesturechange</td>
<td style="text-align:center">当触摸屏幕的任何一个手指的位置发生改变的时候触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">gestureend</td>
<td style="text-align:center">当任何一个手指从屏幕上面移开时触发</td>
</tr>
</tbody>
</table>
<blockquote>
<p>触摸事件和手势事件的之间关系：<br>当一个手指放在屏幕上时，会触发touchstart事件，而另一个手指触摸在屏幕上时<br>触发gesturestart事件，随后触发基于该手指的touchstart事件。<br>如果一个或两个手指在屏幕上滑动时，将会触发gesturechange事件，但是只要有一个手指移开时候，则会触发gestureend事件，<br>紧接着会触发touchend事件。<br>手势的专有属性:<br>rotation: 表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从0开始；<br>scale: 表示2个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始的，并随距离拉大而增长。</p>
</blockquote>
<h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><ul>
<li>PC端</li>
</ul>
<ol>
<li>window事件属性（适用于body标签）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:center">当窗口失去焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:center">当错误发生时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:center">当窗口获得焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:center">当文档加载时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onresize</td>
<td style="text-align:center">当调整窗口大小时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>form事件属性(适用于所有h5元素，常用于表单)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:center">当元素失去焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onchange</td>
<td style="text-align:center">当元素改变时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:center">当元素获得焦点时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">oninput</td>
<td style="text-align:center">当元素获得用户输入时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onreset</td>
<td style="text-align:center">当表单重置时运行脚本。HTML 5 不支持</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onselect</td>
<td style="text-align:center">当选取元素时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onsubmit</td>
<td style="text-align:center">当提交表单时运行脚本</td>
</tr>
</tbody>
</table>
<ol>
<li>keyboard事件(适用于所有h5元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onkeydown</td>
<td style="text-align:center">当按下按键时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onkeypress</td>
<td style="text-align:center">当按下并松开按键时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onkeyup</td>
<td style="text-align:center">当松开按键时运行脚本</td>
</tr>
</tbody>
</table>
<ol>
<li>mouse事件(适用于所有h5元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onclick</td>
<td style="text-align:center">当单击鼠标时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ondblclick</td>
<td style="text-align:center">当双击鼠标时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ondrag</td>
<td style="text-align:center">当拖动元素时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragend</td>
<td style="text-align:center">当拖动操作结束时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragenter</td>
<td style="text-align:center">当元素被拖动至有效的拖放目标时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragleave</td>
<td style="text-align:center">当元素离开有效拖放目标时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragover</td>
<td style="text-align:center">当元素被拖动至有效拖放目标上方时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragstart</td>
<td style="text-align:center">当拖动操作开始时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondrop</td>
<td style="text-align:center">当被拖动元素正在被拖放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onmousedown</td>
<td style="text-align:center">当按下鼠标按钮时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmousemove</td>
<td style="text-align:center">当鼠标指针移动时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseout</td>
<td style="text-align:center">当鼠标指针移出元素时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseover</td>
<td style="text-align:center">当鼠标指针移至元素之上时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseup</td>
<td style="text-align:center">当松开鼠标按钮时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmousewheel</td>
<td style="text-align:center">当转动鼠标滚轮时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onscroll</td>
<td style="text-align:center">当滚动元素滚动元素的滚动条时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>media事件(适用于所有h5元素,常用于媒体元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onabort</td>
<td style="text-align:center">当发生中止事件时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:center">当在元素加载期间发生错误时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadeddata</td>
<td style="text-align:center">当加载媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpause</td>
<td style="text-align:center">当媒介数据暂停时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onplay</td>
<td style="text-align:center">当媒介数据将要开始播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onplaying</td>
<td style="text-align:center">当媒介数据已开始播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onwaiting</td>
<td style="text-align:center">当媒介已停止播放但打算继续播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ul>
<li>移动端<blockquote>
<p> 理解click的300ms的延迟响应<br> Click事件在移动手机开发中有300ms的延迟，因为在手机早期，浏览器系统有放大和缩放功能，用户在屏幕上点击两次之后，<br> 系统会触发放大或者缩放功能，因此系统做了一个处理，当触摸一次后，在300ms这段时间内有没有触摸第二次，<br> 如果触摸了第二次的话，说明是触发放大或缩放功能，否则的话是click事件。因此当click时候，所有用户必须等待于300ms后才<br> 会触发click事件。所以当在移动端使用click事件的时候，会感觉到有300ms的迟钝。</p>
</blockquote>
</li>
</ul>
<ol>
<li>touch事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">touchstart</td>
<td style="text-align:center">当手指放在屏幕上触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchmove</td>
<td style="text-align:center">当手指在屏幕上滑动时，连续地触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchend</td>
<td style="text-align:center">当手指从屏幕上离开时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchcancel</td>
<td style="text-align:center">当系统停止跟踪时触发; 该事件暂时使用不到</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touches</td>
<td style="text-align:center">表示当前跟踪的触摸操作的touch对象的数组</td>
</tr>
</tbody>
</table>
<ol>
<li>gesture事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">gesturestart</td>
<td style="text-align:center">当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">gesturechange</td>
<td style="text-align:center">当触摸屏幕的任何一个手指的位置发生改变的时候触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">gestureend</td>
<td style="text-align:center">当任何一个手指从屏幕上面移开时触发</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS skills]]></title>
      <url>https://yanlee26.github.io/2015/12/01/cssskills/</url>
      <content type="html"><![CDATA[<h1 id="CSS-使用技巧"><a href="#CSS-使用技巧" class="headerlink" title="CSS 使用技巧"></a>CSS 使用技巧</h1><ul>
<li>文字<ol>
<li>水平居中<br><code>text-aligh:center</code></li>
<li>垂直居中<br><code>div{height:35px;line-height:35px}//1/n容器高度</code></li>
</ol>
</li>
<li>容器<ol>
<li>水平居中<br><code>div{width:760px;margin:0 auto}</code></li>
<li>垂直居中<br><code>.outer{
 position:relative;
 height:480px;
}
.inner{
position:absolute;
top:50%;
height:240px;
margin-top:-120px;
//然后，将小容器定位为absolute，再将它的左上角沿y轴下移50%，最后将它margin-top上移本身高度的50%即可。
}</code></li>
</ol>
</li>
<li>图片宽度自适应<br>  <code>img{max-width:100%}</code></li>
<li>3D按钮<br>  <code>button {
　　　　background: #888;
　　　　border: 1px solid;
　　　　border-color: #999 #777 #777 #999;
　　}</code></li>
<li>font属性</li>
</ul>
<p><code>body { 
　　　　font-family: Arial, Helvetica, sans-serif; 
　　　　font-size: 13px; 
　　　　font-weight: normal; 
　　　　font-variant: small-caps; 
　　　　font-style: italic; 
　　　　line-height: 150%; 
　　}
body { 
　　　　font: italic small-caps normal 13px/150% Arial, Helvetica, sans-serif; 
　　}</code></p>
<ul>
<li>link状态设置顺序<br>  <code>a:link 
　　a:visited 
　　a:hover 
　　a:active</code></li>
<li><p>IE条件注释<br><code>&lt;!--[if IE]&gt; 
　　　　&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie-stylesheet.css&quot; /&gt; 
　　&lt; ![endif]--&gt;</code></p>
</li>
<li><p>CSS 优先级<br>`<br>　　行内样式 &gt; id样式 &gt; class样式 &gt; 标签名样式</p>
</li>
</ul>
<p>`</p>
<ul>
<li>font-size基准<br><code>body {font-size:62.5%;}
//浏览器的缺省字体大小是16px，你可以先将基准字体大小设为10px：</code></li>
<li>Text-transform和Font Variant<br><code>p {text-transform: uppercase} 
　　p {text-transform: lowercase} 
　　p {text-transform: capitalize}</code></li>
<li>reset<br>`</li>
</ul>
<p>`</p>
<ul>
<li>图片列表<br><code>ul {list-style: none}
　　ul li { 
　　　　background-image: url(&quot;path-to-your-image&quot;); 
　　　　background-repeat: none; 
　　　　background-position: 0 0.5em; 
　　}</code></li>
<li>三角形<br><code>.triangle { 
　　　　border-color: transparent transparent green transparent;
　　　　border-style: solid; 
　　　　border-width: 0px 300px 300px 300px; 
　　　　height: 0px; 
　　　　width: 0px; 
　　}</code></li>
<li>禁止自动换行<br><code>p { white-space:nowrap; }</code></li>
<li>用图片替换文字—有时我们需要在标题栏中使用图片，但是又必须保证搜索引擎能够读到标题<br><code>h1 { 
　　　　text-indent:-9999px; 
　　　　background:url(&quot;h1-image.jpg&quot;) no-repeat; 
　　　　width:200px; 
　　　　height:50px; 
　　}</code></li>
<li>焦点突出<br><code>input:focus { border: 2px solid green; }</code></li>
<li>CSS 提示框<br><code>&lt;a class=&quot;tooltip&quot; href=&quot;#&quot;&gt;链接文字 &lt;span&gt;提示文字&lt;/span&gt;&lt;/a&gt;
a.tooltip {position: relative} 
　　a.tooltip span {display:none; padding:5px; width:200px;} 
　　a:hover {background:#fff;} /*background-color is a must for IE6*/ 
　　a.tooltip:hover span{display:inline; position:absolute;}</code></li>
<li>固定位置<br><code>body{ margin:0;padding:100px 0 0 0;}
　　div#header{
　　　　position:absolute;
　　　　top:0;
　　　　left:0;
　　　　width:100%;
　　　　height:&lt;length&gt;;
　　}
　　@media screen{
　　　　body&gt;div#header{position: fixed;}
　　}
　　* html body{overflow:hidden;}
　　* html div#content{height:100%;overflow:auto;}</code></li>
<li>图片预加载<br><a href="https://perishablepress.com/3-ways-preload-images-css-javascript-ajax/" target="_blank" rel="external">预加载</a></li>
<li>CSS选择器<br><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="external">CSS选择器</a></li>
<li>背景图定位<br><a href="http://www.ruanyifeng.com/blog/2008/05/css_background_image_positioning.html" target="_blank" rel="external">定位</a></li>
</ul>
<h3 id="3D旋转视频展示区"><a href="#3D旋转视频展示区" class="headerlink" title="3D旋转视频展示区"></a>3D旋转视频展示区</h3><p>`</p>
<p><style><br>body {<br>    margin-top: 5em;<br>    text-align: center;<br>    color: #414142;<br>    background: rgb(246,241,232);<br>    /<em>制作多背景</em>/<br>    background-image: -ms-radial-gradient(farthest-side ellipse at center,  rgba(246,241,232,.85) 39%,rgba(212,204,186,.5) 100%), url(“<a href="http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg">http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg</a>“);<br>    background-image: -webkit-radial-gradient(farthest-side ellipse at center,  rgba(246,241,232,.85) 39%,rgba(212,204,186,.5) 100%), url(“<a href="http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg">http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg</a>“);<br>    background-image: radial-gradient( farthest-side ellipse at center,  rgba(246,241,232,.85) 39%,rgba(212,204,186,.5) 100%), url(“<a href="http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg">http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg</a>“);<br>    /<em>控制背景图像尺寸</em>/<br>    background-size: cover;<br>}</p>
<p>h1, em, #information {<br>    display: block;<br>    font-size: 25px;<br>    font-weight: normal;<br>    margin: 2em auto;<br>}</p>
<p>a {<br>    color: #414142;<br>    font-style: normal;<br>    text-decoration: none;<br>    font-size: 20px;<br>}</p>
<p>a:hover {<br>    text-decoration: underline;<br>}</p>
<p>#container {<br>    margin: 0 auto;<br>    width: 1024px;<br>}</p>
<p>.wrapper {<br>    display: inline-block;<br>    width: 310px;<br>    height: 100px;<br>    vertical-align: top;<br>    margin: 1em 1.5em 2em 0;<br>    cursor: pointer;<br>    position: relative;<br>    font-family: Tahoma, Arial;<br>    -webkit-perspective: 4000px;<br>    -moz-perspective: 4000px;<br>    -ms-perspective: 4000px;<br>    -o-perspective: 4000px;<br>    perspective: 4000px;<br>}</p>
<p>.item {<br>    height: 100px;<br>    -webkit-transform-style: preserve-3d;<br>    -moz-transform-style: preserve-3d;<br>    -ms-transform-style: preserve-3d;<br>    -o-transform-style: preserve-3d;<br>    transform-style: preserve-3d;<br>    /<em>给每个列表项添加过渡动画效果</em>/<br>    -webkit-transition: -webkit-transform .6s;<br>    -moz-transition: -moz-transform .6s;<br>    -ms-transition: -ms-transform .6s;<br>    -o-transition: -o-transform .6s;<br>    transition: transform .6s;<br>}</p>
<p>.item:hover {<br>    /<em>悬浮状态改变每个列表项的transform效果</em>/<br>    -webkit-transform: translateZ(-50px) rotateX(95deg);<br>    -moz-transform: translateZ(-50px) rotateX(95deg);<br>    -ms-transform: translateZ(-50px) rotateX(95deg);<br>    -o-transform: translateZ(-50px) rotateX(95deg);<br>    transform: translateZ(-50px) rotateX(95deg);<br>}<br>.itemimg {<br>    display: block;<br>    position: absolute;<br>    top: 0;<br>    /<em>设置列表项图片的圆角和阴影效果</em>/<br>    border-radius: 3px;<br>    box-shadow: 0px 3px 8px rgba(0,0,0,0.3);<br>   -webkit-transform: translateZ(50px);<br>   -moz-transform: translateZ(50px);<br>   -ms-transform: translateZ(50px);<br>   -o-transform: translateZ(50px);<br>    transform: translateZ(50px);<br>   -webkit-transition: all .6s;<br>   -moz-transition: all .6s;<br>   -ms-transition: all .6s;<br>   -o-transition: all .6s;<br>    transition: all .6s;<br>    width: 310px;<br>    height: 100px;<br> }</p>
<p>.item .information {<br>    display: block;<br>    position: absolute;<br>    top: 0;<br>    height: 80px;<br>    width: 290px;<br>    text-align: left;<br>    border-radius: 15px;<br>    padding: 10px;<br>    font-size: 12px;<br>    text-shadow: 1px 1px1pxrgba(255,255,255,0.5);<br>    box-shadow: none;<br>    background: rgb(236,241,244);<br>    /<em>给底层显示文本的层级设置渐变效果</em>/<br>    background: -webkit-linear-gradient(to bottom,  rgba(236,241,244,1) 0%,rgba(190,202,217,1) 100%);<br>    background: -ms-linear-gradient(to bottom,  rgba(236,241,244,1) 0%,rgba(190,202,217,1) 100%);<br>    background: linear-gradient(to bottom,  rgba(236,241,244,1) 0%,rgba(190,202,217,1) 100%);<br>    -webkit-transform: rotateX(-90deg) translateZ(50px);<br>    -moz-transform: rotateX(-90deg) translateZ(50px);<br>    -ms-transform: rotateX(-90deg) translateZ(50px);<br>    -o-transform: rotateX(-90deg) translateZ(50px);<br>    transform: rotateX(-90deg) translateZ(50px);<br>    -webkit-transition: all .6s;<br>    -moz-transition: all .6s;<br>    -ms-transition: all .6s;<br>    -o-transition: all .6s;<br>    transition: all .6s;<br> }</p>
<p>.information strong {<br>    display: block;<br>    margin: .2em 0 .5em 0;<br>    font-size: 20px;<br>    font-family: “Oleo Script”;<br>  }<br>.item:hoverimg {<br>    /<em>列表项悬浮状态时，去掉图片的阴影效果</em>/<br>    box-shadow: none;<br>    border-radius: 15px;<br>}</p>
<p>.item:hover .information {<br>    box-shadow: 0px 3px 8px rgba(0,0,0,0.3);<br>    border-radius: 3px;<br> }<br></style></p>
<div id="container"><br>        <h1>CSS3 3D变形制作视频展示区</h1><br>        <div class="wrapper"><br>            <div class="item"><br>                <img src="http://pic2.qiyipic.com/image/20140415/4e/32/5f/v_105669963_m_601_180_101.jpg"><br>                <span class="information"><br>                    <strong>澳门风云</strong>闻名中外，曾担任美国赌场保安总顾问的魔术手石一坚，终回流澳门退休，更宴请各方朋友到来庆祝生日宴.<br>                </span><br>            </div><br>        </div>

<pre><code>    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic4.qiyipic.com/image/20140417/b5/01/81/a_100003950_m_601_m2_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;改过迁善&lt;/strong&gt;该剧讲述了金明民饰演的律师在失忆后回顾自己以往的所作所为心生忏悔，为弥补自己犯下的错误而与自己曾经工作过的律师事务所对簿公堂的故事。
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic1.qiyipic.com/common/lego/20140521/4515581d06cc4d5b8ab320da2cf3778d.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;父子刑警&lt;/strong&gt;本剧改编自雫井修介小说《Bitter Blood》。剧中，新晋刑警•佐原夏辉（佐藤健饰）被分配到银座警察
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic5.qiyipic.com/image/20140319/7a/8d/4f/a_100003478_m_601_m1_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;果宝特攻3&lt;/strong&gt;果宝特攻3,顾名思义是果宝特攻的第二部续集,已在国家广播电影电视总局备案.暂定剧情为:菠萝吹雪偶然间穿越到了古代的水果世界
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic0.qiyipic.com/image/20140517/ce/e8/42/v_106167752_m_601_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;红眼&lt;/strong&gt;1988年7月16日，从汉城始发的列车发生了一起严重的交通事故，造成100多人死亡。
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic6.qiyipic.com/image/20140303/da/e9/aa/v_105073913_m_601_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;熊出没之夺宝熊兵&lt;/strong&gt;一场漆黑雨夜的意外事故，一段笑料十足的误打误撞，将两个外表相似却内容各异的箱子调换。
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>`</p>
<ul>
<li>分页<br>`<br>ul.pagination {<br>  display: inline-block;<br>  padding: 0;<br>  margin: 0;<br>}</li>
</ul>
<p>ul.pagination li {display: inline;}</p>
<p>ul.pagination li a {<br>    color: black;<br>    float: left;<br>    padding: 8px 16px;<br>    text-decoration: none;<br>}</p>
<p>ul.pagination li a.active {<br>    background-color: #4CAF50;<br>    color: white;<br>}</p>
<p>ul.pagination li a:hover:not(.active) {background-color: #ddd;}<br>//html<br>ul.pagination&gt;li&gt;a<em>8<br>//面包屑导航<br>ul.breadcrumb {<br>    padding: 8px 16px;<br>    list-style: none;<br>    background-color: #eee;<br>}<br>ul.breadcrumb li {display: inline;}<br>ul.breadcrumb li+li:before {<br>    padding: 8px;<br>    color: black;<br>    content: “/\00a0”;<br>}<br>ul.breadcrumb li a {color: green;}<br>//html<br>ul&gt;li&gt;a</em>5<br>`</p>
</div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS深入浅出学习分析总结]]></title>
      <url>https://yanlee26.github.io/2015/09/02/moc_summery/</url>
      <content type="html"><![CDATA[<h1 id="JS深入浅出学习分析总结"><a href="#JS深入浅出学习分析总结" class="headerlink" title="JS深入浅出学习分析总结"></a>JS深入浅出学习分析总结</h1><h2 id="六种数据类型"><a href="#六种数据类型" class="headerlink" title="六种数据类型"></a>六种数据类型</h2><pre><code>弱类型：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num=32;num=&apos;str&apos;;32+32;//64</div><div class="line">32+&apos;32&apos; //64;</div><div class="line">&apos;32&apos;-32 //0</div></pre></td></tr></table></figure>
<p>-数据类型</p>
<pre><code>- 原始类型(五种)：number,string,boolean,null,undefined
- 对象类型object:Function,Array,Date...
</code></pre><ul>
<li><p>隐式转换</p>
<ul>
<li>类型相同，同===</li>
<li>类型不同，尝试类型转换并比较<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">null==undefined;</div><div class="line">number==string转number</div><div class="line">boolean==?转number 1==true //true</div><div class="line">object==number|string尝试对象转为基本类型 new String(&apos;hi&apos;)==&apos;hi&apos; //true,</div><div class="line">其它：false</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>包装对象：string,number,boolean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str=&apos;12&apos;;//string</div><div class="line">str.length ;//2</div><div class="line">str.a=10;//10</div><div class="line">str.a;//undefined,临时对象创建后立即销毁</div><div class="line">var newStr=new String(&apos;12&apos;);//Object</div></pre></td></tr></table></figure>
</li>
<li><p>类型转换</p>
<ul>
<li>typeof：基本类型及function类型（null失效）</li>
<li>instanceof:对象类型，适合自定义对象及原生对象（不同iframe和window间失效）</li>
<li>Object.prototype：[[Class]]适合内置对象和基元类型（null和undefined失效；IE678返回【object Object】）</li>
<li>constructor</li>
<li>duck type<h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2>###表达式</li>
</ul>
</li>
<li>原始表达式：<ul>
<li>常量，直接量：3.14，‘a’</li>
<li>关键字:null,this,true</li>
<li>变量:i,j,k</li>
</ul>
</li>
<li>复合表达式：原始表达式&amp;原始表达式</li>
<li>初始化表达式：[1,2]===new Array(1,2);</li>
<li>函数表达式：var foo=function(){};(function(){})()</li>
<li>属性访问表达式：var o={x:1};o.x;o[x’]</li>
<li>调用表达式：foo()</li>
<li>对象创建表达式：new Func(1);new Object //无参数可以省略’（）‘;<h3 id="运算符（表达式之间）"><a href="#运算符（表达式之间）" class="headerlink" title="运算符（表达式之间）"></a>运算符（表达式之间）</h3></li>
<li>操作数：<ul>
<li>一元：+num;</li>
<li>二元：a+b;</li>
<li>三元：c?a:b</li>
</ul>
</li>
<li>功能：<ul>
<li>赋值：a+=1<br>-比较：a==b</li>
<li>算数：a-b;</li>
<li>位：a|b;</li>
<li>逻辑：exp1&amp;&amp;exp2<br>-字符串：‘a’+’b’</li>
<li>特殊：<pre><code>-delete obj.x //Object.defineProperty(obj,&apos;x&apos;,                      {configurable:false,value:1});
</code></pre><ul>
<li>,:var a,b;</li>
<li>in: var i in item<ul>
<li>instanceof ,typeof</li>
</ul>
</li>
<li>new :obj.hasOwnProperty(‘x’);obj.<strong>proto</strong>.hasOwnProperty(‘x’) //true</li>
<li>this</li>
<li>void:void 0<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2></li>
</ul>
</li>
</ul>
</li>
<li>块语句（js无块及级作用域）和var语句</li>
<li>try catch语句</li>
<li>function,switch,循环（for in(1.顺序不定，2.enumberable为false时不可用；3.受原型链影响),do-while），with</li>
<li>严格模式strict<blockquote>
<p>一种特殊的运行模式，修复了部分语言上的不足，提供了更强的错误检查并增强安全性</p>
<ul>
<li>不允许使用with    </li>
<li>所有变量必须先声明</li>
<li>eval中代码不能创建eval所在作用域下的变量函数，而是为eval单独创建一个作用域并在eval返回时丢弃</li>
<li>函数中的特殊对象arguments是静态副本（不像非严格模式时修改arguments或者参数变量会相互影响）</li>
<li>删除configurable=false的属性会报错而非忽略</li>
<li>禁止八进制字面量（010）</li>
<li>eval,arguments变量为关键字，不可作为变量名函数名</li>
<li>一般函数调用时（非对象方法调用，不使用apply/call/bind等修改this）this指向null而非全局对象，若使用apply/call当传入null或undefined时this指向null或者undefined而非全局。</li>
<li>试图修改writable=false，在不可扩展对象上添加属性时包TypeError而非忽略</li>
<li>arguments.caller,arguments.callee禁用<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li>
</ul>
</blockquote>
</li>
<li>对象结构（原型链）<br><img src="http://img.mukewang.com/5899cf7300011e1c08280441.jpg" alt="属性的属性"></li>
<li>创建对象方法：<ul>
<li>对象字面量</li>
<li>new/原型链<br><img src="http://img.mukewang.com/5899cfd80001d6cb05290393.jpg" alt="原型链的继承"></li>
<li>Object.create()<br><img src="http://img.mukewang.com/5899d0410001527005980329.jpg" alt="Object.create"></li>
</ul>
</li>
<li><p>属性的操作</p>
<ul>
<li>读写<blockquote>
<p>注意for-in操作符可以把对象原型上属性也遍历出来</p>
</blockquote>
</li>
<li>读写异常<figure class="highlight plain"><figcaption><span>obj=&#123;x:1&#125;;var yz;if(obj.y)&#123;yz=obj.y.z&#125;;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var yz=obj&amp;&amp;obj.y&amp;&amp;obj.y.z;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>属性删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var descriptor=Object.getOwnPropertyDescriptor(Object,&apos;prototype&apos;);</div><div class="line">descriptor.configurable;//false,是否可配置</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://img.mukewang.com/5899d324000108a606410289.jpg" alt="图片描述"></p>
<blockquote>
<p>node环境中最后一个也是false</p>
<ul>
<li>属性检测<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hasOwnProperty();</div><div class="line">propertyIsEnumerable()</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p><img src="http://img.mukewang.com/5899d52c00013d8206160360.jpg" alt="图片描述"></p>
<ul>
<li><p>属性枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var o=&#123;x:1,y:2,z:3&#125;;</div><div class="line">&apos;toString&apos; in o;//true</div><div class="line">o.propertyIsEnumerable(&apos;toString&apos;);//false</div><div class="line">var key;</div><div class="line">for(key in o)&#123;console.log(key)&#125;;x,y,z</div><div class="line">var obj=Object.create(o);</div><div class="line">obj.a=4;</div><div class="line">var key;</div><div class="line">for(key in obj)&#123;console.log(key)&#125;;a,x,y,z</div><div class="line">for(key in obj)&#123;if(obj.hasOwnProperty(key)&#123;console.log(key)&#125;)&#125;;a</div></pre></td></tr></table></figure>
</li>
<li><p>get/set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var man=&#123;</div><div class="line">    name:&apos;yl&apos;,</div><div class="line">    get age()&#123;return new Date.getFullYear()-1990&#125;,</div><div class="line">    set age(val)&#123;console.log(&apos;np&apos;+val)&#125;</div><div class="line">&#125;</div><div class="line">man.age;//27</div><div class="line">man.age=12;//np12</div></pre></td></tr></table></figure>
</li>
<li><p>属性标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptor(&#123;pro:true&#125;,&apos;pro&apos;);</div><div class="line">//Object&#123;value:true,writable:true,enumerable:true,configurable:true&#125;</div><div class="line">Object.getOwnPropertyDescriptor(&#123;pro:true&#125;,&apos;a&apos;);//undefined</div><div class="line">var person=&#123;&#125;;</div><div class="line">Object.defineProperty(person,&apos;name&apos;,&#123;</div><div class="line">    configurable:false,</div><div class="line">    writable:false,</div><div class="line">    enumerable:true,</div><div class="line">    value:&apos;yl&apos;</div><div class="line">&#125;);</div><div class="line">person.name;//yl</div><div class="line">person.name=1;</div><div class="line">person.name;//yl</div><div class="line">delete person.name;//false</div><div class="line">Object.defineProperty(person,&apos;type&apos;,&#123;</div><div class="line">    configurable:true,</div><div class="line">    writable:true,</div><div class="line">    enumerable:false,</div><div class="line">    value:&apos;Object&apos;</div><div class="line">&#125;);</div><div class="line">Object.keys(person);//[&apos;name&apos;]</div><div class="line">//多个属性</div><div class="line">Object.defineProperties(person,&#123;</div><div class="line">    title1:&#123;value:&apos;fe1&apos;,enumerable:true&#125;,</div><div class="line">    title2:&#123;value:&apos;fe2&apos;,enumerable:true&#125;,</div><div class="line">    title3:&#123;value:&apos;fe3&apos;,enumerable:true,writable:true&#125;</div><div class="line">&#125;);</div><div class="line">Object.getOwnPropertyDescriptor(person,&apos;title3&apos;);</div><div class="line">//Object&#123;value:&apos;fe3&apos;,writable:true,enumerable:true,configurable:false&#125;</div><div class="line">Object.getOwnPropertyDescriptor(person,&apos;title1&apos;);</div><div class="line">//Object&#123;value:&apos;fe3&apos;,writable:false,enumerable:true,configurable:false&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对象标签，序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var toString=Object.prototype.toString;</div><div class="line">function getType(o)&#123;return toString.call(o).slice(8,-1)&#125;</div><div class="line">getType(true)</div><div class="line">//&quot;Boolean&quot;</div><div class="line">toString.call(null)</div><div class="line">//&quot;[object Null]&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>extensible扩展性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;x:1,y:2&#125;;</div><div class="line">Object.isExtensible(obj);//true</div><div class="line">Object.preventExtensions(obj);</div><div class="line">Object.isExtensible(obj);//false</div><div class="line">obj.z=1;</div><div class="line">obj.z;//undefined,add new property failed</div><div class="line">Object.getOwnPropertyDescriptor(obj,&apos;x&apos;);</div><div class="line">//Object&#123;value:1,writable:true,enumerable:true,configurable:true&#125;</div><div class="line">Object.seal(obj);</div><div class="line">Object.getOwnPropertyDescriptor(obj,&apos;x&apos;);</div><div class="line">//Object&#123;value:1,writable:true,enumerable:true,configurable:false&#125;</div><div class="line">Object.isSealed(obj);//true</div><div class="line">Object.freeze(obj);</div><div class="line">Object.getOwnPropertyDescriptor(obj,&apos;x&apos;);</div><div class="line">//Object&#123;value:1,writable:false,enumerable:true,configurable:false&#125;</div><div class="line">Object.isFrozen(obj);//true</div><div class="line">//caution :not affects prototype chain!!!</div></pre></td></tr></table></figure>
</li>
<li><p>序列化其他，其它对象方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//序列化JSON.stringify&amp;JSON.parse</div><div class="line">var obj=&#123;x:1,y:true,z:[1,2,3],nullVal:null&#125;;</div><div class="line">JSON.stringify(obj);//&quot;&#123;&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null&#125;&quot;</div><div class="line">obj=&#123;x:undefined,y:NaN,z:Infinity,nullVal:new Date()&#125;;</div><div class="line">JSON.stringify(obj);//&quot;&#123;&quot;y&quot;:null,&quot;z&quot;:null,&quot;nullVal&quot;:&quot;2017-02-07T23:10:33.107Z&quot;&#125;&quot;,注意undefined和NaN</div><div class="line">o=JSON.parse(&apos;&#123;&quot;x&quot;:&quot;1&quot;&#125;&apos;);</div><div class="line">o.x;//1</div><div class="line">//其它对象方法toString()&amp;valueOf()</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##数组</p>
<ul>
<li><p>创建与操作</p>
<blockquote>
<p>数组是值的有序集合，每个值叫做元素，每个元素在数组中都有数字位置<br>编号，即索引。js中数组是弱类型的，其中可以含有不同类型元素。</p>
<figure class="highlight plain"><figcaption><span>arr=[1,true,null,undefined,&#123;&#125;,[]]        ```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- 创建数组字面量：[]</div><div class="line">- new Array()</div><div class="line">- 元素读写</div><div class="line">```arr.length;arr[i];delete arr[j];//delete 操作不改变原数组</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>元素增删</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- 数组迭代</div><div class="line">```for-in for</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二维数组-稀疏数组"><a href="#二维数组-稀疏数组" class="headerlink" title="二维数组+稀疏数组"></a>二维数组+稀疏数组</h3><ul>
<li>稀疏数组：并不含有从0开始的连续索引，一般length属性值比实际元素个数多<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//&#123;&#125;=&gt;Object.prototype;[]=&gt;Array.prototype</div><div class="line">Array.prototype.join;</div><div class="line">Array.prototype.reverse;</div><div class="line">Array.prototype.sort;</div><div class="line">Array.prototype.concat;</div><div class="line">Array.prototype.slice;</div><div class="line">Array.prototype.splice;//左闭右开</div><div class="line">Array.prototype.forEach;//ES5</div><div class="line">Array.prototype.map;//ES5</div><div class="line">Array.prototype.map;//ES5</div><div class="line">Array.prototype.filter;//ES5</div><div class="line">Array.prototype.every;//ES5</div><div class="line">Array.prototype.some;//ES5</div><div class="line">Array.prototype.reduce/reduceRight;//ES5</div><div class="line">Array.prototype.indexOf/lastIndexOf;//ES5</div><div class="line">Array.isArray;//ES5；[] instanceof Array;[].constructor===Array;(&#123;&#125;).toString.apply([])===&apos;[object Array]&apos;</div><div class="line">var arr=[1,2,3];</div><div class="line">var sum=arr.reduce(function(x,y)&#123;return x+y&#125;,0);//6</div><div class="line">var max=arr.reduce(function(x,y)&#123;return x&gt;y?x:y&#125;);//3</div></pre></td></tr></table></figure>
</li>
</ul>
<p>###小结</p>
<ul>
<li>数组vs一般对象<br>同：都可以继承，数组是对象对象不一定是数组，数组拥有对象的一切属性和方法<br>异：数组自动更新length，按索引访问数组相对对象属性访问迅速。数组对象集成Array.prototype上的大量数组操作方法</li>
<li>字符串vs数组<br>字符串可以堪称类数组<figure class="highlight plain"><figcaption><span>str='hello';</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">str.charAt(0);//&apos;h&apos;</div><div class="line">str[1];//e</div><div class="line">Array.prptotype.join.call(str,&apos;_&apos;);//&apos;h_e_l_l_o&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数和作用域"><a href="#函数和作用域" class="headerlink" title="函数和作用域"></a>函数和作用域</h2><blockquote>
<p>一块js代码，定义一次但可以多次调用。js中函数也是对象</p>
<ul>
<li>函数=函数名+参数列表+函数体<br>返回值：<br>1.如果函数没有return语句或者return后边是基本类型=&gt;返回this</li>
</ul>
<ol>
<li>如果返回一个对象=&gt;返回以此对象作为构造器的一个实例<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3></li>
</ol>
<ul>
<li>this</li>
<li>arguments</li>
<li>作用域</li>
<li>调用：<ul>
<li>直接调用：foo()</li>
<li>对象方法：o.method()</li>
<li>构造器：new Foo()</li>
<li>call/apply/bind:foo.call</li>
</ul>
</li>
<li>创建<ul>
<li>函数声明：function a(){};会被前置</li>
<li>函数表达式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//function variable</div><div class="line">var a=function()&#123;&#125;</div><div class="line">//IEF(Immediately Executed Function)</div><div class="line">(function()&#123;&#125;)()</div><div class="line">//first-class function</div><div class="line">return function()&#123;&#125;</div><div class="line">//NFE(Named Function Expression)</div><div class="line">var a=function a()&#123;&#125;</div><div class="line">//FC(Function Constructor)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>函数声明</th>
<th>函数表达式</th>
<th>函数构造器</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>允许匿名</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>立即调用</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>在定义该函数的作用域通过函数名访问</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>没有函数名</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>全局的this(浏览器)</li>
<li><p>一般函数的this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function a()&#123;return this&#125;</div><div class="line"> a()===window;//true ,global,object</div><div class="line">//严格模式下：a()===undefined</div></pre></td></tr></table></figure>
</li>
<li><p>作为对象方法的this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var o=&#123;</div><div class="line">    prop:23,</div><div class="line">f:function()&#123;return this.prop&#125;</div><div class="line">&#125;</div><div class="line">o.f();//23</div><div class="line">function g()&#123;return this.prop&#125;</div><div class="line">o.f=g;</div><div class="line">o.f();//23</div></pre></td></tr></table></figure>
</li>
<li><p>对象原型链上的this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o=&#123;</div><div class="line">f:function()&#123;return this.a+this.b&#125;</div><div class="line">&#125;</div><div class="line">var p=Object.create(o);</div><div class="line">p.a=1;p.b=2;</div><div class="line">p.f();//3</div></pre></td></tr></table></figure>
</li>
<li><p>get/set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function modulus()&#123;</div><div class="line">return Math.sqrt(this.re*this.re+this.im*this.im)</div><div class="line">&#125;</div><div class="line">var o=&#123;</div><div class="line">re:1,im:-1,</div><div class="line">get phase()&#123;</div><div class="line">return Math.atan2(this.im,this.re)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Object.defineProperty(o,&apos;modulus&apos;,&#123;</div><div class="line">    get:modulus,emumerable:true,configurable:true</div><div class="line">&#125;)</div><div class="line">console.log(o.phase,o.modulus);//-.78,1.142</div></pre></td></tr></table></figure>
</li>
<li><p>构造器中的this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function MyClass()&#123;this.a=22&#125;</div><div class="line">var o=new MyClass();</div><div class="line">o.a;//22</div><div class="line">function C2()&#123;this.a=23;return &#123;a:38&#125;&#125;</div><div class="line">o=new C2()</div><div class="line">o.a;//23</div></pre></td></tr></table></figure>
</li>
<li><p>call/apply方法与this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function add(a,b)&#123;return this.a+this.b+c+d&#125;</div><div class="line">var o=&#123;a:1,b:3&#125;</div><div class="line">add.call(o,5,7);//1+3+5+7=16</div><div class="line">add.apply(o,[10,20]);//1+3+10+20=34</div><div class="line">function bar()&#123;</div><div class="line">console.log(Object.prototype.toString.call(this))</div><div class="line">&#125;</div><div class="line">bar.call(7);//&quot;[object Number]&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>bind方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function f()&#123;return this.a&#125;</div><div class="line">var g=f.bind(&#123;a:&quot;test&quot;&#125;)</div><div class="line">g();//test</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><ul>
<li><p>arguments属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(x,y,z)&#123;</div><div class="line">&apos;use strict&apos;;</div><div class="line">arguments.length;//2</div><div class="line">arguments[0];//1</div><div class="line">arguments[0]=20;</div><div class="line">x;//changed to 20,严格模式下仍是1</div><div class="line">arguments[2]=100;</div><div class="line">z;//still undefined !!! 未传参数失去绑定关系</div><div class="line">arguments.callee===foo;//true,严格模式下不可用</div><div class="line">&#125;</div><div class="line">foo(1,2);//foo.name=&gt;函数名</div><div class="line">foo.length;//3 ，foo.length=&gt;形参个数,arguments.length=&gt;实参个数</div></pre></td></tr></table></figure>
</li>
<li><p>call/apply方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(x,y)&#123;console.log(x,y,this)&#125;</div><div class="line">foo.call(100,1,2);//1,2,Number(100)</div><div class="line">foo.apply(true,[3,4]);//3,4,Boolean(true)</div><div class="line">foo.apply(null);//undefined,undefined,window(严格模式下null)</div><div class="line">foo.apply(undefined);//undefined,undefined,window（严格模式下undefined）</div></pre></td></tr></table></figure>
</li>
<li><p>bind方法（IE9以上）</p>
</li>
<li><p>bind与currying（把整个函数拆成多个单元）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(a,b,c)&#123;return a+b+c&#125;</div><div class="line">var func=add.bind(undefined,100);</div><div class="line">func(1,2);//103</div><div class="line">var func2=func.bind(undefined,200)</div><div class="line">func2(10);//310</div></pre></td></tr></table></figure>
</li>
<li><p>bind与new</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;this.b=100;return this.a&#125;</div><div class="line">var func=foo.bind(&#123;a:1&#125;)</div><div class="line">func();//1</div><div class="line">new func();//&#123;b:100&#125;，bind被忽略？？？</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="闭包作用域"><a href="#闭包作用域" class="headerlink" title="闭包作用域"></a>闭包作用域</h2><ul>
<li><p>闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function outer()&#123;</div><div class="line">    var localVal=30;</div><div class="line">    return function()&#123;</div><div class="line">        return localVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var func=outer();</div><div class="line">func();//30</div></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(function ()&#123;</div><div class="line">    var _userId=123;</div><div class="line">    var _typeId=&quot;Item&quot;;</div><div class="line">    var export=&#123;&#125;;</div><div class="line">    function converter(userId)&#123;</div><div class="line">        return +userId;</div><div class="line">&#125;</div><div class="line">export.getUserId=function()&#123;</div><div class="line">    return converter(_userId);</div><div class="line">&#125;</div><div class="line">export.getTypeId=function()&#123;</div><div class="line">return _typedId;</div><div class="line">&#125;</div><div class="line">window.export=export;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>好处：灵活方便，封装；坏处：空间浪费，内存泄漏，性能消耗</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>类型<ul>
<li>全局</li>
<li>函数</li>
<li>eval</li>
</ul>
</li>
<li>作用于链<h3 id="ES3的执行上下文（EC）"><a href="#ES3的执行上下文（EC）" class="headerlink" title="ES3的执行上下文（EC）"></a>ES3的执行上下文（EC）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function funcEC1()&#123;</div><div class="line">console.log(&apos;EC1&apos;);</div><div class="line">    var funcEC2=function ()&#123;</div><div class="line">        console.log(&apos;EC2&apos;);</div><div class="line">        var funcEC3=function()&#123;</div><div class="line">            console.log(&apos;EC3&apos;);</div><div class="line">        &#125;;</div><div class="line">        funcEC3();</div><div class="line">&#125;;</div><div class="line">    funcEC2();</div><div class="line">&#125;;</div><div class="line">funcEC1();</div><div class="line">//EC0 EC1 EC2 EC3</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>概念：变量对象（Variable Object）,一个抽象概念中的对象，用于存储执行上下文中的变量，函数声明，函数参数。</li>
<li><p>EC与VO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext=&#123;</div><div class="line">    VO:&#123;</div><div class="line">    data_var,data_func_declaration,data_func_arguments</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">GlobalContextVO   VO===this===global</div><div class="line">//demo</div><div class="line">var a=10;</div><div class="line">function test(x)&#123;</div><div class="line">    var b=20;</div><div class="line">&#125;</div><div class="line">test(30);</div><div class="line">//=&gt;</div><div class="line">VO(gC)=&#123;</div><div class="line">    a:10,</div><div class="line">    test:&lt;ref to function&gt;</div><div class="line">&#125;</div><div class="line">VO(test functionContext)=&#123;</div><div class="line">    x:30,b:20</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>全局执行上下文GEC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">VO(globalContext)===[[global]];</div><div class="line">[[global]]=&#123;</div><div class="line">    Math:&lt;...&gt;,</div><div class="line">    String:&lt;&gt;,</div><div class="line">    isNaN:function ()&#123;Native Code&#125;,</div><div class="line">    ...</div><div class="line">    window:global//applied by browser(host)</div><div class="line">&#125;;</div><div class="line">GlobalContextVO  (VO===this===global)</div><div class="line">String(10);//[[global]].String(10);</div><div class="line">window.a=10;//[[global]].window.a=10</div><div class="line">this.b=20;//[[global]].b=20</div></pre></td></tr></table></figure>
</li>
<li><p>函数中的激活对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">VO(functionContext)===AO;</div><div class="line">AO=&#123;</div><div class="line">    arguments:&lt;Arg0&gt;//函数调用时生成</div><div class="line">&#125;;</div><div class="line">arguments=&#123;</div><div class="line">    callee,length,properties-indexes</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>变量初始化阶段</p>
<blockquote>
<p>VO填充顺序：</p>
</blockquote>
</li>
</ul>
<ol>
<li>函数参数（arguments=arguments||undefined）;<br>2.函数声明（命名冲突则覆盖,函数表达式不影响VO）；<br>3.变量声明（初始化为undefined，命名冲突则忽略）<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function test(a,b)&#123;</div><div class="line">var c=10;</div><div class="line">function d()&#123;&#125;</div><div class="line">var e=function _e()&#123;&#125;;</div><div class="line">(function x()&#123;&#125;)();</div><div class="line">b=20;</div><div class="line">&#125;</div><div class="line">test(10);</div><div class="line">//AO</div><div class="line">AO(test)=&#123;</div><div class="line">a:10,b:undefined,c:undefined,d:&lt;ref to func &apos;d&apos;&gt;,e:undefined</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<p>###demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function test(a,b)&#123;</div><div class="line">var c=10;</div><div class="line">function d()&#123;&#125;</div><div class="line">var e=function _e()&#123;&#125;;</div><div class="line">(function x()&#123;&#125;)</div><div class="line">b=30;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>变量初始化阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">test(10);</div><div class="line">AO(test)=&#123;</div><div class="line">a:10,b:undefined,</div><div class="line">c:undefined,</div><div class="line">d:&lt;ref to func &apos;d&apos;&gt;</div><div class="line">e:undefined</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码执行阶段</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AO(test)=&#123;</div><div class="line">a:10,b:20,</div><div class="line">c:10,</div><div class="line">d:&lt;ref to FunctionDeclaration &apos;d&apos;&gt;</div><div class="line">e:function _e&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert(x);</div><div class="line">var x=10;</div><div class="line">alert(x);x=20;</div><div class="line">function x()&#123;&#125;</div><div class="line">alert(x);</div><div class="line">if(true)&#123;var a=1&#125;else&#123;var b=true&#125;</div><div class="line">alert(a);alert(b)</div><div class="line">//function x()&#123;&#125; 10 20 1 undefined</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="OOP（封装-继承-多态-抽象）"><a href="#OOP（封装-继承-多态-抽象）" class="headerlink" title="OOP（封装+继承+多态+抽象）"></a>OOP（封装+继承+多态+抽象）</h2><blockquote>
<p>OOP:一种程序设计范型，同时也是一种程序开发方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性，灵活性和扩展性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Person(name,age)&#123;this.name=name;this.age=age;&#125;</div><div class="line"></div><div class="line">Person.prototype.hi=function()&#123;console.log(&apos;Hi Iam&apos;+this.name+&apos;I am&apos;+this.age+&apos;years old now&apos;)&#125;</div><div class="line"></div><div class="line">Person.prototype.LEGS_NUM=2;</div><div class="line">Person.prototype.ARMS_NUM=2;</div><div class="line">Person.prototype.walk=function()&#123;console.log(this.nama+&apos;is walking&apos;)&#125;</div><div class="line">function Student(name,age,className&#123;Person.call(this,name,age);this.className=className&#125;</div><div class="line"></div><div class="line">Student.prototype=Object.create(Person.prototype);//</div><div class="line">Student.prototype.constructor=Student;</div><div class="line">Student.prototype.hi=function ()&#123;</div><div class="line">    console.log(&quot;Hi&quot;+this.name+&apos;,I am&apos;+this.age+&apos;years old ,and from&apos;+this.className+&apos;.&apos;)</div><div class="line">&#125;</div><div class="line">Student.prototype.learn=function(subject)&#123;console.log(&apos;my major is&apos;+subject)&#125;</div><div class="line">//test</div><div class="line">var tom=new Student(&apos;Tom&apos;,22,&apos;Class 3&apos;);</div><div class="line">tom.hi();</div><div class="line">tom.LEGS_NUM;</div><div class="line">tom.walk();</div><div class="line">tom.learn();</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="http://img.mukewang.com/589babcb0001243408190462.jpg" alt="再谈原型链"></p>
<h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Student.prototype.x=101;</div><div class="line">tom.x;//101</div><div class="line"></div><div class="line">Student.prototype=&#123;y:3&#125;;</div><div class="line">tom.y;//undefined</div><div class="line">tom.x;//101</div><div class="line"></div><div class="line">var jack=new Student(&apos;Jack&apos;,22,&apos;Class 1&apos;);</div><div class="line">jack.x;//undefined</div><div class="line">jack.y;//2</div></pre></td></tr></table></figure>
<p>-Thus:<br>1.动态修改prototype对象的属性, 会影响创建及已创建的实例</p>
<ol>
<li>修改整个prototype对象，只影响后续创建的实例</li>
</ol>
<ul>
<li>内置构造器的prototype<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x=1;</div><div class="line">var obj=&#123;&#125;;</div><div class="line">obj.x;//1</div><div class="line">for(var key in obj)&#123;console.log(key)&#125;//x</div><div class="line">//ES5</div><div class="line">Object.defineProperty(Object.prototype,&#123;</div><div class="line">writable:true,value:1</div><div class="line">&#125;)</div><div class="line">var obj=&#123;&#125;;</div><div class="line">obj.x;//1</div><div class="line">for(var key in obj)&#123;console.log(key)&#125;//nothing</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现继承的方式"><a href="#实现继承的方式" class="headerlink" title="实现继承的方式"></a>实现继承的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">function Student()&#123;&#125;</div><div class="line">Student.prototype=Person.prototype;//1 bad</div><div class="line">Student.prototype=new Person;//2===4</div><div class="line">Student.prototype=Object.create(Person.prototype);//3,ES5</div><div class="line">//check</div><div class="line">if(!Object.create)&#123;</div><div class="line">    Object.create=function(proto)&#123;</div><div class="line">    function F()&#123;&#125;</div><div class="line">    F.prototype=proto;</div><div class="line">    return new F;</div><div class="line">&#125;    </div><div class="line">&#125;</div><div class="line">Student.prototype.constructor=Person;//4</div></pre></td></tr></table></figure>
<h3 id="模拟重载，链式调用，模块化"><a href="#模拟重载，链式调用，模块化" class="headerlink" title="模拟重载，链式调用，模块化"></a>模拟重载，链式调用，模块化</h3><ul>
<li><p>模拟重载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">    var args=arguments;</div><div class="line">    if(typeof args[0]===&apos;object&apos;&amp;&amp;args[0])&#123;</div><div class="line">        if(args[0].name)&#123;</div><div class="line">            this.name=args[0].name        </div><div class="line">        &#125;</div><div class="line">         if(args[0].age)&#123;</div><div class="line">            this.age=args[0].age        </div><div class="line">        &#125;else&#123;</div><div class="line">            if(args[0])&#123;</div><div class="line">                this.name=args[0]</div><div class="line">            &#125;</div><div class="line">            if(args[1])&#123;</div><div class="line">                this.age=args[1]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Person.prototype.toString=function()&#123;</div><div class="line">    return &apos;name=&apos;+this.name+&apos;,age&apos;+this.age;</div><div class="line">&#125;</div><div class="line">var tom=new Person(&apos;tom&apos;,28);</div><div class="line">var jack=new Person(&#123;name:&apos;Jack&apos;,age:23&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>调用子类的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;this.name=name;&#125;</div><div class="line">function Student(name,className)&#123;this.className=className;Person.call(this,name);&#125;</div><div class="line">var tom=new Student(&apos;tom&apos;,&apos;NT&apos;);</div><div class="line"></div><div class="line">Person.prototype.init=function()&#123;&#125;；</div><div class="line">Student.prototypt.init=function()&#123;Person.prototype.init.apply(this,arguments)&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>链式调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function ClassManager()&#123;</div><div class="line">    ClassManager.prototype.addClass=function(str)&#123;</div><div class="line">        console.log(&apos;Class&apos;+str+&apos;added&apos;);</div><div class="line">        return this;//实现链式调用</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var manager=new ClassManager();</div><div class="line">manager.addClass(&apos;classA&apos;).addClass(&apos;classB&apos;).addClass(&apos;classC&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function DetectorBase()&#123;</div><div class="line">    throw new Error(&apos;Abstract class can not be invoked directly!&apos;)</div><div class="line">&#125;</div><div class="line">DetectorBase.detect=function()&#123;console.log(&apos;Detector starting...&apos;)&#125;;</div><div class="line">DetectorBase.stop=function()&#123;console.log(&apos;Detector stopped.&apos;)&#125;;</div><div class="line">DetectorBase.init=function()&#123;throw new Error(&apos;Error&apos;)&#125;;</div><div class="line"></div><div class="line">function LinkDetector()&#123;&#125;</div><div class="line">LinkDetector.prototype=Object.create(Detector.prototype);</div><div class="line">LinkDetector.prototype.constructor=LinkDetector;</div><div class="line">//...add methods to LinkDetector...</div></pre></td></tr></table></figure>
</li>
<li><p>defineProperty(ES5)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">    Obect.defineProperty(this,&apos;name&apos;,&#123;value:name,enumerable:true&#125;);</div><div class="line">&#125;</div><div class="line">Object.defineProperty(Person,&quot;ARMS_NUM&quot;,&#123;value:2,enumerable:true&#125;);</div><div class="line">Object.seal(Person.prototype);</div><div class="line">Object.seal(Person);</div><div class="line">function Student(name,className)&#123;</div><div class="line">    this.className=className;</div><div class="line">Person.call(this,name)</div><div class="line">&#125;</div><div class="line">Student.prototype=Object.create(Person.prototype);</div><div class="line">Student.prototype.constructor=Student;</div></pre></td></tr></table></figure>
</li>
<li><p>模块化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var moduleA;</div><div class="line">moduleA=function()&#123;</div><div class="line">    var prop=1;</div><div class="line">    function func()&#123;</div><div class="line">        return&#123;</div><div class="line">        func:func,</div><div class="line">        prop:prop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var moduleA;</div><div class="line">moduleA=new function()&#123;</div><div class="line">    var prop=1;</div><div class="line">    function func()&#123;&#125;</div><div class="line">    this.func=func;</div><div class="line">    this.prop=prop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实践（探测器）<br>```<br>!function(global){<br>  function DetectorBase(configs){</p>
<pre><code>if(!this instanceof DetectorBase){
    throw new Error(&apos;Do not invoke without new&apos;)
}
this.configs=configs;
this.analyze();
</code></pre><p>  }<br>  DetectorBase.prototype.detect=function(){</p>
<pre><code>throw new Error(&apos;Not implemented&apos;)
</code></pre><p>  }<br>  DetectorBase.prototype.analyze=function(){<br>  console.log(‘analyzing…’);<br>  this.data=’###data###’;<br>  }<br>}<br>function LinkDetector(links){<br>  if(!this instanceof LinkDetector){</p>
<pre><code>throw new Error(&apos;Do not invoke without new&apos;);
</code></pre><p>  }<br>  this.links=links;<br>  DetectorBase.aply(this,arguments);<br>}<br>function ContainerDetector(containers){<br>  if(!this instanceof ContainerDetector){</p>
<pre><code>throw new Error(&apos;Do not invoke without new&apos;)
</code></pre><p>  }<br>  this.containers=containers;<br>  DetectorBase.apply(this,arguments);<br>}<br>//inherit first<br>inherit(LinkDetector,DetectorBase);<br>inherit(ContainerDetector,DetectorBase);<br>//</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[How browsers work?]]></title>
      <url>https://yanlee26.github.io/2015/07/02/browsers_work/</url>
      <content type="html"><![CDATA[<h1 id="标准浏览器的幕后"><a href="#标准浏览器的幕后" class="headerlink" title="标准浏览器的幕后"></a>标准浏览器的幕后</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>所谓的浏览器<h3 id="主流浏览器：IE-FF-Safari-Chrome-Opera"><a href="#主流浏览器：IE-FF-Safari-Chrome-Opera" class="headerlink" title="主流浏览器：IE,FF,Safari,Chrome,Opera"></a>主流浏览器：IE,FF,Safari,Chrome,Opera</h3></li>
</ul>
<ul>
<li>部分开源的有FF,Chrome,Safari，W3C统计这三大浏览器占领市场的6成份额。</li>
</ul>
<ul>
<li>浏览器主要功能特性<blockquote>
<p>The browser main functionality is to present the web resource you choose, by requesting it from the server and displaying it on the browser window. </p>
</blockquote>
</li>
</ul>
<ul>
<li>浏览器的主要功能是呈现你所选择的资源，通过向服务端请求并展示在浏览器窗口。</li>
<li>浏览器用户交互有很多类似之处，其中便是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Address bar for inserting the URI---url地址栏</div><div class="line">Back and forward buttons---前进后退按钮</div><div class="line">Bookmarking options---书签选择</div><div class="line">A refresh and stop buttons for refreshing and stopping the loading of current documents---刷新和停止刷新和阻止加载当前文档</div><div class="line">Home button that gets you to your home page---主页</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Strangely enough, the browser’s user interface is not specified in any formal specification, it is just good practices shaped over years of experience and by browsers imitating each other(浏览器用户界面并非以任何标准区分而区分，而是多年的应用习惯塑造了了其不谋而合的特性). The HTML5 specification doesn’t define UI elements a browser must have, but lists some common elements. Among those are the address bar, status bar and tool bar. There are, of course, features unique to a specific browser like Firefox downloads manager.<br>More on that in the user interface chapter.</p>
<ul>
<li>浏览器高水平结构<h3 id="主要组件如下"><a href="#主要组件如下" class="headerlink" title="主要组件如下"></a>主要组件如下</h3></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.The user interface （UI界面）- this includes the address bar, back/forward button, bookmarking menu etc. Every part of the browser display except the main window where you see the requested page.</div><div class="line">2.The browser engine（引擎） - the interface for querying and manipulating the rendering engine.</div><div class="line">3. The rendering engine（渲染引擎） - responsible for displaying the requested content. For example if the requested content is HTML, it is responsible for parsing the HTML and CSS and displaying the parsed content on the screen.</div><div class="line">4. Networking（网络） - used for network calls, like HTTP requests. It has platform independent interface and underneath implementations for each platform.</div><div class="line">5. UI backend（UI后端） - used for drawing basic widgets like combo boxes and windows. It exposes a generic interface that is not platform specific. Underneath it uses the operating system user interface methods.</div><div class="line">6. JavaScript interpreter（JS解释器）. Used to parse and execute the JavaScript code.</div><div class="line">7.Data storage（数据存储）. This is a persistence layer. The browser needs to save all sorts of data on the hard disk, for examples, cookies. The new HTML specification (HTML5) defines &apos;web database&apos; which is a complete (although light) database in the browser.</div></pre></td></tr></table></figure>
<p><img src="http://img.mukewang.com/582dba090001a25806270387.png" alt="browser 主要组件"><br>*请注意，Chrome与大多数浏览器不同，它拥有多个呈现引擎实例，每个标签一个。 每个选项卡是一个单独的过程。</p>
<ul>
<li>组件通信</li>
</ul>
<ul>
<li>FF和Chrome都有专门的通信结构，下边讨论。<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><blockquote>
<p>The responsibility of the rendering engine is well… Rendering, that is display of the requested contents on the browser screen.</p>
</blockquote>
</li>
<li>渲染即在浏览器上显示请求的内容<br>By default the rendering engine can display HTML and XML documents and images. It can display other types through a plug-in (a browser extension). An example is displaying PDF using a PDF viewer plug-in. We will talk about plug-ins and extensions in a special chapter. In this chapter we will focus on the main use case - displaying HTML and images that are formatted using CSS.</li>
</ul>
<ol>
<li>渲染引擎—Rendering engines<blockquote>
<p>Our reference browsers - Firefox, Chrome and Safari are built upon two rendering engines. Firefox uses Gecko - a “home made” Mozilla rendering engine. Both Safari and Chrome use Webkit.</p>
</blockquote>
</li>
</ol>
<ul>
<li>FF,Chrome,Safari 建立在两个引擎之上。FF运用Gecko内核—一个家装的Mozilla渲染引擎。Safari和Chorme用的是Webkit内核。<br>Webkit is an open source rendering engine which started as an engine for the Linux platform and was modified by Apple to support Mac and Windows. See <a href="http://webkit.org/" target="_blank" rel="external">http://webkit.org/</a> for more details.</li>
<li>Webkit是一个开源渲染引擎，起初在linux平台作引擎并被Apple改造应用到Mac和window系统。</li>
</ul>
<ol>
<li>主流（main flow）<blockquote>
<p>The rendering engine will start getting the contents of the requested document from the networking layer. This will usually be done in 8K chunks.</p>
</blockquote>
</li>
</ol>
<ul>
<li>渲染引擎从网络层获取文档内容，这通常在8k快完成。<img src="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" alt=""></li>
<li>渲染引擎将以解析html文档和转换标签到所谓的文档树—DOM节点上开始。它将解析样式数据，包含内敛样式和外联样式。这些样式信息以及可视化的指令将用于创建另一个树–渲染树。</li>
<li>渲染树包含具有视觉属性（visual attributes如颜色和尺寸）的矩形。 矩形以正确的顺序显示在屏幕上。<br>在渲染树的构造之后，它经过<strong>“布局(layout)”</strong>过程。 这意味着给每个节点在其应该出现在屏幕上的确切坐标。 下一个阶段是<strong>绘画(pianting)</strong> - 渲染树将被遍历，每个节点将使用UI后端图层绘制。<br>重要的是要了解这是一个<strong>渐进(gtadual process)</strong>的过程。 为了获得更好的用户体验，渲染引擎将尽快尝试在屏幕上显示内容。 它不会等到所有的HTML被解析之后才开始构建和布局渲染树。 内容的一部分将被解析和显示，同时该过程继续保持来自网络的其余内容。</li>
</ul>
<ol>
<li>主流示例, 解析和DOM树结构<br><img src="http://img.mukewang.com/582dbd3e0001335605000393.png" alt="Webkit main flow"><br><img src="http://img.mukewang.com/582dbfd100014e8107310396.png" alt="Mozilla&#39;s Gecko rendering engine main flow"><blockquote>
<p>Although Webkit and Gecko use slightly different terminology, the flow is basically the same.<br>a.一般解析</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<p>Since parsing is a very significant(重要，有意义) process within the rendering engine, we will go into it a little more deeply. Let’s begin with a little introduction about parsing.<br>Parsing a document means translating it to some structure that makes sense（转换成有意义的结构） - something the code can understand and use. The result of parsing is usually a tree of nodes that represent the structure of the document（解析的结果通常是表示文档结构的节点树）. It is called a parse tree or a syntax tree（解析树||语法树）.</p>
</blockquote>
</li>
</ul>
<ul>
<li>Parsing is based on the syntax rules the document obeys - the language or format it was written in. Every format you can parse must have deterministic（确定性） grammar consisting of vocabulary and syntax rules. It is called a context free grammar. Human languages are not such languages and therefore cannot be parsed with conventional parsing techniques.</li>
</ul>
<ul>
<li>Parser +Lexer combination组合<blockquote>
<p>arsing can be separated into two sub processes - lexical analysis and syntax analysis.<br>Lexical analysis is the process of breaking the input into tokens(词法分析是将输入分解成符记的过程). Tokens are the language vocabulary - the collection of valid building blocks. In human language it will consist of all the words that appear in the dictionary for that language.<br>Syntax analysis is the applying of the language syntax rules（语法分析就是语言语法规则的运用）.<br>Parsers usually divide the work between two components - the lexer(sometimes called tokenizer) that is responsible for breaking the input into valid tokens, and the parser that is responsible for constructing the parse tree by analyzing the document structure according to the language syntax rules. The lexer knows how to strip irrelevant characters like white spaces and line breaks.<br><img src="http://img.mukewang.com/582e362c0001b3a506400407.png" alt="from source document to parse trees"></p>
</blockquote>
</li>
</ul>
<ul>
<li>The parsing process is iterative. The parser will usually ask the lexer for a new token and try to match the token with one of the syntax rules. If a rule is matched, a node corresponding to the token will be added to the parse tree and the parser will ask for another token.<br>If no rule matches, the parser will store the token internally, and keep asking for tokens until a rule matching all the internally stored tokens is found. If no rule is found then the parser will raise an exception. This means the document was not valid and contained syntax errors.</li>
</ul>
<ul>
<li>Translation改变<blockquote>
<p>Many times the parse tree is not the final product. Parsing is often used in translation - transforming the input document to another format. An example is compilation. The compiler that compiles a source code into machine code first parses it into a parse tree and then translates the tree into a machine code document.<br><img src="http://img.mukewang.com/582e3a850001ce7405000294.png" alt="compilation flow"></p>
</blockquote>
</li>
<li><p>解析示例</p>
</li>
<li><p>Formal definitions for vocabulary and syntax词法标准定义<br>Vocabulary is usually expressed by <a href="http://www.regular-expressions.info/" target="_blank" rel="external">regular expressions</a>.<br>We said that a language can be parsed by regular parsers if its grammar is a context frees grammar. An intuitive definition of a context free grammar is a grammar that can be entirely expressed in BNF. For a formal definition see <a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="external">http://en.wikipedia.org/wiki/Context-free_grammar</a></p>
</li>
<li>Types of parsers解析器类型<br>There are two basic types of parsers - top down parsers(自上而下) and bottom up parsers（自下而上）.</li>
<li>Generating parsers automatically—自动生成解析器<blockquote>
<p>There are tools that can generate a parser for you. They are called parser generators(解析生成器). You feed them with the grammar of your language - its vocabulary and syntax rules and they generate a working parser. Creating a parser requires a deep understanding of parsing and its not easy to create an optimized parser by hand, so parser generators can be very useful.<br>Webkit uses two well known parser generators - <strong><em>Flex</em></strong> for creating a lexer and <strong><em>Bison</em></strong> for creating a parser (you might run into them with the names Lex and Yacc). Flex input is a file containing regular expression definitions of the tokens. Bison’s input is the language syntax rules in BNF format.<br>b. HTML Parser—html解析： to parse the HTML markup into a parse tree.</p>
</blockquote>
</li>
<li>html语法定义<blockquote>
<p>The vocabulary and syntax of HTML are defined in <a href="http://img.mukewang.com/582e3aaa00017cbb04000305.png" target="_blank" rel="external">specifications</a>created by the w3c organization. The current version is HTML4 and work on HTML5 is in progress.</p>
</blockquote>
</li>
<li>非自由上下文（context free）语法<blockquote>
<p>As we have seen in the parsing introduction, grammar syntax can be defined formally using formats like BNF.<br>Unfortunately all the conventional parser topics do not apply to HTML (I didn’t bring them up just for fun - they will be used in parsing CSS and JavaScript). HTML cannot easily be defined by a context free grammar that parsers need.<br>There is a formal format for defining HTML -<strong><em> DTD</em></strong> (Document Type Definition) - but it is not a context free grammar.<br>This appears strange at first site - HTML is rather close to XML .There are lots of available XML parsers. There is an XML variation of HTML - XHTML - so what’s the big difference?<br>The difference is that HTML approach is more <strong><em>“forgiving”</em></strong>, it lets you omit certain tags which are added implicitly, sometimes omit the start or end of tags etc. On the whole it’s a “soft” syntax, as opposed to XML’s stiff and demanding syntax.<br>Apparently this seemingly small difference makes a world of a difference. On one hand this is the main reason why HTML is so popular - it forgives your mistakes and makes life easy for the web author. On the other hand, it makes it difficult to write a format grammar. So to summarize - HTML cannot be parsed easily, not by conventional parsers since its grammar is not a context free grammar, and not by XML parsers(html不能由常规解析器轻易解析，因为它的语法不是上下文自由的语法，不能由XML解析器（解析）).</p>
</blockquote>
</li>
<li>HTML DTD<blockquote>
<p>DTD有一些变体。 严格模式仅符合规范，但其他模式包含对浏览器过去使用的标记的支持。 目的是向后兼容旧内容。 当前严格的DTD在这里：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd</a></p>
</blockquote>
</li>
<li>DOM<br>The output tree（输出树） - the parse tree is a tree of DOM element （元素DOM）and attribute nodes（节点属性）. It is the object presentation of the HTML document and the interface of HTML elements to the outside world like JavaScript（是一个代表HTML文档和HTML元素对外部世界如JS提供接口的对象）. <blockquote>
<p>When I say the tree contains DOM nodes, I mean the tree is constructed of elements that implement one of the DOM interfaces(包含DOM节点的树，便是由实现接口之一的元素们构成的树). Browsers use concrete implementations that have other attributes used by the browser internally.</p>
</blockquote>
</li>
<li>The parsing algorithm—解析算法<br>htnl不能被自上而下的解析规则解析，原因是：</li>
</ul>
<ol>
<li>语言的原谅本质</li>
<li>浏览器含有传统的容错机制去支持广为人知的无效html的事实</li>
<li>解析进程可重入。通常来源在解析期间不会更改，但在html中，包含‘document.write’的脚本标记可以添加额外的标记，因此解析过程实际上会修改输入。<br>无法用正规解析技术，浏览器为html创造了自定义解析器。<br><img src="http://img.mukewang.com/582e3edc00011ece03260341.png" alt="HTML parsing flow"></li>
</ol>
<ul>
<li>The tokenization algorithm—标记化算法<blockquote>
<p>The algorithm’s output is an HTML token. 算法输出就是一个HTML符记。<br>The algorithm is expressed as a <strong><em>state machine（状态机）</em></strong>. Each state consumes one or more characters of the input stream and updates the next state according to those characters. The decision is influenced by the current tokenization state and by the tree construction state. This means the same consumed character will yield different results for the correct next state, depending on the current state. The algorithm is too complex to bring fully, so let’s see a simple example that will help us understand the principal.<img src="http://img.mukewang.com/582dba090001a25806270387.png" alt="Tokening the example input"></p>
</blockquote>
</li>
<li>构建树算法<blockquote>
<p>When the parser is created the Document object is created.解析器被构建则文档对象被构建。</p>
</blockquote>
</li>
<li>解析结束后行为<blockquote>
<p>At this stage the browser will mark the document as interactive and start parsing scripts that are in “deferred” mode - those who should be executed after the document is parsed. The document state will be then set to “complete” and a “load” event will be fired.<br><em>此阶段，浏览器将文档标记为交互式并解析出于延迟模式的脚本—解析文档之后执行的脚本。而后，文档状态将设置为完成，并触发加载事件</em></p>
</blockquote>
</li>
<li>浏览器容错<br><em>你从未获取到‘Invalid Syntax</em>错误在html页面，浏览器修理无效内容并继续。<br>c. CSS解析<blockquote>
<p>the CSS specification defines CSS lexical and syntax grammar .CSS的特点决定了CSS lexical 和语法</p>
</blockquote>
</li>
<li>webkit CSS 解析器<blockquote>
<p>Webkit uses <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" target="_blank" rel="external">Flex and Bison</a> parser generators to create parsers automatically from the CSS grammar files. <img src="http://img.mukewang.com/582dbd3e0001335605000393.png" alt="parsing CSS"><br>d. 脚本解析<br>见js部分<br>e.脚本及样式处理规则</p>
</blockquote>
</li>
<li>脚本<blockquote>
<p>The model of the web is synchronous(异步的). Authors expect scripts to be parsed and executed immediately when the parser reaches a <script> tag. The parsing of the document halts until the script was executed. If the script is external then the resource must be first fetched from the network - this is also done synchronously, the parsing halts until the resource is fetched. This was the model for many years and is also specified in HTML 4 and 5 specifications. Authors could mark the script as “defer” and thus it will not halt the document parsing and will execute after it is parsed. HTML5 adds an option to mark the script as asynchronous so it will be parsed and executed by a different thread.</p>
</blockquote>
</li>
<li>Speculative parsing—推测解析<blockquote>
<p>Both Webkit and Firefox do this optimization. While executing scripts, another thread parses the rest of the document and finds out what other resources need to be loaded from the network and loads them. These way resources can be loaded on parallel connections and the overall speed is better. Note - the speculative parser doesn’t modify the DOM tree and leaves that to the main parser, it only parses references to external resources like external scripts, style sheets and images.<br><em>Webkit和Firefox都会进行这种优化。 在执行脚本时，另一个线程解析文档的其余部分，并找出需要从网络加载的其他资源并加载它们。 这些方式资源可以并行连接加载，整体速度更好。 注意 - 推测解析器不修改DOM树并将其留给主解析器，它只解析对外部资源的引用，如外部脚本，样式表和图像。</em></p>
</blockquote>
</li>
<li>样式<blockquote>
<p>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don’t change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. Webkit blocks scripts only when they try to access for certain style properties that may be effected by unloaded style sheets.(当存在仍在加载和解析的样式表时，FF会阻止所有脚本；Webkit只在用户视图访问某些可能被卸载的样式表影响的样式属性时阻止脚本)</p>
</blockquote>
</li>
</ul>
<ol>
<li>Render tree—渲染树 构建<br>While the DOM tree is being constructed, the browser constructs another tree, the render tree. This tree is of visual elements in the order in which they will be displayed. <blockquote>
<p>Firefox calls the elements in the render tree “frames”. Webkit uses the term renderer or render object. </p>
</blockquote>
</li>
</ol>
<ul>
<li>渲染树相对于DOM树<br>The renderers correspond to the DOM elements, but the relation is not one to one(渲染器与DOM元素对应，但不是一一对应). Non visual DOM elements will not be inserted in the render tree. An example is the “head” element. Also elements whose display attribute was assigned to “none” will not appear in the tree (elements with “hidden” visibility attribute will appear in the tree).<img src="http://img.mukewang.com/582dbfd100014e8107310396.png" alt="The render tree and the corresponding DOM tree"></li>
<li>渲染树构建流<br>In Firefox, the presentation is registered as a listener for DOM updates. The presentation delegates frame creation to the “FrameConstructor” and the constructor resolves style(see style computation) and creates a frame.<br>In Webkit the process of resolving the style and creating a renderer is called “attachment”. Every DOM node has an “attach” method. Attachment is synchronous, node insertion to the DOM tree calls the new node “attach” method.<br>火狐的呈现被设置为DOM更新的监听，此呈现代理了frameConstructorframe对frame的构建且此构建解决了样式并创造了frame；Webkit中的解决样式和构建render的过程被称为粘贴，每个DOM节点都有一个粘贴的方法。<br>Processing the html and body tags results in the construction of the render tree root. The root render object corresponds to what the CSS spec calls the containing block - the top most block that contains all other blocks. Its dimensions are the viewport - the browser window display area dimensions. Firefox calls it ViewPortFrame and Webkit calls it RenderView. This is the render object that the document point to. The rest of the tree is constructed as a DOM nodes insertion. （处理html和body标签导致渲染树根的构造。根渲染对象对于CSS规范调用包含块–包含所有其他块最顶层的块。其尺寸即viewport–浏览器窗口显示区域的尺寸。FF调用其ViewPortFrame和Webkit调用其RenderVIew。）<br>See CSS2 on this topic - <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">http://www.w3.org/TR/CSS21/intro.html#processing-model</a></li>
<li>样式计算<br>Style data is a very large construct, holding the numerous style properties, this can cause memory problems.<br>Finding the matching rules for each element can cause performance issues if it’s not optimized. Traversing the entire rule list for each element to find matches is a heavy task. Selectors can have complex structure that can cause the matching process to start on a seemingly promising path that is proven to be futile and another path has to be tried.<br>For example - this compound selector:<br>div div div div{<br>…<br>}<br>Means the rules apply to a “<div>“ who is the descendant of 3 divs. Suppose you want to check if the rule applies for a given “<div>“ element. You choose a certain path up the tree for checking. You may need to traverse the node tree up just to find out there are only two divs and the rule does not apply. You then need to try other paths in the tree.<br>Applying the rules involves quite complex cascade rules that define the hierarchy of the rules.<br>Let’s see how the browsers face these issues:<br>a. 共享样式数据<br>Webkit nodes references style objects (RenderStyle) These objects can be shared by nodes in some conditions. The nodes are siblings or cousins and（webkit节点指样式对象（renderstyle），某些情况下该对象可以为节点所共享。节点是兄弟表关系和）:<br>1.The elements must be in the same mouse state (e.g., one can’t be in :hover while the other isn’t).元素必须在一些鼠标状态<br>2.Neither element should have an id—也不能共用ID<br>3.The tag names should match—标签名应匹配<br>4.The class attributes should match—class属性应匹配<br>5.The set of mapped attributes must be identical—映射属性应匹配<br>6.The link states must match—链接状态应匹配<br>7.The focus states must match—焦点状态应匹配<br>8.Neither element should be affected by attribute selectors, where affected is defined as having any selector match that uses an attribute selector in any position within the selector at all。元素不应受属性选择器影响。<br>9.There must be no inline style attribute on the elements.元素不能有内联样式。<br>10.There must be no sibling selectors in use at all. WebCore simply throws a global switch when any sibling selector is encountered and disables style sharing for the entire document when they are present. This includes the + selector and selectors like :first-child and :last-child.必须没有使用同级选择器。<br>b. FireFox 树规则（有额外的树—规则树和样式文本树，针对更容易的样式计算）<br>Firefox has two extra trees for easier style computation - the rule tree and style context tree. Webkit also has style objects but they are not stored in a tree like the style context tree, only the DOM node points to its relevant style.<img src="http://img.mukewang.com/582e362c0001b3a506400407.png" alt="Firefox style context tree"><br>The style contexts contain end values（样式文本包含终值）. The values are computed by applying all the matching rules in the correct order and performing manipulations that transform them from logical to concrete values. For example - if the logical value is percentage of the screen it will be calculated and transformed to absolute units. The rule tree idea is really clever. It enables sharing these values between nodes to avoid computing them again. This also saves space.<br>All the matched rules are stored in a tree. The bottom nodes in a path have higher priority. The tree contains all the paths for rule matches that were found. Storing the rules is done lazily. The tree isn’t calculated at the beginning for every node, but whenever a node style needs to be computed the computed paths are added to the tree.<br>The idea is to see the tree paths as words in a lexicon. Lets say we already computed this rule tree:<br>Suppose we need to match rules for another element in the content tree, and find out the matched rules (in the correct order) are B - E - I. </li>
<li>Division into structs—分成结构<br>The style contexts are divided into structs(结构体). Those structs contain style information for a certain category like border or color. All the properties in a struct are either inherited or non inherited（所有属性在结构体中要么继承要么非继承）. Inherited properties are properties that unless defined by the element, are inherited from its parent. Non inherited properties (called “reset” properties) use default values if not defined.<br>The tree helps us by caching entire structs (containing the computed end values) in the tree（此树帮我等缓存所有结构体）. The idea is that if the bottom node didn’t supply a definition for a struct, a cached struct in an upper node can be used.</li>
<li>用树规则计算样式文本<br>When computing the style context for a certain element, we first compute a path in the rule tree or use an existing one. We then begin to apply the rules in the path to fill the structs in our new style context. We start at the bottom node of the path - the one with the highest precedence (usually the most specific selector) and traverse the tree up until our struct is full. If there is no specification for the struct in that rule node, then we can greatly optimize - we go up the tree until we find a node that specifies it fully and simply point to it - that’s the best optimization - the entire struct is shared. This saves computation of end values and memory.<br>If we find partial definitions we go up the tree until the struct is filled.<br>If we didn’t find any definitions for our struct, then in case the struct is an “inherited” type - we point to the struct of our parent in the context tree, in this case we also succeeded in sharing structs. If its a reset struct then default values will be used.<br>If the most specific node does add values then we need to do some extra calculations for transforming it to actual values. We then cache the result in the tree node so it can be used by children.<br>The resulting rule tree will look like this (the nodes are marked with the node name : the # of rule they point at):<img src="http://img.mukewang.com/582e3a850001ce7405000294.png" alt="The rule tree"><br><img src="http://img.mukewang.com/582e3aaa00017cbb04000305.png" alt="The context tree"><br>Suppose we parse the HTML and get to the second <div> tag. We need to create a style context for this node and fill its style structs.<br>We will match the rules and discover that the matching rules for the <div> are 1 ,2 and 6. This means there is already an existing path in the tree that our element can use and we just need to add another node to it for rule 6 (node F in the rule tree).<br>We will create a style context and put it in the context tree. The new style context will point to node F in the rule tree.<br>c. Manipulating the rules for an easy match—操作规则方便匹配<br>There are several sources for style rules:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CSS rules, either in external style sheets or in style elements.</div><div class="line">p &#123;color:blue&#125;</div><div class="line">Inline style attributes like</div><div class="line">&lt;p style=&quot;color:blue&quot; /&gt;</div><div class="line">HTML visual attributes (which are mapped to relevant style rules)</div><div class="line">&lt;p bgcolor=&quot;blue&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The last two are easily matched to the element since he owns the style attributes and HTML attributes can be mapped using the element as the key.(最后两个很容易地匹配到了元素因其拥有样式属性和html可以利用元素作为key去键映射的属性)<br>d. 正确的瀑布流顺序运用规则</p>
<ul>
<li>Style sheet cascade order—CSS规则<br>A declaration for a style property can appear in several style sheets, and several times inside a style sheet. This means the order of applying the rules is very important. This is called the “cascade” order. According to CSS2 spec, the cascade order is (from low to high)级联顺序（由低到高）:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Browser declarations:浏览器声明</div><div class="line">User normal declarations：用户正常声明</div><div class="line">Author normal declarations：作者正常声明</div><div class="line">Author important declarations：作者重要声明</div><div class="line">User important declarations：用户重要声明</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The browser declarations are least important and the user overrides the author only if the declaration was marked as important. Declarations with the same order will be sorted by specifity and then the order they are specified. The HTML visual attributes are translated to matching CSS declarations . They are treated as author rules with low priority.</p>
<ul>
<li><p>种类<br>选择器特性由CSS2规范定义如下：<br>如果声明是from是一个’style’属性，而不是一个带选择器的规则，则计数1，否则为0（= a）<br>计数选择器中的ID属性的数量（= b）<br>计数选择器中其他属性和伪类的数量（= c）<br>计数选择器中元素名称和伪元素的数量（= d）<br>连接四个数字a-b-c-d（在具有大基数的数字系统中）给出特异性。<br>您需要使用的数字基数由您在某个类别中拥有的最高计数来定义。<br>例如，如果a = 14，您可以使用十六进制基。 在不太可能的情况下，如果a = 17，您将需要一个17位数字基数。 后面的情况可能发生在这样的选择器：html body div div p …（17标签在你的选择器..不是很可能）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Some examples:</div><div class="line"></div><div class="line">* &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</div><div class="line">li &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</div><div class="line">li:first-line &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line">ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line">ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</div><div class="line">h1 + *[rel=up]&#123;&#125; /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</div><div class="line">ul ol li.red &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</div><div class="line">li.red.level &#123;&#125; /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</div><div class="line">#x34y &#123;&#125; /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</div><div class="line">style=&quot;&quot; /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div></pre></td></tr></table></figure>
</li>
<li><p>规则排序<br>After the rules are matched, they are sorted according to the cascade rules. Webkit uses bubble sort for small lists and merge sort for big ones. Webkit implements sorting by overriding the “&gt;” operator for the rules:</p>
</li>
</ul>
<figure class="highlight plain"><figcaption><span>bool operator >(CSSRuleData& r1, CSSRuleData& r2)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int spec1 = r1.selector()-&gt;specificity();</div><div class="line">int spec2 = r2.selector()-&gt;specificity();</div><div class="line">return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Gradual process—渐进过程<br>Webkit使用标记是否已加载所有顶级样式表（包括@imports）的标志。 如果在附加时样式未完全加载 - 使用占位符并在文档中标记，并且一旦样式表被加载，它们将被重新计算。</li>
</ul>
<ol>
<li>Layout</li>
</ol>
<ul>
<li>Dirty bit system脏位系统<br>In order not to do a full layout for every small change, browser use a “dirty bit” system. A renderer that is changed or added marks itself and its children as “dirty” - needing layout.</li>
</ul>
<p>There are two flags - “dirty” and “children are dirty”. Children are dirty means that although the renderer itself may be ok, it has at least one child that needs a layout.</p>
<ul>
<li>Global and incremental layout—全局和增量布局<img src="http://img.mukewang.com/582e3edc00011ece03260341.png" alt="Incremental layout - only dirty renderers and their children are layed out"></li>
<li>Asynchronous and Synchronous layout—异同布渲染</li>
<li>Optimizations—选择</li>
<li>The layout process 布局过程<br>The layout usually has the following pattern:</li>
</ul>
<p>Parent renderer determines its own width.<br>Parent goes over children and:<br>Place the child renderer (sets its x and y).<br>Calls child layout if needed(they are dirty or we are in a global layout or some other reason) - this calculates the child’s height.<br>Parent uses children accumulative heights and the heights of the margins and paddings to set it own height - this will be used by the parent renderer’s parent.<br>Sets its dirty bit to false.<br>Firefox uses a “state” object(nsHTMLReflowState) as a parameter to layout (termed “reflow”). Among others the state includes the parents width.<br>The output of Firefox layout is a “metrics” object(nsHTMLReflowMetrics). It will contain the renderer computed height.</p>
<ul>
<li>Width calculation 宽度计算</li>
<li>Line breaking 换行</li>
</ul>
<ol>
<li>Painting—喷涂</li>
</ol>
<ul>
<li>全局和增量<br>Like layout, painting can also be global - the entire tree is painted - or incremental. In incremental painting, some of the renderers change in a way that does not affect the entire tree. The changed renderer invalidates it’s rectangle on the screen. This causes the OS to see it as a “dirty region” and generate a “paint” event. The OS does it cleverly and coalesces several regions into one. In Chrome it is more complicated because the renderer is in a different process then the main process. Chrome simulates the OS behavior to some extent. The presentation listens to these events and delegates the message to the render root. The tree is traversed until the relevant renderer is reached. It will repaint itself (and usually its children).</li>
<li>喷涂规则<br>The stacking order of a block renderer is:<br>1.background color<br>2.background image<br>3.border<br>4.children<br>5.outline</li>
<li>FF 布局列表<br>Firefox goes over the render tree and builds a display list for the painted rectangular. It contains the renderers relevant for the rectangular, in the right painting order (backgrounds of the renderers, then borders etc).<br>That way the tree needs to be traversed only once for a repaint instead of several times - painting all backgrounds, then all images , then all borders etc.<br>Firefox optimizes the process by not adding elements that will be hidden, like elements completely beneath other opaque elements.</li>
<li>Webkit rectangle storage矩形存储<br>Before repainting, webkit saves the old rectangle as a bitmap. It then paints only the delta between the new and old rectangles. </li>
</ul>
<ol>
<li>动态改变<br>The browsers try to do the minimal possible actions in response to a change. So changes to an elements color will cause only repaint of the element. Changes to the element position will cause layout and repaint of the element, its children and possibly siblings. Adding a DOM node will cause layout and repaint of the node. Major changes, like increasing font size of the “html” element, will cause invalidation of caches, relyout and repaint of the entire tree.</li>
<li>渲染引擎线程</li>
</ol>
<ul>
<li>事件循环</li>
</ul>
<ol>
<li>CSS2 视觉模型</li>
</ol>
<ul>
<li>canvas</li>
<li>CSS Box model<br><img src="http://img.mukewang.com/582e40270001579c05090348.jpg" alt="box model"></li>
<li>Positioning scheme—定位方案</li>
<li>Box types—盒类型<br>Block box: forms a block - have their own rectangle on the browser window.<br>Inline box: does not have its own block, but is inside a containing block.<br>Blocks are formatted vertically one after the other. Inlines are formatted horizontally.<img src="http://img.mukewang.com/582e409300018abe03500324.png" alt="block-inlineBlock"></li>
<li>定位<br>a. relative<br>b. floats<br>c. absolute and fixed</li>
<li>Layered representation—分层表现</li>
</ul>
<ol>
<li>资源</li>
</ol>
<p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">how browsers work</a></p>
</script></p></blockquote></li></ul>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Youth]]></title>
      <url>https://yanlee26.github.io/2015/01/02/youth/</url>
      <content type="html"><![CDATA[<blockquote>
<p>志不朽者虽难必易，行不止者虽远必臻!</p>
</blockquote>
<h1 id="Youth"><a href="#Youth" class="headerlink" title=" Youth"></a><center> Youth</center></h1><p>　　Youth isn’t a time of life; it is a state of mind; it is not a matter of rosy cheeks,<br>red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions;<br>it is the freshness of the deep springs of life.</p>
<p>　　Youth means a temperamental predominance of courage over timidity, of the appetite for<br>adventure over the love of ease. This often exists in a man of 60 more than a boy of 20.<br>Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p>
<p>　　Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust<br> bows the heart and turns the spirit back to dust.</p>
<p>　　Whether 60 or 16, there is in every human being’s the lure of wonder, the unfailing childlike appetite for<br> what’s next and the joy of the game of living. In the center of my heart and your heart there is a wireless<br> station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the infinite,<br> so long are you young.</p>
<p>   When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism,<br> then you are grown old, even at 20; but as long as your aerials are up, to catch waves of optimism,<br> there is hope you may die young at 80.</p>
<hr>
<h1 id="青春"><a href="#青春" class="headerlink" title="青春"></a><center>青春</center></h1><p>　　青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。</p>
<p>　　青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，<br>    方堕暮年。</p>
<p>　　岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p>
<p>　　无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，<br>    只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。</p>
<p>　　一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，<br>    捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p>
]]></content>
    </entry>
    
  
  
</search>
