<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2017年前端技能规划]]></title>
      <url>https://github.com/yanlee26/blog/2016/12/09/frontend-shedule/</url>
      <content type="html"><![CDATA[<h3 id="2017年前端技能规划"><a href="#2017年前端技能规划" class="headerlink" title="2017年前端技能规划"></a>2017年前端技能规划</h3><ol>
<li>结合公司业务需求，补充、完善、更新自身技术栈；在前端（尤其移动端）方面，做到<br>基本功扎实并立足于行业技术前沿；如有余力，熟悉一门后台语言（php，python,java）,以<br>更加完善软件开发的知识技能储备。</li>
<li>熟悉，深刻了解公司产品特点及业务需求特征；在保证功能的前提下，做到代码优雅，命名<br>规范，逻辑缜密，以提高复用性及方便日后的维护，提高前端开发效率。</li>
<li><a href="http://www.xmind.net/m/4AFt" target="_blank" rel="external">技能XMind</a></li>
</ol>
<ul>
<li><p>###技术栈</p>
<p>| 类型          |                主要内容          |<br>| :———— |:—————————-:    |<br>|Core|html（html5）,css（css3）,js（es6）,component|<br>|UI Frameworks |bootstrap,ionic,mui,               |<br>|CSS Preprocessors|sass,scss,less                  |<br>|JS Frameworks|jquery,zepto,vue/react/angular,three|<br>|JS Preprocessors |babel,typescript                |<br>|Back End|node php                                 |<br>|Http Test|Postman                                 |<br>|Template|Jade,Haml                                |<br>|Code Quality|JSLint,EsLint                        |<br>|Process Automation|gulp,grunt                     |<br>|Package Managers|npm,webpack,bower                |<br>|Building Tools|webpack,requireJS                  |<br>|FrontEnd Performance|WebPagetest                  |<br>|Testing|Karma                                     |<br>|Version Control|git ,svn                          |<br>|Text Editors|sublime,webstorm                     |</p>
</li>
<li><h3 id="熟悉常见软件开发模式"><a href="#熟悉常见软件开发模式" class="headerlink" title="熟悉常见软件开发模式"></a>熟悉常见软件开发模式</h3><blockquote>
<p>未来只有两种软件工程师:端工程师+ 云工程师</p>
</blockquote>
<p>| 分类          | 内容           |     备注       |<br>| :———— |:————–:|:————–:|<br>|MVC|Model-管理数据，View-视图展现，Controller（backbone没有），Router|2010年，web2.0时代|<br>|MVVM|视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理|View-Model简化的 Controller,|<br>|SPA| Single-page application|vue,react,angular|<br>|前后端分离| Ajax -前端应用兴起；智能手机 -多终端支持|前端不再是后端 MVC 中的 V，而是单独的一层；REST前后端分离后之间的通信接口|<br>|NODE|JS+操作系统API0|JS成为唯一的浏览器和服务器都支持的语言，前端开发模式的根本改变|<br>|全端|传统技能（JS+HTML+CSS；一门后端语言；移动开发；数据库等|发展成全栈工程师|</p>
</li>
<li><h3 id="熟悉前端工程化"><a href="#熟悉前端工程化" class="headerlink" title="熟悉前端工程化"></a>熟悉前端工程化</h3><blockquote>
<p>前端开发转移到后端环境，意味着可以适用标准的软件工程流程。</p>
</blockquote>
</li>
</ul>
<ol>
<li>持续集成Continuous integration（简称 CI）<blockquote>
<p>开发代码频繁地合并进主干，始终保持可发布状态的这个过程。<br>优点:快速发现错误\防止分支大幅偏离主干\让产品可以快速迭代，同时还能保持高质量</p>
</blockquote>
</li>
</ol>
<ul>
<li>流程<ul>
<li>本地开发（developing）</li>
<li>静态代码检查（linting）</li>
<li>单元测试（testing）</li>
<li>合并进入主干（merging）</li>
<li>自动构建（building）</li>
<li>自动发布（publishing）</li>
</ul>
</li>
</ul>
<ol>
<li>静态代码检查及测试<blockquote>
<p>发现语法错误,发现风格错误,自动纠正错误<br>Web 应用越来越复杂，意味着更可能出错。测试是提高代码质量、降低错误的最好方法之一。<br>测试可以确保得到预期结果。</p>
</blockquote>
</li>
</ol>
<ul>
<li>测试类型<ul>
<li>单元测试（unit testing）</li>
<li>功能测试（feature testing）<blockquote>
<p>功能测试指的是，站在外部用户的角度，测试软件的某项功能。<br>与内部代码实现无关，只测试功能是否正常。<br>很多时候，单元测试都可以通过，但是整体功能会失败。        </p>
</blockquote>
</li>
<li>集成测试（integration testing）</li>
<li>端对端测试 (End-to-End testing）</li>
</ul>
</li>
<li>以测试为导向的开发模式<ul>
<li>TDD：测试驱动的开发（Test-Driven Development）</li>
<li>BDD：行为驱动的开发（Behavior-Driven Development）</li>
<li>是目前最常用的测试框架：Mocha </li>
</ul>
</li>
</ul>
<ol>
<li>移动平台的自动化测试 ,最常见的方案是使用 Appium。  <ul>
<li>基于 WebDriver</li>
<li>采用 客户端/服务器架构</li>
<li>可以在模拟器运行，也可以在真机运行</li>
</ul>
</li>
</ol>
<ul>
<li><h3 id="技术补充资源"><a href="#技术补充资源" class="headerlink" title="技术补充资源"></a>技术补充资源</h3><ul>
<li>JS部分<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="external">A_re-introduction_to_JavaScript</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript 6 入门</a>  </li>
<li><a href="https://vuejs.org/v2/guide/" target="_blank" rel="external">https://vuejs.org/v2/guide/</a></li>
<li><a href="https://facebook.github.io/react/" target="_blank" rel="external">https://facebook.github.io/react/</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a></li>
<li><a href="http://expressjs.com/" target="_blank" rel="external">http://expressjs.com/</a></li>
<li><a href="http://babeljs.cn/" target="_blank" rel="external">http://babeljs.cn/</a></li>
<li><a href="https://threejs.org/" target="_blank" rel="external">https://threejs.org/</a></li>
</ul>
</li>
<li>CSS部分<ul>
<li><a href="http://getbootstrap.com/" target="_blank" rel="external">http://getbootstrap.com/</a></li>
<li><a href="http://compass-style.org/" target="_blank" rel="external">http://compass-style.org/</a></li>
</ul>
</li>
<li>前端规范<ul>
<li><a href="http://www.w3schools.com/" target="_blank" rel="external">http://www.w3schools.com/</a></li>
</ul>
</li>
<li>打包工具<ul>
<li><a href="http://webpack.github.io/" target="_blank" rel="external">http://webpack.github.io/</a></li>
</ul>
</li>
<li>前端自动化<ul>
<li><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">http://www.gulpjs.com.cn/</a></li>
</ul>
</li>
<li>包管理工具<ul>
<li><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a></li>
</ul>
</li>
<li>其它<ul>
<li><a href="https://visualgo.net/" target="_blank" rel="external">数据结构</a></li>
<li><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="external">how browsers work</a></li>
<li><a href="https://platform.html5.org/" target="_blank" rel="external">https://platform.html5.org/</a></li>
<li><a href="http://www.imooc.com/u/2916001" target="_blank" rel="external">慕课网</a></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node--文件及网络操作]]></title>
      <url>https://github.com/yanlee26/blog/2016/11/04/node--http&amp;https/</url>
      <content type="html"><![CDATA[<h1 id="Node–文件及网络操作"><a href="#Node–文件及网络操作" class="headerlink" title="Node–文件及网络操作"></a>Node–文件及网络操作</h1><blockquote>
<p>文件流、网络操作、服务端Web开发基础</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h3><h4 id="利用文件监视实现自动-markdown-文件转换"><a href="#利用文件监视实现自动-markdown-文件转换" class="headerlink" title="利用文件监视实现自动 markdown 文件转换"></a>利用文件监视实现自动 markdown 文件转换</h4><ul>
<li><p>相关链接：</p>
<ol>
<li><a href="https://github.com/chjj/marked">https://github.com/chjj/marked</a></li>
<li><a href="https://github.com/Browsersync/browser-sync">https://github.com/Browsersync/browser-sync</a> </li>
</ol>
</li>
<li><p>实现思路：</p>
<ol>
<li>利用<code>fs</code>模块的文件监视功能监视指定MD文件</li>
<li>当文件发生变化后，借助<code>marked</code>包提供的<code>markdown</code> to <code>html</code>功能将改变后的MD文件转换为HTML</li>
<li>再将得到的HTML替换到模版中</li>
<li>最后利用BrowserSync模块实现浏览器自动刷新<br>browsersync需要用到Python</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line"><span class="keyword">var</span> bs = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> target = path.join(__dirname, process.argv[<span class="number">2</span>] || <span class="string">'./README.md'</span>);</div><div class="line"><span class="keyword">var</span> filename = path.basename(target, path.extname(target)) + <span class="string">'.html'</span>;</div><div class="line"><span class="keyword">var</span> targetHtml = path.join(path.dirname(target), filename);</div><div class="line"></div><div class="line">bs.init(&#123;</div><div class="line">  <span class="attr">server</span>: path.dirname(target),</div><div class="line">  <span class="attr">index</span>: filename,</div><div class="line">  <span class="attr">notify</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">bs.reload(filename);</div><div class="line"></div><div class="line"><span class="keyword">var</span> template = <span class="string">`&lt;!DOCTYPE html&gt;</span></div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset="UTF-8"&gt;</div><div class="line">  &lt;title&gt;&lt;/title&gt;</div><div class="line">  &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;article class="markdown"&gt;</div><div class="line">    &#123;&#123;&#123;body&#125;&#125;&#125;</div><div class="line">  &lt;/article&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">`;</div><div class="line"></div><div class="line">fs.readFile(path.join(__dirname, <span class="string">'./markdown.css'</span>), <span class="string">'utf8'</span>, (error, css) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</div><div class="line">  template = template.replace(<span class="string">'&#123;&#123;&#123;styles&#125;&#125;&#125;'</span>, css);</div><div class="line">  <span class="keyword">var</span> handler = <span class="function">(<span class="params">current, previous</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(target, <span class="string">'utf8'</span>, (error, content) =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> html = template.replace(<span class="string">'&#123;&#123;&#123;body&#125;&#125;&#125;'</span>, marked(content));</div><div class="line">      fs.writeFile(targetHtml, html, (error) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (!error) &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">`updated@<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>);</div><div class="line">          bs.reload(filename);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  handler();</div><div class="line">  fs.watchFile(target, &#123; <span class="attr">interval</span>: <span class="number">100</span> &#125;, handler);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p><img src="./img/01.png" alt="二进制的世界"></p>
<ul>
<li><p>现实过程的流</p>
<ul>
<li>水流，人流</li>
</ul>
</li>
<li><p>在程序开发的概念中</p>
<ul>
<li>流是程序输入或输出的一个连续的字节序列</li>
<li>文件流、网络流</li>
<li>设备(例如鼠标、键盘、磁盘、屏幕、调制解调器和打印机)的输入和输出都是用流来处理的。</li>
</ul>
</li>
</ul>
<h3 id="Node中的流操作"><a href="#Node中的流操作" class="headerlink" title="Node中的流操作"></a>Node中的流操作</h3><p><img src="./img/02.png" alt="流的操作"></p>
<p>在 Node 核心模块 fs 中定义了一些与流相关的 API</p>
<ul>
<li>fs.createReadStream()<ul>
<li>=&gt; 得到一个ReadableStream</li>
</ul>
</li>
<li>fs.createWriteStream()<ul>
<li>=&gt; 得到一个WritableStream</li>
</ul>
</li>
</ul>
<h3 id="读取流常用-API"><a href="#读取流常用-API" class="headerlink" title="读取流常用 API"></a>读取流常用 API</h3><h4 id="Event："><a href="#Event：" class="headerlink" title="Event："></a>Event：</h4><ul>
<li>data</li>
<li>end</li>
<li>error</li>
</ul>
<h4 id="Method："><a href="#Method：" class="headerlink" title="Method："></a>Method：</h4><ul>
<li>read([size])、</li>
<li>pause()、</li>
<li>isPause()、</li>
<li>resume()、</li>
<li>setEncoding(encoding)、</li>
<li>pipe(destination[, options])、</li>
<li>unpipe([destination])</li>
</ul>
<h3 id="写入流常用-API"><a href="#写入流常用-API" class="headerlink" title="写入流常用 API"></a>写入流常用 API</h3><h4 id="Event"><a href="#Event" class="headerlink" title="Event:"></a>Event:</h4><ul>
<li>error</li>
<li>pipe</li>
</ul>
<h4 id="Method：-1"><a href="#Method：-1" class="headerlink" title="Method："></a>Method：</h4><ul>
<li>write(chunk[, encoding][, callback])</li>
<li>end([chunk][, encoding][, callback])</li>
<li>setDefaultEncoding(encoding)</li>
</ul>
<hr>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p>如何计算循环节长度呢？</p>
<p>想想我们手算，如果余数比除数小，我们会在后面补0然后再除。也就是说补零之后的数是下一次的被除数。如果被除数重复出现，除数确定的，那么商和余数也就是一样的。这时，循环节就出现了。</p>
<p>下面的函数分为两部分，</p>
<p>补零操作<br>查找有没有同样的被除数存在，如果有，就找到了循环节，计算循环节长度并返回。在没有找到的前提下，把当前被除数记录下来，并得到余数作为下一次的被除数。<br>这里需要注意，如果某一次出现了除尽的情况，说明该分数是有限小数，循环节长度是0。<br>`<br>JavaScript</p>
<p>console.log(foo(11, 3));<br>console.log(foo(1, 7));;<br>console.log(foo(2, 10));;<br>function foo(a, b) {<br>  if (!(a % b)) {<br>    return <code>${a}÷${b}:${a / b}</code>;<br>  }<br>  var all = (a / b).toString().split(‘.’);<br>  var i = getCycleSection(a, b);<br>  if(i)<br>    return <code>${a}÷${b}: ${all[0]}.{${all[1].substr(0, i) }}</code>;<br>    return <code>${a}÷${b}: ${a / b}</code>;</p>
<p>}<br>function getCycleSection(n, m) {<br>  var temp = [];<br>  while (true) {<br>    while (n &lt; m) {<br>      n *= 10;<br>    }<br>    var index = temp.indexOf(n);<br>    if (index &gt;= 0) {<br>      return temp.length - index;<br>    }<br>    temp.push(n);<br>    n %= m;<br>    if (!n)<br>      return 0;<br>  }<br>}</p>
<p>`</p>
<blockquote>
<p>HTTP协议，http、url、querystring、模块、网络爬虫，创建文件服务器</p>
</blockquote>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h2 id="收发有格式的数据"><a href="#收发有格式的数据" class="headerlink" title="收发有格式的数据"></a>收发有格式的数据</h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="Node中与HTTP相关的模块"><a href="#Node中与HTTP相关的模块" class="headerlink" title="Node中与HTTP相关的模块"></a>Node中与HTTP相关的模块</h2><h2 id="网络爬虫爬取页面内容"><a href="#网络爬虫爬取页面内容" class="headerlink" title="网络爬虫爬取页面内容"></a>网络爬虫爬取页面内容</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node--常用模块初探]]></title>
      <url>https://github.com/yanlee26/blog/2016/11/03/node--npmpackages/</url>
      <content type="html"><![CDATA[<h1 id="Node–常用模块初探"><a href="#Node–常用模块初探" class="headerlink" title="Node–常用模块初探"></a>Node–常用模块初探</h1><blockquote>
<p>核心模块和NPM、文件操作、文件流、网络操作</p>
</blockquote>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><h3 id="核心模块的意义"><a href="#核心模块的意义" class="headerlink" title="核心模块的意义"></a>核心模块的意义</h3><ul>
<li>如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。</li>
<li>Node 的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。</li>
<li>这些核心的功能模块在 Node 中内置。</li>
</ul>
<h3 id="内置如下模块："><a href="#内置如下模块：" class="headerlink" title="内置如下模块："></a>内置如下模块：</h3><ul>
<li><a href="http://nodejs.org/api/path.html" target="_blank" rel="external">path</a>：处理文件路径。</li>
<li><a href="http://nodejs.org/api/fs.html" target="_blank" rel="external">fs</a>：操作文件系统。</li>
<li><a href="http://nodejs.org/api/child_process.html" target="_blank" rel="external">child_process</a>：新建子进程。</li>
<li><a href="http://nodejs.org/api/util.html" target="_blank" rel="external">util</a>：提供一系列实用小工具。</li>
<li><a href="http://nodejs.org/api/http.html" target="_blank" rel="external">http</a>：提供HTTP服务器功能。</li>
<li><a href="http://nodejs.org/api/url.html" target="_blank" rel="external">url</a>：用于解析URL。</li>
<li><a href="http://nodejs.org/api/querystring.html" target="_blank" rel="external">querystring</a>：解析URL中的查询字符串。</li>
<li><a href="http://nodejs.org/api/crypto.html" target="_blank" rel="external">crypto</a>：提供加密和解密功能。</li>
<li><a href="https://nodejs.org/api/" target="_blank" rel="external">其他</a></li>
</ul>
<hr>
<h2 id="Node-Package"><a href="#Node-Package" class="headerlink" title="Node Package"></a>Node Package</h2><blockquote>
<p>由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（Package）的概念。与核心模块类似，就是将一些预先设计好的功能或者说API封装到一个文件夹，提供给开发者使用；</p>
</blockquote>
<h3 id="包的加载机制"><a href="#包的加载机制" class="headerlink" title="包的加载机制"></a>包的加载机制</h3><ul>
<li>与内置模块相同，包的加载同样使用<code>require</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div></pre></td></tr></table></figure>
<ul>
<li>加载机制也和内置模块加载机制相同</li>
<li><p>加载注意事项：</p>
<ul>
<li>先在系统核心（优先级最高）的模块中找；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// 永远加载内部核心模块fs</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>然后再到当前项目中 node_modules 目录中找；</li>
</ul>
<h3 id="如何管理好自己的包包"><a href="#如何管理好自己的包包" class="headerlink" title="如何管理好自己的包包"></a>如何管理好自己的包包</h3><ul>
<li>由于<code>Node</code>本身并没有太多的功能性<code>API</code>，所以市面上涌现出大量的第三方人员开发出来的<code>Package</code><br><img src="./img/npm.png" alt="www.npmjs.com"></li>
<li>包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理</li>
<li>这时候<code>NPM</code>诞生了</li>
</ul>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><ul>
<li><p>随着时间的发展，NPM 出现了两层概念：</p>
<ul>
<li>一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区</li>
<li>另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。</li>
</ul>
</li>
<li><p>官方链接： <a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a></p>
</li>
<li>国内加速镜像： <a href="https://npm.taobao.org/" target="_blank" rel="external">https://npm.taobao.org/</a></li>
</ul>
<h3 id="安装NPM"><a href="#安装NPM" class="headerlink" title="安装NPM"></a>安装NPM</h3><ul>
<li>NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM。</li>
<li>但是，Node 附带的 NPM 可能不是最新版本，最好用下面的命令，更新到最新版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install npm -g</div></pre></td></tr></table></figure>
<ul>
<li>默认安装到当前系统 Node 所在目录下。</li>
<li>由于之前使用 NVM 的方式安装的 Node 所以需要重新配置 NPM 的全局目录</li>
</ul>
<h3 id="配置NPM的全局目录"><a href="#配置NPM的全局目录" class="headerlink" title="配置NPM的全局目录"></a>配置NPM的全局目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config <span class="built_in">set</span> prefix [pathtonpm]</div></pre></td></tr></table></figure>
<ul>
<li>将NPM目录配置到其他目录时，必须将该目录放到环境变量中，否则无法再全局使用</li>
</ul>
<h3 id="常用NPM命令"><a href="#常用NPM命令" class="headerlink" title="常用NPM命令"></a>常用NPM命令</h3><ul>
<li><a href="https://docs.npmjs.com/" target="_blank" rel="external">https://docs.npmjs.com/</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">npm config [ls|list|<span class="built_in">set</span>|get] [name] [value]</div><div class="line">npm init [--yes|-y]</div><div class="line">npm search [name]</div><div class="line">npm info [name]</div><div class="line">npm install [--global|-g] [name]</div><div class="line">npm uninstall [--global|-g] [name]</div><div class="line">npm list [--global|-g]</div><div class="line">npm outdated [--global|-g]</div><div class="line">npm update [--global|-g] [name]</div><div class="line">npm run [task]</div><div class="line">npm cache [clean]</div></pre></td></tr></table></figure>
<hr>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="相关模块"><a href="#相关模块" class="headerlink" title="相关模块"></a>相关模块</h3><p>Node内核提供了很多与文件操作相关的模块，每个模块都提供了一些最基本的操作API，在NPM中也有社区提供的功能包</p>
<h5 id="fs："><a href="#fs：" class="headerlink" title="fs："></a>fs：</h5><p>基础的文件操作 API</p>
<h5 id="path："><a href="#path：" class="headerlink" title="path："></a>path：</h5><p>提供和路径相关的操作 API</p>
<h5 id="readline："><a href="#readline：" class="headerlink" title="readline："></a>readline：</h5><p>用于读取大文本文件，一行一行读</p>
<h5 id="fs-extra（第三方）："><a href="#fs-extra（第三方）：" class="headerlink" title="fs-extra（第三方）："></a>fs-extra（第三方）：</h5><p><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="external">https://www.npmjs.com/package/fs-extra</a> </p>
<h3 id="同步或异步调用"><a href="#同步或异步调用" class="headerlink" title="同步或异步调用"></a>同步或异步调用</h3><ul>
<li>fs模块对文件的几乎所有操作都有同步和异步两种形式</li>
<li>例如：readFile() 和 readFileSync()</li>
<li>区别：<ul>
<li>同步调用会阻塞代码的执行，异步则不会</li>
<li>异步调用会将读取任务下达到任务队列，直到任务执行完成才会回调</li>
<li>异常处理方面，同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">'sync'</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">var</span> data = fs.readFileSync(path.join(<span class="string">'C:\\Users\\iceStone\\Downloads'</span>, <span class="string">'H.mp4'</span>));</div><div class="line">  <span class="comment">// console.log(data);</span></div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">  <span class="keyword">throw</span> error;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'sync'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.time(<span class="string">'async'</span>);</div><div class="line">fs.readFile(path.join(<span class="string">'C:\\Users\\iceStone\\Downloads'</span>, <span class="string">'H.mp4'</span>), (error, data) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</div><div class="line">  <span class="comment">// console.log(data);</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'async'</span>);</div></pre></td></tr></table></figure>
<h3 id="路径模块"><a href="#路径模块" class="headerlink" title="路径模块"></a>路径模块</h3><p>在文件操作的过程中，都必须使用物理路径（绝对路径），path模块提供了一系列与路径相关的 API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'join用于拼接多个路径部分，并转化为正常格式'</span>);</div><div class="line"><span class="keyword">const</span> temp = path.join(__dirname, <span class="string">'..'</span>, <span class="string">'lyrics'</span>, <span class="string">'./友谊之光.lrc'</span>);</div><div class="line"><span class="built_in">console</span>.log(temp);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取路径中的文件名'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.basename(temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取路径中的文件名并排除扩展名'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.basename(temp, <span class="string">'.lrc'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取不同操作系统的路径分隔符'</span>);</div><div class="line"><span class="built_in">console</span>.log(process.platform + <span class="string">'的分隔符为 '</span> + path.delimiter);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'一般用于分割环境变量'</span>);</div><div class="line"><span class="built_in">console</span>.log(process.env.PATH.split(path.delimiter));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取一个路径中的目录部分'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.dirname(temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取一个路径中最后的扩展名'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.extname(temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'将一个路径解析成一个对象的形式'</span>);</div><div class="line"><span class="keyword">const</span> pathObject = path.parse(temp);</div><div class="line"><span class="built_in">console</span>.log(pathObject);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'将一个路径对象再转换为一个字符串的形式'</span>);</div><div class="line"><span class="comment">// pathObject.name = '我终于失去了你';</span></div><div class="line">pathObject.base = <span class="string">'我终于失去了你.lrc'</span>;</div><div class="line"><span class="built_in">console</span>.log(pathObject);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取一个路径是不是绝对路径'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(temp));</div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'../lyrics/爱的代价.lrc'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'将一个路径转换为当前系统默认的标准格式，并解析其中的./和../'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.normalize(<span class="string">'c:/develop/demo\\hello/../world/./a.txt'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取第二个路径相对第一个路径的相对路径'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.relative(__dirname, temp));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'以类似命令行cd命令的方式拼接路径'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.resolve(temp, <span class="string">'c:/'</span>, <span class="string">'./develop'</span>, <span class="string">'../application'</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'获取不同平台中路径的分隔符（默认）'</span>);</div><div class="line"><span class="built_in">console</span>.log(path.sep);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'允许在任意平台下以WIN32的方法调用PATH对象'</span>);</div><div class="line"><span class="comment">// console.log(path.win32);</span></div><div class="line"><span class="built_in">console</span>.log(path === path.win32);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'允许在任意平台下以POSIX的方法调用PATH对象'</span>);</div><div class="line"><span class="built_in">console</span>.log(path === path.posix);</div></pre></td></tr></table></figure>
<p>源码地址：<br><a href="https://github.com/nodejs/node/blob/master/lib/path.js">https://github.com/nodejs/node/blob/master/lib/path.js</a></p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>Node中文件读取的方式主要有：</p>
<h4 id="fs-readFile-file-options-callback-error-data"><a href="#fs-readFile-file-options-callback-error-data" class="headerlink" title="fs.readFile(file[, options], callback(error, data))"></a>fs.readFile(file[, options], callback(error, data))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(<span class="string">'c:\\demo\1.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="fs-readFileSync-file-options"><a href="#fs-readFileSync-file-options" class="headerlink" title="fs.readFileSync(file[, options])"></a>fs.readFileSync(file[, options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">const</span> data = fs.readFileSync(<span class="string">'c:\\demo\1.txt'</span>, <span class="string">'utf8'</span>);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="comment">// 文件不存在，或者权限错误</span></div><div class="line">  <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fs-createReadStream-path-options"><a href="#fs-createReadStream-path-options" class="headerlink" title="fs.createReadStream(path[, options])"></a>fs.createReadStream(path[, options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> stream = fs.createReadStream(<span class="string">'c:\\demo\1.txt'</span>);</div><div class="line"><span class="keyword">let</span> data = <span class="string">''</span></div><div class="line">stream.on(<span class="string">'data'</span>, (trunk) =&gt; &#123;</div><div class="line">  data += trunk;</div><div class="line">&#125;);</div><div class="line">stream.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p><em>由于Windows平台下默认文件编码是GBK，在Node中不支持，可以通过<a href="https://github.com/ashtuchkin/iconv-lite">iconv-lite</a>解决</em></p>
</blockquote>
<h3 id="Readline模块逐行读取文本内容"><a href="#Readline模块逐行读取文本内容" class="headerlink" title="Readline模块逐行读取文本内容"></a>Readline模块逐行读取文本内容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</div><div class="line">  <span class="attr">input</span>: fs.createReadStream(<span class="string">'sample.txt'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rl.on(<span class="string">'line'</span>, (line) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Line from file:'</span>, line);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>Node中文件写入的方式主要有：</p>
<h4 id="fs-writeFile-file-data-options-callback-error"><a href="#fs-writeFile-file-data-options-callback-error" class="headerlink" title="fs.writeFile(file, data[, options], callback(error))"></a>fs.writeFile(file, data[, options], callback(error))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(<span class="string">'c:\\demo\a.txt'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(), (error) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="fs-writeFileSync-file-data-options"><a href="#fs-writeFileSync-file-data-options" class="headerlink" title="fs.writeFileSync(file, data[, options])"></a>fs.writeFileSync(file, data[, options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  fs.writeFileSync(<span class="string">'c:\\demo\a.txt'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">  <span class="comment">// 文件夹不存在，或者权限错误</span></div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="fs-createWriteStream-path-option"><a href="#fs-createWriteStream-path-option" class="headerlink" title="fs.createWriteStream(path[,option])"></a>fs.createWriteStream(path[,option])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> streamWriter = fs.createWriteStream(<span class="string">'c:\\demo\a.txt'</span>);</div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  streamWriter.write(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>&#125;</span>\n`</span>, (error) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h3 id="文件写入-1"><a href="#文件写入-1" class="headerlink" title="文件写入"></a>文件写入</h3><h4 id="fs-appendFile-file-data-options-callback-err"><a href="#fs-appendFile-file-data-options-callback-err" class="headerlink" title="fs.appendFile(file,data[,options],callback(err))"></a>fs.appendFile(file,data[,options],callback(err))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相比较之前文件流的方式，这种方式不会占用文件资源，append完成就会释放</span></div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  fs.appendFile(<span class="string">'c:\\demo\a.txt'</span>,<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>&#125;</span>\n`</span>, (error) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h4 id="fs-appendFileSync-file-data-options"><a href="#fs-appendFileSync-file-data-options" class="headerlink" title="fs.appendFileSync(file,data[,options])"></a>fs.appendFileSync(file,data[,options])</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  fs.appendFileSync(<span class="string">'c:\\demo\a.txt'</span>,<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>&#125;</span>\n`</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h3 id="其他常见文件操作"><a href="#其他常见文件操作" class="headerlink" title="其他常见文件操作"></a>其他常见文件操作</h3><h4 id="验证路径是否存在（过时的API）"><a href="#验证路径是否存在（过时的API）" class="headerlink" title="验证路径是否存在（过时的API）"></a>验证路径是否存在（过时的API）</h4><ul>
<li>fs.exists(path,callback(exists))</li>
<li>fs.existsSync(path) // =&gt; 返回布尔类型 exists</li>
</ul>
<h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><ul>
<li>fs.stat(path,callback(err,stats))</li>
<li>fs.statSync(path) // =&gt; 返回一个fs.Stats实例</li>
</ul>
<h4 id="移动文件或重命名文件或目录"><a href="#移动文件或重命名文件或目录" class="headerlink" title="移动文件或重命名文件或目录"></a>移动文件或重命名文件或目录</h4><blockquote>
<p>与命令行相同，重命名操作也可以实现文件移动</p>
</blockquote>
<ul>
<li>fs.rename(oldPath,newPath,callback)</li>
<li>fs.renameSync(oldPath,newPath)</li>
</ul>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ul>
<li>fs.unlink(path,callback(err))</li>
<li>fs.unlinkSync(path)</li>
</ul>
<h3 id="其他常见文件夹操作"><a href="#其他常见文件夹操作" class="headerlink" title="其他常见文件夹操作"></a>其他常见文件夹操作</h3><h4 id="创建一个目录"><a href="#创建一个目录" class="headerlink" title="创建一个目录"></a>创建一个目录</h4><ul>
<li>fs.mkdir(path[,model],callback)</li>
<li>fs.mkdirSync(path[,model])</li>
</ul>
<h4 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h4><ul>
<li>fs.rmdir(path,callback)</li>
<li>fs.rmdirSync(path)</li>
</ul>
<h4 id="读取一个目录"><a href="#读取一个目录" class="headerlink" title="读取一个目录"></a>读取一个目录</h4><ul>
<li>fs.readdir(path,callback(err,files))</li>
<li>fs.readdirSync(path) // =&gt; 返回files</li>
</ul>
<h3 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h3><h4 id="利用文件监视实现自动-markdown-文件转换"><a href="#利用文件监视实现自动-markdown-文件转换" class="headerlink" title="利用文件监视实现自动 markdown 文件转换"></a>利用文件监视实现自动 markdown 文件转换</h4><ul>
<li><p>相关链接：</p>
<ol>
<li><a href="https://github.com/chjj/marked">https://github.com/chjj/marked</a></li>
<li><a href="https://github.com/Browsersync/browser-sync">https://github.com/Browsersync/browser-sync</a> </li>
</ol>
</li>
<li><p>实现思路：</p>
<ol>
<li>利用<code>fs</code>模块的文件监视功能监视指定MD文件</li>
<li>当文件发生变化后，借助<code>marked</code>包提供的<code>markdown</code> to <code>html</code>功能将改变后的MD文件转换为HTML</li>
<li>再将得到的HTML替换到模版中</li>
<li>最后利用BrowserSync模块实现浏览器自动刷新</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line"><span class="keyword">var</span> bs = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> target = path.join(__dirname, process.argv[<span class="number">2</span>] || <span class="string">'./README.md'</span>);</div><div class="line"><span class="keyword">var</span> filename = path.basename(target, path.extname(target)) + <span class="string">'.html'</span>;</div><div class="line"><span class="keyword">var</span> targetHtml = path.join(path.dirname(target), filename);</div><div class="line"></div><div class="line">bs.init(&#123;</div><div class="line">  <span class="attr">server</span>: path.dirname(target),</div><div class="line">  <span class="attr">index</span>: filename,</div><div class="line">  <span class="attr">notify</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">bs.reload(filename);</div><div class="line"></div><div class="line"><span class="keyword">var</span> template = <span class="string">`&lt;!DOCTYPE html&gt;</span></div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset="UTF-8"&gt;</div><div class="line">  &lt;title&gt;&lt;/title&gt;</div><div class="line">  &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;article class="markdown"&gt;</div><div class="line">    &#123;&#123;&#123;body&#125;&#125;&#125;</div><div class="line">  &lt;/article&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">`;</div><div class="line"></div><div class="line">fs.readFile(path.join(__dirname, <span class="string">'./markdown.css'</span>), <span class="string">'utf8'</span>, (error, css) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</div><div class="line">  template = template.replace(<span class="string">'&#123;&#123;&#123;styles&#125;&#125;&#125;'</span>, css);</div><div class="line">  <span class="keyword">var</span> handler = <span class="function">(<span class="params">current, previous</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(target, <span class="string">'utf8'</span>, (error, content) =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> html = template.replace(<span class="string">'&#123;&#123;&#123;body&#125;&#125;&#125;'</span>, marked(content));</div><div class="line">      fs.writeFile(targetHtml, html, (error) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (!error) &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">`updated@<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>);</div><div class="line">          bs.reload(filename);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  handler();</div><div class="line">  fs.watchFile(target, &#123; <span class="attr">interval</span>: <span class="number">100</span> &#125;, handler);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h2 id="缓冲区处理"><a href="#缓冲区处理" class="headerlink" title="缓冲区处理"></a>缓冲区处理</h2><h3 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a>什么是缓冲区</h3><ul>
<li>缓冲区就是内存中操作数据的容器</li>
<li>只是数据容器而已</li>
<li>通过缓冲区可以很方便的操作二进制数据</li>
<li>而且在大文件操作时必须有缓冲区</li>
</ul>
<h3 id="为什么要有缓冲区"><a href="#为什么要有缓冲区" class="headerlink" title="为什么要有缓冲区"></a>为什么要有缓冲区</h3><ul>
<li>JavaScript是比较擅长处理字符串，但是早期的应用场景主要用于处理HTML文档，不会有太大篇幅的数据处理，也不会接触到二进制的数据。</li>
<li>而在Node中操作数据、网络通信是没办法完全以字符串的方式操作的，简单来说</li>
<li>所以在Node中引入了一个二进制的缓冲区的实现：Buffer</li>
</ul>
<hr>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node--get started]]></title>
      <url>https://github.com/yanlee26/blog/2016/11/01/node--getstarted/</url>
      <content type="html"><![CDATA[<h1 id="Node–get-started"><a href="#Node–get-started" class="headerlink" title="Node–get started"></a>Node–get started</h1><blockquote>
<p>Node简介及配置、快速上手、核心特点、模块化</p>
</blockquote>
<h2 id="Node简介"><a href="#Node简介" class="headerlink" title="Node简介"></a>Node简介</h2><h3 id="客户端的JavaScript是怎样的"><a href="#客户端的JavaScript是怎样的" class="headerlink" title="客户端的JavaScript是怎样的"></a>客户端的JavaScript是怎样的</h3><ul>
<li><p>什么是 JavaScript？</p>
<ul>
<li>脚本语言</li>
<li>运行在浏览器中</li>
<li>一般用来做客户端页面的交互（Interactive）</li>
</ul>
</li>
<li><p>JavaScript 的运行环境？</p>
<ul>
<li>是不是运行在浏览器呢？</li>
<li>不够严谨</li>
<li>运行在浏览器内核中的 JS 引擎（engine）</li>
</ul>
</li>
<li><p>浏览器中的 JavaScript 可以做什么？</p>
<ul>
<li>操作DOM（对DOM的增删改、注册事件）</li>
<li>AJAX/跨域</li>
<li>BOM（页面跳转、历史记录、console.log()、alert()）</li>
<li>ECMAScript</li>
</ul>
</li>
<li><p>浏览器中的 JavaScript 不可以做什么？</p>
<ul>
<li>文件操作（文件和文件夹的CRUD）</li>
<li>没有办法操作系统信息</li>
<li>由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行）</li>
</ul>
</li>
<li><p>在开发人员能力相同的情况下编程语言的能力取决于什么？</p>
<ul>
<li>-语言本身？-</li>
<li>语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作</li>
<li>取决于运行该语言的平台（环境）</li>
<li>对于JS来说，我们常说的JS实际是ES，大部分能力都是由浏览器的执行引擎决定</li>
<li>BOM和DOM可以说是浏览器开放出来的接口</li>
<li><p>比如：Cordova中提供JS调用摄像头，操作本地文件的API</p>
</li>
<li><p>Java既是语言也是平台</p>
</li>
<li>Java运行在Java虚拟机（跨操作系统）</li>
<li><p>PHP既是语言也是平台（跨操作系统）</p>
</li>
<li><p>C#语言平台：.NET Framework（Windows）</p>
</li>
<li>C#可以运行在MONO这样的平台</li>
<li>因为有人需要将C#运行在Linux平台，所有出现了MONO</li>
</ul>
</li>
</ul>
<ul>
<li>JavaScript 只可以运行在浏览器中吗？<ul>
<li>不是</li>
<li>能运行在哪取决于，这个环境有没有特定平台</li>
</ul>
</li>
</ul>
<h3 id="什么是Node"><a href="#什么是Node" class="headerlink" title="什么是Node"></a>什么是Node</h3><ul>
<li>Node 就是 JavaScript 语言在服务器端的运行环境</li>
<li>所谓“运行环境（平台）”有两层意思：<ul>
<li>首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机；</li>
<li>其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。</li>
</ul>
</li>
</ul>
<h3 id="为什么是JavaScript"><a href="#为什么是JavaScript" class="headerlink" title="为什么是JavaScript"></a>为什么是JavaScript</h3><h3 id="Node的实现结构"><a href="#Node的实现结构" class="headerlink" title="Node的实现结构"></a>Node的实现结构</h3><h3 id="Node在当下Web开发领域的应用"><a href="#Node在当下Web开发领域的应用" class="headerlink" title="Node在当下Web开发领域的应用"></a>Node在当下Web开发领域的应用</h3><h3 id="哪些公司在用"><a href="#哪些公司在用" class="headerlink" title="哪些公司在用"></a>哪些公司在用</h3><h3 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h3><ul>
<li>Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架；</li>
<li>Node的实现结构；</li>
<li>Node可以用来开发服务端应用程序，Web系统；</li>
<li>基于Node的前端工具集</li>
</ul>
<hr>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装包的方式安装"><a href="#安装包的方式安装" class="headerlink" title="安装包的方式安装"></a>安装包的方式安装</h3><ul>
<li>安装包下载链接：<ul>
<li>Mac OSX： <a href="http://npm.taobao.org/mirrors/node/v5.7.0/node-v5.7.0.pkg" target="_blank" rel="external">darwin</a></li>
<li>Windows：<ul>
<li><a href="http://npm.taobao.org/mirrors/node/v5.7.0/node-v5.7.0-x64.msi" target="_blank" rel="external">x64</a></li>
<li><a href="http://npm.taobao.org/mirrors/node/v5.7.0/node-v5.7.0-x86.msi" target="_blank" rel="external">x86</a></li>
</ul>
</li>
</ul>
</li>
<li>安装操作：<ul>
<li>一路<em>Next</em></li>
</ul>
</li>
</ul>
<h3 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h3><ul>
<li>操作方式：<ul>
<li>重新下载最新的安装包；</li>
<li>覆盖安装即可；</li>
</ul>
</li>
<li>问题：<ul>
<li>以前版本安装的很多全局的工具包需要重新安装</li>
<li>无法回滚到之前的版本</li>
<li>无法在多个版本之间切换（很多时候我们要使用特定版本）</li>
</ul>
</li>
</ul>
<h3 id="NVM工具的使用"><a href="#NVM工具的使用" class="headerlink" title="NVM工具的使用"></a>NVM工具的使用</h3><blockquote>
<p>Node Version Manager（Node版本管理工具）</p>
</blockquote>
<p>由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理</p>
<h4 id="安装操作步骤"><a href="#安装操作步骤" class="headerlink" title="安装操作步骤"></a>安装操作步骤</h4><ol>
<li>下载：<a href="https://github.com/coreybutler/nvm-windows/releases/download/1.1.0/nvm-noinstall.zip">nvm-windows</a></li>
<li>解压到一个全英文路径</li>
<li><p>编辑解压目录下的<code>settings.txt</code>文件（不存在则新建）</p>
<ul>
<li><code>root 配置为当前 nvm.exe 所在目录</code></li>
<li><code>path 配置为 node 快捷方式所在的目录</code></li>
<li><code>arch 配置为当前操作系统的位数（32/64）</code></li>
<li><code>proxy 不用配置</code></li>
</ul>
</li>
<li><p>配置环境变量 可以通过 window+r  : sysdm.cpl</p>
<ul>
<li><code>NVM_HOME = 当前 nvm.exe 所在目录</code></li>
<li><code>NVM_SYMLINK = node 快捷方式所在的目录</code></li>
<li><code>PATH += %NVM_HOME%;%NVM_SYMLINK%;</code></li>
<li>打开CMD通过<code>set [name]</code>命令查看环境变量是否配置成功</li>
<li>PowerShell中是通过<code>dir env:[name]</code>命令</li>
</ul>
</li>
<li><p>NVM使用说明：</p>
<ul>
<li><a href="https://github.com/coreybutler/nvm-windows/">https://github.com/coreybutler/nvm-windows/</a></li>
</ul>
</li>
<li><p>NPM的目录之后使用再配置</p>
</li>
</ol>
<h3 id="配置Python环境"><a href="#配置Python环境" class="headerlink" title="配置Python环境"></a>配置Python环境</h3><blockquote>
<p>Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译<br>确保全局环境中可以使用python命令</p>
</blockquote>
<h3 id="环境变量的概念"><a href="#环境变量的概念" class="headerlink" title="环境变量的概念"></a>环境变量的概念</h3><blockquote>
<p>环境变量就是操作系统提供的系统级别用于存储变量的地方</p>
</blockquote>
<ul>
<li>Windows中环境变量分为系统变量和用户变量</li>
<li>环境变量的变量名是不区分大小写的</li>
<li>特殊值：<ul>
<li>PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下搜索</li>
</ul>
</li>
</ul>
<h3 id="Windows下常用的命令行操作"><a href="#Windows下常用的命令行操作" class="headerlink" title="Windows下常用的命令行操作"></a>Windows下常用的命令行操作</h3><ul>
<li>切换当前目录（change directory）：cd</li>
<li>创建目录（make directory）：mkdir</li>
<li>查看当前目录列表（directory）：dir<ul>
<li>别名：ls（list）</li>
</ul>
</li>
<li>清空当前控制台：cls<ul>
<li>别名：clear</li>
</ul>
</li>
<li>删除文件：del<ul>
<li>别名：rm</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：所有别名必须在新版本的 PowerShell 中使用</p>
</blockquote>
<hr>
<blockquote>
<p>事件驱动和非阻塞、模块化、核心模块、NPM</p>
</blockquote>
<hr>
<h2 id="事件驱动和非阻塞"><a href="#事件驱动和非阻塞" class="headerlink" title="事件驱动和非阻塞"></a>事件驱动和非阻塞</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// $.ajax()</span></div><div class="line"></div><div class="line"><span class="comment">// $.get('/users/list',&#123;order:'id'&#125;)</span></div><div class="line"></div><div class="line"><span class="comment">// $.get('/delete/user', &#123;id:10&#125;)</span></div><div class="line"><span class="comment">//   .success(function(data)&#123;</span></div><div class="line"><span class="comment">//     console.log(11);</span></div><div class="line"><span class="comment">//   &#125;)</span></div><div class="line"><span class="comment">//   .error(function(error)&#123;</span></div><div class="line">    </div><div class="line"><span class="comment">//   &#125;);</span></div><div class="line"></div><div class="line">$.get(<span class="string">''</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(err)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SCSS]]></title>
      <url>https://github.com/yanlee26/blog/2016/09/24/scss/</url>
      <content type="html"><![CDATA[<h1 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h1><h3 id="get-started…"><a href="#get-started…" class="headerlink" title="get started…"></a>get started…</h3><ol>
<li>变量<blockquote>
<p>定义变量以便于维护</p>
</blockquote>
</li>
</ol>
<p><code>$fontStack:    Helvetica, sans-serif;
$primaryColor: #333;
body {
  font-family: $fontStack;
  color: $primaryColor;
}
// css
body {
  font-family: Helvetica, sans-serif;
  color: #333;
}</code></p>
<ol>
<li>嵌套<blockquote>
<p>选择器嵌套，层次分明</p>
</blockquote>
</li>
</ol>
<p>`<br>nav {<br>  ul {<br>    margin: 0;<br>    padding: 0;<br>    list-style: none;<br>  }<br>  li { display: inline-block; }<br>  a {<br>    display: block;<br>    padding: 6px 12px;<br>    text-decoration: none;<br>  }<br>}<br>//css<br>nav ul {<br>  margin: 0;<br>  padding: 0;<br>  list-style: none;<br>}</p>
<p>nav li {<br>  display: inline-block;<br>}</p>
<p>nav a {<br>  display: block;<br>  padding: 6px 12px;<br>  text-decoration: none;<br>}<br>`</p>
<ol>
<li>导入<blockquote>
<p>导入其它sass文件，优于css的@import</p>
</blockquote>
</li>
</ol>
<p><code>//_reset.scss
html,
body,
ul,
ol {
   margin: 0;
  padding: 0;
}
//base.scss
@import &#39;reset&#39;;
body {
  font-size: 100% Helvetica, sans-serif;
  background-color: #efefef;
}</code></p>
<ol>
<li>mixin<blockquote>
<p>让css3的编写锦上添花</p>
</blockquote>
</li>
</ol>
<p><code>@mixin box-sizing ($sizing) {
    -webkit-box-sizing:$sizing;     
       -moz-box-sizing:$sizing;
            box-sizing:$sizing;
}
.box-border{
    border:1px solid #ccc;
    @include box-sizing(border-box);
}
//css
.box-border {
  border: 1px solid #ccc;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}</code></p>
<ol>
<li>扩展/继承<blockquote>
<p>@extend 优雅实现代码组合声明</p>
</blockquote>
</li>
</ol>
<p>`<br>.message {<br>  border: 1px solid #ccc;<br>  padding: 10px;<br>  color: #333;<br>}<br>.success {<br>  @extend .message;<br>  border-color: green;<br>}<br>.error {<br>  @extend .message;<br>  border-color: red;<br>}<br>//css<br>.message, .success, .error, .warning {<br>  border: 1px solid #cccccc;<br>  padding: 10px;<br>  color: #333;<br>}</p>
<p>.success {<br>  border-color: green;<br>}</p>
<p>.error {<br>  border-color: red;<br>}</p>
<p>.warning {<br>  border-color: yellow;<br>}<br>`</p>
<ol>
<li>四则运算<br>`<br>.container { width: 100%; }</li>
</ol>
<p>article[role=”main”] {<br>  float: left;<br>  width: 600px / 960px * 100%;<br>}</p>
<p>aside[role=”complimentary”] {<br>  float: right;<br>  width: 300px / 960px * 100%;<br>}<br>//css<br>.container {<br>  width: 100%;<br>}</p>
<p>article[role=”main”] {<br>  float: left;<br>  width: 62.5%;<br>}</p>
<p>aside[role=”complimentary”] {<br>  float: right;<br>  width: 31.25%;<br>}<br>`</p>
<ol>
<li>颜色变换<br><code>$linkColor: #08c;
a {
 text-decoration:none;
 color:$linkColor;
 &amp;:hover{
   color:darken($linkColor,10%);
 }
}
//css
a {
text-decoration: none;
color: #0088cc;
}
a:hover {
color: #006699;
}</code><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li>
<li>文件后缀名<ul>
<li>sass:不使用{}及；</li>
<li>scss:同css，首选</li>
</ul>
</li>
<li>导入<code>@import</code><blockquote>
<p>导入css和css用法一样不再编译，导入scss会合并编译</p>
</blockquote>
</li>
<li>注释<code>标准注释/**/，编译到css；单行注释//不编译</code></li>
<li>变量<blockquote>
<p>$开头紧跟变量名，变量名值以：分隔，！表示默认值</p>
</blockquote>
</li>
</ol>
<p>`<br>$fontSize: 12px;<br>body{<br>    font-size:$fontSize;<br>}<br>$baseLineHeight:        2;</p>
<p>$baseLineHeight:        1.5 !default;<br>body{<br>    line-height: $baseLineHeight;<br>}<br>//css<br>body{<br>    line-height:2;<br>}<br>//特殊变量：变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用<br>$borderDirection:       top !default;<br>$baseFontSize:          12px !default;<br>$baseLineHeight:        1.5 !default;</p>
<p>//应用于class和属性<br>.border-#{$borderDirection}{<br>  border-#{$borderDirection}:1px solid #ccc;<br>}<br>//应用于复杂的属性值<br>body{<br>    font:#{$baseFontSize}/#{$baseLineHeight};<br>}<br>`</p>
<ol>
<li><p>多值变量</p>
<blockquote>
<p>多值类型分list和map类型，list类似js数组，map类似对象<br>`<br>$linkColor:         #08c #333 !default;//第一个值为默认值，第二个鼠标滑过值<br>a{<br>color:nth($linkColor,1);</p>
</blockquote>
<p>&amp;:hover{<br> color:nth($linkColor,2);<br>}<br>}<br>//css<br>a{<br>color:#08c;<br>}<br>a:hover{<br>color:#333;<br>}<br>$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);<br>@each $header, $size in $headings {<br>#{$header} {<br> font-size: $size;<br>}<br>}<br>//css<br>h1 {<br>font-size: 2em;<br>}<br>h2 {<br>font-size: 1.5em;<br>}<br>h3 {<br>font-size: 1.2em;<br>}<br>`</p>
</li>
<li>全局变量：！global</li>
<li>嵌套与挑出@at-root,@at-root (without: …)和@at-root (with: …)</li>
<li>混合@mixin<br>`<br>@mixin center-block {<br> margin-left:auto;<br> margin-right:auto;<br>}<br>.demo{<br> @include center-block;<br>}<br>@mixin opacity($opacity:50) {<br>opacity: $opacity / 100;<br>filter: alpha(opacity=$opacity);<br>}<br>@mixin opacity($opacity:50) {<br>opacity: $opacity / 100;<br>filter: alpha(opacity=$opacity);<br>}</li>
</ol>
<p>//css style<br>.opacity{<br>  @include opacity; //参数使用默认值<br>}<br>.opacity-80{<br>  @include opacity(80); //传递参数<br>}<br>//多个参数<br>@mixin horizontal-line($border:1px dashed #ccc, $padding:10px){<br>    border-bottom:$border;<br>    padding-top:$padding;<br>    padding-bottom:$padding;<br>}<br>.imgtext-h li{<br>    @include horizontal-line(1px solid #ccc);<br>}<br>.imgtext-h–product li{<br>    @include horizontal-line($padding:15px);<br>}<br>//@content<br>@mixin max-screen($res){<br>  @media only screen and ( max-width: $res )<br>  {<br>    @content;<br>  }<br>}</p>
<p>@include max-screen(480px) {<br>  body { color: red }<br>}<br>`</p>
<ol>
<li>继承@extent</li>
<li>占位选择器%<blockquote>
<p>如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中<br>不管是否使用了@extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过@extend调用。</p>
</blockquote>
</li>
</ol>
<p>`<br>%ir{<br>  color: transparent;<br>  text-shadow: none;<br>  background-color: transparent;<br>  border: 0;<br>}<br>%clearfix{<br>  @if $lte7 {<br>    *zoom: 1;<br>  }<br>  &amp;:before,<br>  &amp;:after {<br>    content: “”;<br>    display: table;<br>    font: 0/0 a;<br>  }<br>  &amp;:after {<br>    clear: both;<br>  }<br>}</p>
<p>#header{<br>  h1{<br>    @extend %ir;<br>    width:300px;<br>  }<br>}<br>.ir{<br>  @extend %ir;<br>}<br>//css</p>
<p>#header h1,<br>.ir{<br>  color: transparent;<br>  text-shadow: none;<br>  background-color: transparent;<br>  border: 0;<br>}<br>`</p>
<ol>
<li>函数<br>`<br>$baseFontSize:      10px !default;<br>$gray:              #ccc !defualt;        </li>
</ol>
<p>// pixels to rems<br>@function pxToRem($px) {<br>  @return $px / $baseFontSize * 1rem;<br>}</p>
<p>body{<br>  font-size:$baseFontSize;<br>  color:lighten($gray,10%);<br>}<br>.test{<br>  font-size:pxToRem(16px);<br>  color:darken($gray,10%);<br>}<br>`</p>
<ol>
<li>运算<br>$baseFontSize:          14px !default;<br>$baseLineHeight:        1.5 !default;<br>$baseGap:               $baseFontSize * $baseLineHeight !default;<br>$halfBaseGap:           $baseGap / 2  !default;<br>$samllFontSize:         $baseFontSize - 2px  !default;</li>
</ol>
<p>//grid<br>$_columns:                     12 !default;      // Total number of columns<br>$_column-width:                60px !default;   // Width of a single column<br>$_gutter:                      20px !default;     // Width of the gutter<br>$_gridsystem-width:            $_columns * ($_column-width + $_gutter); //grid system width<code>
</code></p>
<ol>
<li>条件和循环<br>`<br>$lte7: true;<br>$type: monster;<br>.ib{<br>display:inline-block;<br>@if $lte7 {<pre><code>*display:inline;
*zoom:1;
</code></pre>}<br>}<br>p {<br>@if $type == ocean {<br>color: blue;<br>} @else if $type == matador {<br>color: red;<br>} @else if $type == monster {<br>color: green;<br>} @else {<br>color: black;<br>}<br>}<br>//css<br>.ib{<br>display:inline-block;<br><em>display:inline;
</em>zoom:1;<br>}<br>p {<br>color: green;<br>}<br>//三目运算<br>if($condition, $if_true, $if_false)<br>//for:@for $var from <start> through <end>和@for $var from <start> to <end><br>@for $i from 1 through 3 {<br>.item-#{$i} { width: 2em * $i; }<br>}<br>//css<br>.item-1 {<br>width: 2em;<br>}<br>.item-2 {<br>width: 4em;<br>}<br>.item-3 {<br>width: 6em;<br>}<br>//each:@each $var in <list or="" map=""><br>$animal-list: puma, sea-slug, egret, salamander;<br>@each $animal in $animal-list {<br>.#{$animal}-icon {<br>background-image: url(‘/images/#{$animal}.png’);<br>}<br>}<br>`</list></end></start></end></start></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Prefesional JS]]></title>
      <url>https://github.com/yanlee26/blog/2016/06/08/Prefessional%20JS/</url>
      <content type="html"><![CDATA[<h1 id="JS高级教程总结"><a href="#JS高级教程总结" class="headerlink" title="JS高级教程总结"></a>JS高级教程总结</h1><h3 id="Chapter3-基本概念"><a href="#Chapter3-基本概念" class="headerlink" title="Chapter3 基本概念"></a>Chapter3 基本概念</h3><ul>
<li>3.4数据类型</li>
</ul>
<ol>
<li>五种简单类型（基本数据类型）：<br>Null,Undefined,String,Number,Boolean，symbol（ES6）<blockquote>
<p>判断：<code>typeof</code></p>
</blockquote>
</li>
</ol>
<p>1.1 Undefined:undefined</p>
<blockquote>
<p>变量声明而未初始化（显式初始化变量是好习惯）</p>
</blockquote>
<p>1.2 Null:null</p>
<blockquote>
<p>空指针，此即typeof（null）===undefined的根本原因</p>
<ul>
<li>由于ES数据类型具有动态性，故没必要定义其它类型 </li>
</ul>
<ol>
<li>一种对象类型：Object（一组数据和功能的集合）<br>判断:<code>instanceof</code><br>ES 中Object类型是所有其它实例的基础，Object类型所<br>具有的所有属性和方法同样存在于具体对象中</li>
</ol>
</blockquote>
<p><code>constructor:保存用于创建当前对象的函数（构造函数即Object）
hasOwnProperty():检查给定的属性是否在当前对象实例中
isPrototypeOf():检查传入的对象是否是传入对象的原型
propertyIsEnumerable():是否可通过for-in枚举
toLocalString():返回对象字符串表示（与本区对应）
toString():返回对象字符串表示
valueOf():返回对象的字符串，数值或者布尔值表示。同toString</code></p>
<ul>
<li>3.5操作符</li>
</ul>
<ol>
<li>一元操作符<blockquote>
<p>1.递增递减：++a,a++: 前/后置操作时决定变量值在执行操作前/后改变<br>2.加减：a+=n,a-=n<br>3.位操作符：NOT(~),OR(|),AND(&amp;),XOR(^),(&lt;&lt;),(&gt;&gt;),(&gt;&gt;&gt;)<br>4.布尔操作符：!,&amp;&amp;,||<br>5.算术性操作符：+-<em>/<br>6.关系操作符：&gt;,&lt;<br>7.相等操作符 ：<br> a.相等与否（操作数成立则true）：==,!=<br> b.全等与否（比较之前不转换操作数）：===,!==<br>8.条件操作符：variable=boolean_expression?true_value:false_value<br>9.赋值操作符：+=，-=，</em>=，/=，%=，&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=<br>10.逗号操作符：var a,b,c</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>语句</p>
<blockquote>
<ol>
<li>if(condition) statement1 else statement2</li>
<li>do{statement}while(expression)</li>
<li>while(expression) statement</li>
<li>for(initialization;expression;post-loop-expression) statement</li>
<li>for(property in expression) statement</li>
<li>label:statement</li>
<li>break/continue:break 立即跳出循环（强制继续执行循环后语句），continue立即退出<br>循环（当前循环），但从循环顶部继续执行</li>
<li>with(expression) statement</li>
<li>switch(expression){<br>case value:statement1<br>break;<br>case value:statement2<br>break;<br>…<br>case default<br>break;<br>}</li>
</ol>
</blockquote>
</li>
<li><p>3.7 函数-可以封装任意条语句，在任何地方任何时候执行</p>
<blockquote>
<p>没有重载：可以为一函数编写两个定义，只要定义的签名（接受的参数类型和数量）不同即可<br>ES中函数没有签名，真正重载不可能做到只能模拟<br>function add(n){<br>return n+100<br>}<br>function add(n){<br>return n+200<br>}//覆盖掉上一个<br>var result=add(100);//300</p>
</blockquote>
</li>
</ul>
<h3 id="Chapter4-变量作用域及内存"><a href="#Chapter4-变量作用域及内存" class="headerlink" title="Chapter4 变量作用域及内存"></a>Chapter4 变量作用域及内存</h3><blockquote>
<p>JS 变量松散的本质决定了它只是在特定时间用于保存特定值的一个名字而已</p>
</blockquote>
<p>4.1 基本类型（简单的数据段）和引用类型（可能有多个值构成的对象）</p>
<blockquote>
<p>因可以操作保存在变量中的实际值，基本数据类型按值访问；<br>引用类型值保存在内存中，不同于其它语言，JS不允许直接访问内存中的位置（操作实际对象）。<br>当复制保存着某个变量时，操作的是对象的引用；但在为对象添加属性时，操作的是实际的对象<br>访问变量的方式有按值和按引用两种，而参数只能按值传递。ES中所有函数的参数都是按值传递的！<br><a href="https://q.cnblogs.com/q/39352/" target="_blank" rel="external">JS函数参数按值传递的</a><br><code>function setName(obj){obj.name=&#39;yl&#39;;obj={};obj.name=&#39;hello&#39;} 
var p={};setName(p);p.name;//&#39;yl&#39;
//即使在内部修改了参数的值，但原始的引用仍然不变。实际上，当函数内部重写obj时，该变量引用的就是
一个在函数执行完立即销毁的局部变量了。完全可以把ES函数的参数想象成局部变量</code><br>执行环境和作用域（execution context&amp; scope）<br>EC:决定了变量或函数有权访问的其它数据，决定了它们各自的行为；每个EC都有一个与之关联的变量对象（vo）<br>,环境中定义的所有变量和函数都保存在这个对象中。虽然无法访问该对象，但解析器在处理数据时会在后台使用它。<br>某个执行环境中的所有代码执行完毕后，该环境被销毁，其中的所有变量和函数定义也随之而去。<br>每个函数都有自己的执行环境，当执行流进入一个函数时，函数环境就会被推入一个环境栈中；函数执行之后，栈将其<br>弹出，把控制权返回给之前的执行环境。<br>Scope:当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）,以保证对执行环境有权访问的<br>所有变量和函数的有序访问。其前端始终是当前执行的代码所在环境的变量对象。全局执行环境的变量对象始终都是作用<br>域链中的最后一个对象。<br>这些环境之间的联系是线性的有次序的，每个环境都可以向上搜索sc，以查询变量和函数名；但反之不行。<br>那sc可以延长吗？ 可以。。。<br>利用try-catch,with语句</p>
</blockquote>
<p>4.2 无块级作用域</p>
<blockquote>
<p>1.声明变量：使用var声明的变量会自动被添加到最近的执行环境中（在函数内部是局部环境，with语句中是<br>函数环境，如果忘记var则被添加到全局环境）2.查询标识符：当在某个环境中为了读取或写入而引用一个标识符<br> 时，必须通过搜索来确定标识符实际代表什么。</p>
</blockquote>
<p>4.3 垃圾回收GC</p>
<blockquote>
<p>标记清除(mark-sweep)和引用计数(reference-counting)<br>mark-sweep:变量进入环境即将变量标记为‘进入环境’，逻辑上永远无法释放进入环境变量所占用的内存；当变量<br>离开时，记‘离开环境’</p>
</blockquote>
<h3 id="Chapter-5-引用类型"><a href="#Chapter-5-引用类型" class="headerlink" title="Chapter 5 引用类型"></a>Chapter 5 引用类型</h3><blockquote>
<p>引用类型的值（对象）是引用类型的一个实例，ES中引用类型是用于将数据和功能组织在一起的一种数据结构。<br>常被不妥当地称为类，有时候也称对象定义。</p>
</blockquote>
<p>5.1 Object<br>5.2 Array</p>
<ul>
<li>检测：Array.isArray();instanceof Array</li>
<li>转换：toString(),join()方法</li>
<li>栈方法：push,pop</li>
<li>队列方法：shift,unshift</li>
<li>排序sort(),reverse()</li>
<li>操作方法：concat(),splice()<br>  a. delete:splice(0,2);b:insert:splice(0,2,’red’,’blue’);c:replace:splice(2,1,’a’,’b’)</li>
<li>位置方法：indexOf(),lastIndexOf()</li>
<li>迭代方法：every(),filter(),map(),forEach(),some()</li>
<li>归并：reduce(),reduceRight()<br>5.3 Date:<br>Date.parse():接收一个表示日期字符串的参数，然后尝试解析成毫秒数<br>Date.UTC()：同样返回时间戳，在构建时与parse使用不同的信息。<blockquote>
<p>日期和时间都是基于本地时区而非GMT来创建</p>
</blockquote>
</li>
</ul>
<p>5.4 RegExp<br>5.5 Function</p>
<blockquote>
<p>ES中函数即对象，每个函数都是Function的一个实例，函数名是指向函数对象的一个指针，与其它引用类型一样有属性和方法</p>
<ul>
<li>5.5.1 没有重载<br>上述重载案例与下边等价：<br><code>var add=function(n){return n+100};
add=function(n){return n+200}//覆盖上个</code></li>
<li>5.5.2函数声明与函数表达式<br>js引擎（解析器）会率先读取函数声明，并使其在执行任何代码之前可用；而对<br>函数表达式则同解析普通语句一样，等到解析器执行到其所在代码行，才被解释执行。</li>
<li>5.5.3 作为值的函数（ES中函数也是变量，所以可作为值使用）<br>`<br>function createComparisonFunction(propertyName) {<pre><code>return function(object1, object2){
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
</code></pre></li>
</ul>
</blockquote>
<pre><code>        if (value1 &lt; value2){
            return -1;
        } else if (value1 &gt; value2){
            return 1;
        } else {
            return 0;
        }
    };
}
var data = [{name: &quot;Zachary&quot;, age: 28}, {name: &quot;Nicholas&quot;, age: 29}];
data.sort(createComparisonFunction(&quot;name&quot;));
alert(data[0].name);  //Nicholas
data.sort(createComparisonFunction(&quot;age&quot;));
alert(data[0].name);  //Zachary     
</code></pre><p>`</p>
<ul>
<li>5.5.4 函数内部属性：arguments，this</li>
<li>5.5.5 函数属性和方法<blockquote>
<p>每个函数都包含两个属性：length（函数希望接收的参数个数）和prototype（对ES中引用类型而言，prototype保存了<br>其所有实例的属性和方法，即toString(),valueOf()等方法实际上保存在prototype名下，只不过通过各自对象的实例访问）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>每个函数都包含两个非继承而来的方法：call(),apply():用途是在特定作用域中调用函数，实际上是设置函数体内this指向。<br>ES5中还有一个bind方法，用于创建一个函数实例，其this值会被绑定到<br>传给bind函数的值。</p>
<p>另外每个函数继承的toString(),toLocalString()，valueOf()始终返回函数代码</p>
</blockquote>
<p><code>function sayColor=function(){alert(this.color)}
window.color=&#39;red&#39;;
var o={color:&#39;blue&#39;};
var objSayColor=sayColor.bind(o);
objSayColor();//&#39;blue&#39;</code></p>
<ul>
<li>5.5.6 基本包装对象<blockquote>
<p>ES提供了三个特殊的引用类型（Boolean,Number,String），与其它引用类型类似但也具有各自基本类型相应的行为<br>注意：引用类型和基本类型主要区别就是对象生命周期：使用new操作符创建的引用类型实例，在执行流离开当前作用域之前<br>一直保存在内存中。而自动创建的基本包装对象，只存在于一行代码执行的瞬间，然后立即销毁。即我们不能给基本类型添加<br>属性和方法。<br>Object构造函数如工厂方法一样，根据传入值的类型返回基本包装对象实例</p>
</blockquote>
</li>
</ul>
<p><code>var obj=new Object(&#39;hello&#39;);obj instanceOf String;//true</code></p>
<ul>
<li>5.6.1 Boolean <blockquote>
<p>Boolean实例重写了valueOf()方法并返回true/false；重写了toString()方法，返回’true’/‘false’<br>注意：布尔表达式中所有对象都会被转换为true<br>`</p>
</blockquote>
</li>
</ul>
<p>var a=new Boolean(true)<br>undefined<br>a<br>Boolean {[[PrimitiveValue]]: true}<br>a.toString()<br>“true”<br>a.valueOf()<br>true<br>`</p>
<ul>
<li>5.6.2 Number<blockquote>
<p>方法：toFixed(),toExponential(),toPrecision()</p>
</blockquote>
</li>
<li>5.6.3 String</li>
</ul>
<ol>
<li>字符方法<blockquote>
<p>charAt(),charCodeAt()</p>
</blockquote>
</li>
<li>字符操作方法<blockquote>
<p>concat(),slice(),subString(),substr(),</p>
</blockquote>
</li>
<li>字符串位置方法<blockquote>
<p>indexOf(),lastIndexOf()</p>
</blockquote>
</li>
<li>trim(),trimLeft(),trimRight()方法</li>
<li>大小写转换方法<blockquote>
<p>toLocalUpperCase(),toUpperCase(),toLowerCase()</p>
</blockquote>
</li>
<li>模式匹配方法<blockquote>
<p>search(),replace(),match(),split()</p>
</blockquote>
</li>
<li>localeCompare()方法，fromCharCode()方法</li>
</ol>
<ul>
<li>5.7 单体内置对象<blockquote>
<p>定义：由ES实现提供的不依赖于宿主环境的对象，即在ES程序执行之前既存在了</p>
</blockquote>
</li>
</ul>
<ol>
<li>Global对象（兜底对象，任何不属于其它对象的属性和方法都是它的属性和方法）<blockquote>
<p>如isNaN()，isFinite(),parseInt(),parseFloat(),encodeURI(),encodeURIComponent()<br>eval(),window对象，Math对象（min(),max(),ceil(),floor(),random()）</p>
</blockquote>
</li>
</ol>
<h3 id="Chapter-6-面向对象-Object-Oriented-Programing"><a href="#Chapter-6-面向对象-Object-Oriented-Programing" class="headerlink" title="Chapter 6 面向对象 Object Oriented Programing"></a>Chapter 6 面向对象 Object Oriented Programing</h3><blockquote>
<p>ES对象：包含基本值，对象或函数的无序属性的集合。</p>
</blockquote>
<p>6.1.1 属性类型（数据属性+访问器属性）</p>
<ol>
<li>数据属性：</li>
</ol>
<ul>
<li>[[Configurable]]:是否可配置，delete(true)</li>
<li>[[Enumerable]]: 是否可枚举，for-in(true)</li>
<li>[[Writable]]:是否可写(true)</li>
<li>[[Writable]]:包含这个属性的数据值（undefined）<blockquote>
<p>ES5中Object.defineProperty(object,propertyName,descriptor)方法，包含属性所在对象，属性名，描述符对象三个参数，可以修改对象的默认特性。<br>注意：一旦把属性定义为不可配置的就再也甭能把它设置成可配置的了。</p>
</blockquote>
</li>
</ul>
<ol>
<li>访问器特性，对象的属性：<blockquote>
<p>不包含数据值，包含一对getter，setter函数（非必须），有以下四个特性。访问器属性不能直接定义，必须用<br>Object.defineProperty()定义，Object.defineProperties()可以定义多个属性</p>
</blockquote>
</li>
</ol>
<ul>
<li>[[Configurable]]:同上(true)</li>
<li>[[Enumerable]]:同上(true)</li>
<li>[[Get]]:读取属性时调用的函数（undefined）</li>
<li><p>[[Set]]:写入属性时调用的函数（undefined）<br>`<br>var book = {</p>
<pre><code>    _year: 2004,
    edition: 1
};
Object.defineProperty(book, &quot;year&quot;, {
    get: function(){
        return this._year;
    },
    set: function(newValue){

        if (newValue &gt; 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;

        }
    }
});

book.year = 2005;
alert(book.edition);   //2
</code></pre><p>`<br>6.1.3 读取属性特性</p>
<blockquote>
<p>Object.getOwnPropertyDescriptor()方法，两个参数属性所在的对象+读取其描述符的属性名，返回一对象.<br>JS中可以针对任何对象（BOM，DOM），使用该方法。<br>`<br>var descriptor = Object.getOwnPropertyDescriptor(book, “_year”);</p>
<pre><code>alert(descriptor.value);          //2004
alert(descriptor.configurable);   //false
alert(typeof descriptor.get);     //&quot;undefined&quot;
var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);
alert(descriptor.value);          //undefined
alert(descriptor.enumerable);     //false
alert(typeof descriptor.get);     //&quot;function&quot;`
</code></pre></blockquote>
</li>
</ul>
<p>6.2 创建对象<br>6.2.1 工厂模式—用函数来封装以特定接口创建对象的细节</p>
<blockquote>
<p>特点：虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题(怎样知道对象类型)。<br><code>function createPerson(name, age, job){
            var o = new Object();
            o.name = name;
            o.age = age;
            o.job = job;
            o.sayName = function(){
                alert(this.name);
            };    
            return o;
        }
        var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.sayName();   //&quot;Nicholas&quot;
        person2.sayName();   //&quot;Greg&quot;</code></p>
</blockquote>
<p>6.2.2 构造函数模式—如Object，Array这样的原生构造函数，运行时会自动出现在EC中，也可创建自定义的。<br><code>function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = function(){
                alert(this.name);
            };    
        }
        var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.sayName();   //&quot;Nicholas&quot;
        person2.sayName();   //&quot;Greg&quot;
        alert(person1 instanceof Object);  //true
        alert(person1 instanceof Person);  //true
        alert(person2 instanceof Object);  //true
        alert(person2 instanceof Person);  //true
        alert(person1.constructor == Person);  //true
        alert(person2.constructor == Person);  //true
        alert(person1.sayName == person2.sayName);  //false</code></p>
<blockquote>
<p>特点：没有显式创建对象，没有return语句，直接将属性和方法赋给this，首字母大写，必须使用new构建实例。<br>优点：可以将构造函数的实例标识为一种特定的类型；<br>缺点：每个方法都要在每个实例上创建一遍，不同实例上同名函数是不同的。<br><code>this.sayName=new Function(&#39;alert(this.name)&#39;);//与声明函数逻辑上等价
person1.sayName===person2.sayName;//false
//优化，但此时全局函数有些名不副实
this.sayName=sayName;
function sayName(){}</code></p>
</blockquote>
<p>6.2.3 原型模式</p>
<blockquote>
<p>我们创建的每个函数，都有一个指向一个对象的且是一个指针的prototype属性，其作用是包含可以有特定<br>类型所有实例共享的属性和方法。即prototype通过调用构造函数而创建的那个实例的原型对象。此时可以将所有实例共享其所包含的属性和方法。<br>优点：让任意实例共享其原型对象所包含的所有属性和方法。<br>缺点：省略了为构造函数传递初始化参数这一环节，导致所有实例默认获得相同属性，对于包含引用类型的属性而言，问题不可忽视</p>
</blockquote>
<p>`<br>//原型模式案例<br>function Person(){<br>        }<br>        Person.prototype.name = “Nicholas”;<br>        Person.prototype.age = 29;<br>        Person.prototype.job = “Software Engineer”;<br>        Person.prototype.sayName = function(){<br>            alert(this.name);<br>        };</p>
<pre><code>var person1 = new Person();
person1.sayName();   //&quot;Nicholas&quot;

var person2 = new Person();
person2.sayName();   //&quot;Nicholas&quot;

alert(person1.sayName == person2.sayName);  //true

alert(Person.prototype.isPrototypeOf(person1));  //true
alert(Person.prototype.isPrototypeOf(person2));  //true

//only works if Object.getPrototypeOf() is available
if (Object.getPrototypeOf){
    alert(Object.getPrototypeOf(person1) == Person.prototype);  //true
    alert(Object.getPrototypeOf(person1).name);  //&quot;Nicholas&quot;
}
//虽然可以通过实例访问原型中的值，但不能通过对象实例重写原型中的值。只是‘屏蔽’
person1.name = &quot;Greg&quot;;
alert(person1.name);   //&quot;Greg&quot; – from instance
alert(person2.name);   //&quot;Nicholas&quot; – from prototype
//使用delete操作符完全可以删除该属性
delete person1.name;
alert(person1.name);   //&quot;Nicholas&quot; - from the prototype
//hasOwnProperty（）,in操作符结合
function hasPrototypeProperty(object,name){return !object.hasOwnProperty(name)&amp;&amp;(name in object)}
//ES5中的Object.keys()方法用于取得对象上所有可枚举的对象属性，接收一个对象为参数返回一个包含所有可枚举属性的字符串数组
var keys=Object.keys(Person.prototype)
//简化的原型语法,对象字面量形式创建的对象，但此时constructor不再指向Person了
//此种写法本质上重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object）
Person.prototype={
constructor:Person,//加上此句话重设constructor，此举导致constructor的[[Enumerable]]被设置为true，默认false
 name:&apos;Tom&apos;,
 age:&apos;18&apos;,
 say:function(){}
}
//要消除此bug还需要再加这句话
Object.defineProperty(Person.prptotype,&apos;constructor&apos;,{
enumerable:false,
value:Person
})
//原生对象的原型
Array.prototype===[].__proto__
String.prototype===&apos;&apos;.__proto__
Object.prototype==={}.__proto__
//此方法困境
 Person.prototype = {
            constructor: Person,
            name : &quot;Nicholas&quot;,
            age : 29,
            job : &quot;Software Engineer&quot;,
            friends : [&quot;Shelby&quot;, &quot;Court&quot;],
            sayName : function () {
                alert(this.name);
            }
        };
        var person1 = new Person();
        var person2 = new Person();
        person1.friends.push(&quot;Van&quot;);
        alert(person1.friends);    //&quot;Shelby,Court,Van&quot;
        alert(person2.friends);    //&quot;Shelby,Court,Van&quot;
        alert(person1.friends === person2.friends);  //true
</code></pre><p>`<br>6.2.4 组合使用构造函数和原型模式—用途广泛，认可度最高，首选</p>
<p><code>function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];
        }
        Person.prototype = {
            constructor: Person,
            sayName : function () {
                alert(this.name);
            }
        };
        var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.friends.push(&quot;Van&quot;);
        alert(person1.friends);    //&quot;Shelby,Court,Van&quot;
        alert(person2.friends);    //&quot;Shelby,Court&quot;
        alert(person1.friends === person2.friends);  //false
        alert(person1.sayName === person2.sayName);  //true</code><br>6.2.5 动态原型模式</p>
<blockquote>
<p>把所有信息封装在构造函数中，通过构造函数初始化原型，保持了同时使用构造函数和原型的优点。即<br>可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型.<br>谨记：此时不能使用对象字面量重写原型，否则会切断实例与新原型之间的联系</p>
</blockquote>
<p>`<br>function Person(name, age, job){</p>
<pre><code>    //properties
    this.name = name;
    this.age = age;
    this.job = job;

    //methods
    if (typeof this.sayName != &quot;function&quot;){

        Person.prototype.sayName = function(){
            alert(this.name);
        };

    }
}
var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
friend.sayName();
</code></pre><p>`<br>6.2.6 寄生构造函数模式</p>
<blockquote>
<p>返回的对象与构造函数或者构造函数与原型属性之间没关系。</p>
</blockquote>
<p>`<br>function SpecialArray(){       </p>
<pre><code>    //create the array
    var values = new Array();

    //add the values
    values.push.apply(values, arguments);

    //assign the method
    values.toPipedString = function(){
        return this.join(&quot;|&quot;);
    };

    //return it
    return values;        
}

var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);
alert(colors.toPipedString()); //&quot;red|blue|green&quot;
alert(colors instanceof SpecialArray);
</code></pre><p>`<br>6.2.7 稳妥构造函数模式</p>
<p><code>function Person(name,age,job){
var o=new Object;
o.sayName=function(){alert(name)}
return o
}
var p1=new Person(&#39;yl&#39;,26,&#39;software engineer&#39;);
p1.sayName();//&#39;yl&#39;</code><br>6.3 继承（接口继承和实现继承（ES仅支持此继承））—依赖原型链继承<br>6.3.1 原型链</p>
<blockquote>
<p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<p>`<br> function SuperType(){<br>            this.property = true;<br>        }</p>
<pre><code>SuperType.prototype.getSuperValue = function(){
    return this.property;
};

function SubType(){
    this.subproperty = false;
}

//inherit from SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function (){
    return this.subproperty;
};

var instance = new SubType();
alert(instance.getSuperValue());   //true

alert(instance instanceof Object);      //true
alert(instance instanceof SuperType);   //true
alert(instance instanceof SubType);     //true

alert(Object.prototype.isPrototypeOf(instance));    //true
alert(SuperType.prototype.isPrototypeOf(instance)); //true
alert(SubType.prototype.isPrototypeOf(instance));   //true
</code></pre><p>`<br>6.3.2 借用构造函数</p>
<p>`<br> function SuperType(){<br>            this.colors = [“red”, “blue”, “green”];<br>        }</p>
<pre><code>function SubType(){  
    //inherit from SuperType
    SuperType.call(this);
}
//传递参数
 function SubType(){  
            //inherit from SuperType passing in an argument
            SuperType.call(this, &quot;Nicholas&quot;);

            //instance property
            this.age = 29;
        }

var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);    //&quot;red,blue,green,black&quot;

var instance2 = new SubType();
alert(instance2.colors);    //&quot;red,blue,green&quot;
</code></pre><p>`<br>6.3.3 组合继承</p>
<blockquote>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承<br>`<br>function SuperType(name){<br>            this.name = name;<br>            this.colors = [“red”, “blue”, “green”];<br>        }</p>
</blockquote>
<pre><code>SuperType.prototype.sayName = function(){
    alert(this.name);
};

function SubType(name, age){  
    SuperType.call(this, name);

    this.age = age;
}

SubType.prototype = new SuperType();

SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType(&quot;Nicholas&quot;, 29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);  //&quot;red,blue,green,black&quot;
instance1.sayName();      //&quot;Nicholas&quot;;
instance1.sayAge();       //29

var instance2 = new SubType(&quot;Greg&quot;, 27);
alert(instance2.colors);  //&quot;red,blue,green&quot;
instance2.sayName();      //&quot;Greg&quot;;
instance2.sayAge();       //27
</code></pre><p>`<br>6.3.4 原型式继承</p>
<p>`<br>var person = {<br>            name: “Nicholas”,<br>            friends: [“Shelby”, “Court”, “Van”]<br>        };</p>
<pre><code>var anotherPerson = Object.create(person);
anotherPerson.name = &quot;Greg&quot;;
anotherPerson.friends.push(&quot;Rob&quot;);

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = &quot;Linda&quot;;
yetAnotherPerson.friends.push(&quot;Barbie&quot;);

alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;
</code></pre><p>`<br>6.3.5 寄生式继承</p>
<p>`</p>
<p>`<br>6.3.6 寄生组合式继承</p>
<p>`<br>function object(o){<br>            function F(){}<br>            F.prototype = o;<br>            return new F();<br>        }</p>
<pre><code>function inheritPrototype(subType, superType){
    var prototype = object(superType.prototype);   //create object
    prototype.constructor = subType;               //augment object
    subType.prototype = prototype;                 //assign object
}

function SuperType(name){
    this.name = name;
    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
};

function SubType(name, age){  
    SuperType.call(this, name);

    this.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType(&quot;Nicholas&quot;, 29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);  //&quot;red,blue,green,black&quot;
instance1.sayName();      //&quot;Nicholas&quot;;
instance1.sayAge();       //29
var instance2 = new SubType(&quot;Greg&quot;, 27);
alert(instance2.colors);  //&quot;red,blue,green&quot;
instance2.sayName();      //&quot;Greg&quot;;
instance2.sayAge();       //27
</code></pre><p>`</p>
<h3 id="Chapter-7-函数表达式-与函数声明的区别"><a href="#Chapter-7-函数表达式-与函数声明的区别" class="headerlink" title="Chapter 7 函数表达式(与函数声明的区别)"></a>Chapter 7 函数表达式(与函数声明的区别)</h3><p>7.1 递归<br> arguments.callee是一个指向正在执行函数的指针，实现递归<br>`</p>
<p>function factorial(num){<br>                if (num &lt;= 1){<br>                    return 1;<br>                } else {<br>                    //return num<em>factorial(num-1)<br>                    return num </em> arguments.callee(num-1);<br>                }<br>            }<br>            var anotherFactorial = factorial;<br>            factorial = null;<br>            //alert(anotherFactorial(4));  //error<br>            alert(anotherFactorial(4));  //24<br>            // //严格模式下debug—使用命名函数表达式<br>            var factorial=(function f(num){<br>            if(num&lt;-1){return 1}<br>            else{return num*f(num-1)}<br>            })<br>`<br>7.2 闭包closure</p>
<blockquote>
<p>匿名函数与闭包：前者-创建一个函数并赋值给变量；后者-有权访问另一个函数作用域中变量的函数（在一个函数内创建另一函数）。<br>原理：明白作用域链的概念，当某函数被调用时，会创建一个EC及相应的作用域链；<br>然后使用arguments和其它命名参数的值来初始化函数的活动对象（activation object）<br>此时，外部函数作用域链处于第二位，再外的第三位，。。。，最外到全局执行环境。<br>其实，作用域链包含两级变量对象–本地活动对象和全局变量对象，其本质是一个指向<br>变量对象的指针列表，仅仅引用并不包含变量对象。</p>
</blockquote>
<p>7.2.1 闭包与变量</p>
<blockquote>
<p>闭包的副作用：只能取得包含函数中任何变量的最后一个值。</p>
</blockquote>
<p><code>function createFunctions(){
                var result = new Array();
                for (var i=0; i &lt; 10; i++){
                    result[i] = function(){
                        return i;
                    };
                }
                return result;
            }
        var funcs = createFunctions();
            //every function outputs 10
            //原因：每个函数作用域链中都保存着createFunctions()函数的活动对象，它们引用的是
            同一个变量i。当createFunction（）函数返回后，i都是10.
            for (var i=0; i &lt; funcs.length; i++){
                document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);
            }
        //解决方案如下：创建一个匿名函数强制让闭包行为符合预期（函数参数是按值传递的）
        for (var i=0; i &lt; 10; i++){
                            result[i] = function(num){
                                return function(){
                                    return num;
                                };
                            }(i);
                        }
        //或者用ES6语法变var i为let i</code><br>7.2.2 关于this对象</p>
<blockquote>
<p>this对象是在运行时基于函数的执行环境绑定的：在全局下this===window；当函数被作为某个对象的方法<br>调用时，this===调用其的对象。但匿名函数的作用域具有全局性，其this对象通常指向window；除非通过call（）<br>apply()改变。</p>
</blockquote>
<p>`<br>var name = “The Window”;<br>    var object = {<br>        name : “My Object”,<br>        getNameFunc : function(){<br>            //var that=this;<br>            return function(){<br>                return this.name;<br>                //return that.name;<br>            };<br>        }<br>    };<br>alert(object.getNameFunc()());  //“The Window”<br>//细微变化可能改变this<br>var name=’window’;<br>var obj={name:’obj’,getName:function(){return this.name}}<br>obj.getName();//‘obj’<br>(obj.getName)();//‘obj’<br>(obj.getName=obj.getName)();//‘window’,this得不到维持</p>
<p>`</p>
<blockquote>
<p>原因分析：每个函数在调用时都会自动取得两个特殊变量this和arguments；内部函数在搜索<br>此二变量时只会搜索到其活动对象为之，故永不可能直接访问外部函数中此二变量。一种解决方式是把外部作用<br>域中this对象保存在闭包中。如上注释部分。</p>
</blockquote>
<p>7.2.3 内存泄漏</p>
<blockquote>
<p>闭包会引用包含函数的整个活动对象！即使闭包不直接引用ele，包含函数的活动对象也仍然<br>会保存一个引用。<br><code>function assignHandler(){
    var ele=document.getElementById(&#39;xx&#39;);
    var id=ele.id;//抽出闭包中循环引用的变量
    ele.onclick=function(){}
    ele=null;//清除对dom对象的引用
}</code></p>
</blockquote>
<p>7.2.4 模仿块级作用域</p>
<blockquote>
<p>JS 从不会告诉你是否声明了同一个变量；只会无视后续声明（会执行声明的初始化），匿名函数可以<br>模仿块级作用域并避免此问题。并且只要做到闭包中没有指向匿名函数的引用，就可以减少闭包占用内存的问题。<br><code>(function(){//block scope})();
var someFunction=function(){//block scope}
function(){//block scope}();//error ,函数声明不能跟（），js将function当作函数声明的开始</code></p>
</blockquote>
<p>7.2.5 private variables私有变量</p>
<blockquote>
<p>事实上，JS中没有私有成员的概念；所有对象的属性都是公有的。但有个私有变量的概念—任何在函数<br>中定义的变量。<br>特权方法（privileged method）: 有权访问私有变量和私有函数的公有方法。有以下两种<br>但在函数中定义特权有个缺点：必须使用构造函数模式实现，其缺点是每个实例都会创建一组新方法，使用静态私有变量<br>可以避免此问题（私有变量和函数是由实例共享的，作为一个闭包总是保存着对包含作用域的引用）。</p>
</blockquote>
<p>`<br>//模式一：在构造函数中定义特权方法，将特权方法作为闭包（有权访问在构造函数中的所有属性和方法）<br>function MyObject(){<br>    //私有变量和私有函数<br>    var privateVariable=10;<br>    function privateFunction(){<br>        return false;<br>    }<br>    //特权方法<br>    this.publicMethod=functionn(){<br>        privateVariable++;<br>        return privateFunciton();<br>    }<br>}<br>// 使用静态私有变量<br>(function(){<br>    var name = “”;<br>    Person = function(value){<br>        name = value;<br>    };<br>    Person.prototype.getName = function(){<br>        return name;<br>    };<br>    Person.prototype.setName = function (value){<br>        name = value;<br>    };<br>})();<br>var person1 = new Person(“Nicholas”);<br>alert(person1.getName());   //“Nicholas”<br>person1.setName(“Greg”);<br>alert(person1.getName());   //“Greg”<br>var person2 = new Person(“Michael”);<br>alert(person1.getName());   //“Michael”<br>alert(person2.getName());   //“Michael”</p>
<p>`</p>
<ol>
<li><p>4.2 模块模式</p>
<blockquote>
<p>上述模式用于为自定义类型创建私有变量和特权方法，而模块模式则是为单例创建私有变量和特权的方法。<br>`</p>
<pre><code>function BaseComponent(){
}
</code></pre></blockquote>
<pre><code>function OtherComponent(){
}

var application = function(){

    //private variables and functions
    var components = new Array();

    //initialization
    components.push(new BaseComponent());

    //public interface
    return {
        getComponentCount : function(){
            return components.length;
        },

        registerComponent : function(component){
            if (typeof component == &quot;object&quot;){
                components.push(component);
            }
        }
    };
}();

application.registerComponent(new OtherComponent());
//增强的模块模式
function BaseComponent(){
            }

            function OtherComponent(){
            }

            var application = function(){

                //private variables and functions
                var components = new Array();

                //initialization
                components.push(new BaseComponent());

                //create a local copy of application
                var app = new BaseComponent();

                //public interface
                app.getComponentCount = function(){
                    return components.length;
                };

                app.registerComponent = function(component){
                    if (typeof component == &quot;object&quot;){
                        components.push(component);
                    }
                };

                //return it
                return app;
            }();
            alert(application instanceof BaseComponent);
            application.registerComponent(new OtherComponent());
            alert(application.getComponentCount());  //2
</code></pre><p>`</p>
<h3 id="Chapter-8-BOM"><a href="#Chapter-8-BOM" class="headerlink" title="Chapter 8 BOM"></a>Chapter 8 BOM</h3></li>
<li>1 window对象</li>
<li><p>1.1 global scope</p>
<blockquote>
<p>定义的全局变量和在window上直接定义的变量细微差别就是前者不可以用delete操作符删除<br>var a=’hello’;window.b=’world’;delete window.a;//false;delete window.b;//true<br>因var 添加的window属性的[[Configurable]]===false</p>
</blockquote>
</li>
<li><p>1.2 窗口关系及框架</p>
</li>
<li>1.3 窗口位置<br>`<br>//使用下边代码可以跨浏览器取得窗口左边和上边位置。<br>var leftPos = (typeof window.screenLeft == “number”) ? <pre><code>                  window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == &quot;number&quot;) ? 
                  window.screenTop : window.screenY;
alert(&quot;Left: &quot; + leftPos);
alert(&quot;Top: &quot; + topPos);
</code></pre><code>8.1.4 窗口大小</code><br>var pageWidth = window.innerWidth,<pre><code>    pageHeight = window.innerHeight;
if (typeof pageWidth != &quot;number&quot;){
    if (document.compatMode == &quot;CSS1Compat&quot;){
        pageWidth = document.documentElement.clientWidth;
        pageHeight = document.documentElement.clientHeight;
    } else {
        pageWidth = document.body.clientWidth;
        pageHeight = document.body.clientHeight;
    }
}
alert(&quot;Width: &quot; + pageWidth);
alert(&quot;Height: &quot; + pageHeight);
</code></pre>`</li>
<li>1.5 导航和打开<br><code>window.open();
// 接收四个参数：URL，窗口目标，一个特性字符串，布尔值</code><br>8.1.6 setInterval()和setTimeOut()<br>8.1.7 系统对话框：alert(),confirm(),prompt()<br>8.2 location 对象<br><code>window.location===document.location</code></li>
<li>3 navigator对象</li>
<li>4 screen对象</li>
<li><p>5 history对象</p>
<h3 id="Chapter-9-客户端检查"><a href="#Chapter-9-客户端检查" class="headerlink" title="Chapter 9 客户端检查"></a>Chapter 9 客户端检查</h3><h3 id="Chapter-10-DOM"><a href="#Chapter-10-DOM" class="headerlink" title="Chapter 10 DOM"></a>Chapter 10 DOM</h3><blockquote>
<p>DOM是针对HTML和XML文档的一个API，描绘了一个层次化的节点树，允许开发人员增删改<br>查页面的一部分。注意IE中的DOM对象都是以COM对象的形式实现的。</p>
</blockquote>
</li>
<li><p>1 节点层次</p>
<blockquote>
<p>DOM树：DOM可以将HTML，XML文档描述成一个由多层次节点构成的结构。节点分几种不同的类型，<br>每种类型分别表示文档中不同的信息及标记。每个节点都有自己的特点数据和方法且与其它节点存在<br>关系，由此构成了层次，所有页面标记则表现为一个以特定节点为根节点的树形结构。每一段标记<br>都可以通过树中一个节点来表示（html元素由元素节点表示，attribute由属性节点表示，documentType由文档<br>类型节点表示，commit由注释节点表示）。</p>
</blockquote>
</li>
<li><p>1.1 Node类型（12种）</p>
<ol>
<li><strong>Node.ELEMENT_NODE(1)</strong>;</li>
<li><strong>Node.ATTRIBUTE_NODE(2)</strong>;</li>
<li><strong>Node.TEXT_NODE(3);</strong></li>
<li>Node.ENTITY_REFERENCE_NODE(5);</li>
<li>Node.ENTITY_NODE(6);</li>
<li>Node.PROCESSING_INSTRUCTION_NODE(7);</li>
<li><strong>Node.COMMIT_NODE(8);</strong></li>
<li><strong>Node.DOCUMENT_NODE(9);</strong></li>
<li><strong>Node.DOCUMENT_TYPE_NODE(10);</strong></li>
<li>Node.DOCUMENT_FRAGMENT_NODE(11);</li>
<li>Node.NOTATION_NODE(12);<h3 id="Chapter11-DOM扩展"><a href="#Chapter11-DOM扩展" class="headerlink" title="Chapter11 DOM扩展"></a>Chapter11 DOM扩展</h3><blockquote>
<p>DOM扩展主要是selectorsAPI和H5</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<ul>
<li>querySelector()</li>
<li>querySelectorAll()</li>
<li>matchesSelector()</li>
<li>元素遍历<ol>
<li>childElementCount:返回子元素（不含文本节点和注释）个数；</li>
<li>firstElementChild:指向首子元素；</li>
<li>lastElementChild:指向首尾元素；</li>
<li>previousElementSibling:指向前一个同辈元素；</li>
<li>nextElementSibling:指向后一个同辈元素；</li>
</ol>
</li>
</ul>
<ol>
<li><p>3HTML5</p>
<blockquote>
<p>H5规范围绕如何使用新增标记定义了大量的JS API。其中一些与DOM重叠，定义了浏览器应该支持的DOM扩展</p>
</blockquote>
</li>
<li><p>3.1与类相关的扩充</p>
</li>
</ol>
<ul>
<li>getElementByClassName():返回带有指定类的所有元素的NodeList；</li>
<li>classList():<ol>
<li>div.classList.remove(‘user’):删除类集中某类</li>
<li>div.classList.add(‘user’):添加类集中某类</li>
<li>div.classList.toggle(‘user’):切换类集中某类</li>
<li>div.classList.contains(‘user’):查询类集中某类</li>
</ol>
</li>
</ul>
<ol>
<li>3.2焦点管理<br><code>var btn=document.getElementById(&#39;my-button&#39;);
btn.focus();
document.hasFocus();//true
//通过检查文档是否活得了焦点来判断用户是否在与页面交互</code></li>
<li>3.3 HTMLDocument的变化</li>
</ol>
<ul>
<li>readyState属性：loading（加载中）,complete(已完成)</li>
<li>compatMode兼容模式<br><code>alert(document.compatMode==&#39;CSS1Compat&#39;?&#39;Standards Mode&#39;:&#39;Quicks Mode&#39;)</code></li>
<li>head 属性<br><code>var head=document.head||document.getElementsByTagName(&#39;head&#39;[0])</code></li>
</ul>
<ol>
<li>3.4 字符集属性<br><code>document.charset;//UTF-8</code></li>
<li>3.5自定义数据属性data-<blockquote>
<p>目的是为元素提供与渲染无关的信息，或者提供语义信息，可以任意添加随便命名，但要以data-开头。</p>
</blockquote>
</li>
</ol>
<p>11 .3.6插入标记</p>
<blockquote>
<p>DOM操作的福音：虽然DOM操作可以实现细致入微的控制，但非常繁琐，使用插入标记<br>技术直接插入html字符串不仅简单而且高效。但多说浏览器中插入的script脚本并不会<br>执行（除非指定defer属性且位于（微软所谓的）作用域之后）</p>
</blockquote>
<ul>
<li>innerHTML<br><code>document.querySelector(&#39;div&#39;).innerHTML=&#39;&lt;script defer&gt;alert(&quot;hi&quot;)&lt;/script&gt;&#39;</code></li>
<li>outerHTML</li>
<li>insertAdjacentHTML()<h3 id="Chapter12-DOM2和DOM3"><a href="#Chapter12-DOM2和DOM3" class="headerlink" title="Chapter12 DOM2和DOM3"></a>Chapter12 DOM2和DOM3</h3><h3 id="Chapter13-事件处理程序"><a href="#Chapter13-事件处理程序" class="headerlink" title="Chapter13 事件处理程序"></a>Chapter13 事件处理程序</h3></li>
</ul>
<ol>
<li>2.2 DOM0级事件处理程序<blockquote>
<p>介绍：传统方式，将一个函数赋值给一个事件处理程序属性。特点：简单，跨<br>浏览器。首先要取得要操作对象的引用。<br>DOM0级事件处理程序被称为元素的方法，因此时事件处理程序是在元素作用域中执行的。</p>
</blockquote>
</li>
</ol>
<p><code>var btn=document.getElementById(&#39;xx&#39;);
btn.onclick=functin(){}；
btn.onclick=null;//删除事件处理程序</code></p>
<ol>
<li>2.3 DOM2级事件处理程序<blockquote>
<p>DOM2定义了两个方法用于指定和删除处理程序的操作：addEventListener()和removeEventListener()<br>所有DOM节点都包含这两个方法且接受三个参数：事件名，函数，布尔值（true:捕获，false冒泡）<br>多数情况下将事件处理程序添加到事件流的冒泡阶段，可以最大限度地兼容各种浏览器。<br><code>btn.addEventListener(&#39;click&#39;,function(){
},false);
btn.removeEventListener(&#39;click&#39;,function(){
},false);</code></p>
</blockquote>
</li>
<li>2.4IE事件处理程序<br><code>btn.attach(&#39;onclick&#39;,function(){});
btn.detach(&#39;onclick&#39;,function(){});</code></li>
<li>2.5跨浏览器事件处理程序</li>
<li>3事件对象<blockquote>
<p>触发DOM上某事件时会产生一个包含与事件相关信息的事件对象。<br>只有在事件处理程序执行期间，event对象才会存在，否则立即销毁。</p>
</blockquote>
</li>
</ol>
<p>`<br>btn.onclick=function(event){alert(event.type)}<br>btn.addEventListener(‘click’,function(event){alert(event.type)}<br>//stopPropagation用于阻止事件在DOM上传播（捕获或冒泡）<br>var btn = document.getElementById(“myBtn”);<br>        btn.onclick = function(event){<br>            alert(“Clicked”);<br>            event.stopPropagation();<br>        };</p>
<pre><code>document.body.onclick = function(event){
    alert(&quot;Body clicked&quot;);
};
</code></pre><p>`</p>
<ol>
<li>4事件类型</li>
<li>4.1 UI事件：不一定与用户操作有关的事件。包括DOMActive(非html事件),load,unload,abort<br>error,select,resize,scroll事件。<br><code>var isSurpported=document.implementation.hasFeature(&#39;HTMLEventts&#39;,&#39;2.0&#39;);
var isSurpported=document.implementation.hasFeature(&#39;UIEvent&#39;,&#39;3.0&#39;);</code></li>
<li>4.2 焦点事件：blur,focusIn,focusOut,focus</li>
<li>4.3 鼠标与滚轮事件：click,dbclick,mousedown,mouseenter,mouseleave,mousemove,<br>mouseout,mouseover,mouseup</li>
<li>4.4键盘与文本事件：keydowm,keyup,keypress</li>
<li>4.5 复合事件</li>
<li>4.6 变动事件</li>
<li>4.7 HTML5事件：contextmenu,beforeunload,DOMContentloaded,readystatechange<br>pageshow,pagehide,haschange</li>
<li>4.8 设备事件</li>
<li>4.9 触摸与手势事件touchEvents</li>
</ol>
<ul>
<li>触摸事件<ol>
<li>touchstart</li>
<li>touchmove</li>
<li>touchend</li>
<li>touchcancel</li>
</ol>
</li>
<li>手势事件<ol>
<li>gesturestart</li>
<li>gesturechange</li>
<li>gestureend</li>
</ol>
</li>
</ul>
<ol>
<li>5 内存和性能<blockquote>
<p>每个函数都是对象，会占用内存，内存中对象越多性能越差；必须事先指定所有事件<br>处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。解决之道是使用事件委托或<br>移除事件处理程序。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>事件委托：只需在DOM树中尽量最高的层次上添加一个事件处理程序<br>`<br>(function(){<br>var list = document.getElementById(“myLinks”);</p>
<pre><code>EventUtil.addHandler(list, &quot;click&quot;, function(event){
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    switch(target.id){
        case &quot;doSomething&quot;:
            document.title = &quot;I changed the document&apos;s title&quot;;
            break;

        case &quot;goSomewhere&quot;:
            location.href = &quot;http://www.wrox.com&quot;;
            break;

        case &quot;sayHi&quot;:
            alert(&quot;hi&quot;);
            break;
    }
});
</code></pre><p>  })();<br>  btn.onclick=function(){</p>
<pre><code>//过河
btn.onclick=null;//拆桥
//...
</code></pre><p>  }<br>`</p>
</li>
</ul>
<ol>
<li>6模拟事件</li>
</ol>
<ul>
<li><p>DOM中的事件模拟：document.createEvent()方法创建对象。<br>`<br>(function(){</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
var btn2 = document.getElementById(&quot;myBtn2&quot;);

EventUtil.addHandler(btn, &quot;click&quot;, function(event){
    alert(&quot;Clicked!&quot;);
    alert(event.screenX);   //100
});

EventUtil.addHandler(btn2, &quot;click&quot;, function(event){
    //create event object
    var event = document.createEvent(&quot;MouseEvents&quot;);
    //initialize the event object
    event.initMouseEvent(&quot;click&quot;, true, true, document.defaultView, 0, 100, 0, 0, 0, false, 
                         false, false, false, 0, btn2);
    //fire the event
    btn.dispatchEvent(event);
});
</code></pre><p>  })();<br>`</p>
<h3 id="Chapter-14-表单脚本"><a href="#Chapter-14-表单脚本" class="headerlink" title="Chapter 14 表单脚本"></a>Chapter 14 表单脚本</h3></li>
<li><p>自动切换焦点<br>`<br>  <body></body></p>
<pre><code>&lt;form method=&quot;post&quot; action=&quot;http://www.nczonline.net&quot;&gt;
    &lt;p&gt;Enter your telephone number:&lt;/p&gt;
    &lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; size=&quot;3&quot; maxlength=&quot;3&quot; &gt;
    &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; size=&quot;3&quot; maxlength=&quot;3&quot; &gt;
    &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; size=&quot;4&quot; maxlength=&quot;4&quot; &gt;

    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function(){

    function tabForward(event){            
        event = EventUtil.getEvent(event);
        var target = EventUtil.getTarget(event);

        if (target.value.length == target.maxLength){
            var form = target.form;

            for (var i=0, len=form.elements.length; i &lt; len; i++) {
                if (form.elements[i] == target) {
                    if (form.elements[i+1]){
                        form.elements[i+1].focus();
                    }
                    return;
                }
            }
        }
    }

    var textbox1 = document.getElementById(&quot;txtTel1&quot;),
        textbox2 = document.getElementById(&quot;txtTel2&quot;),
        textbox3 = document.getElementById(&quot;txtTel3&quot;);

    EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward);        
    EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward);        
    EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);        

})();
&lt;/script&gt;
</code></pre><p>`</p>
</li>
<li><ol>
<li><p>4 表单序列化<br>`<br>function serialize(form){        </p>
<pre><code>var parts = [],
    field = null,
    i,
    len,
    j,
    optLen,
    option,
    optValue;

for (i=0, len=form.elements.length; i &lt; len; i++){
    field = form.elements[i];

    switch(field.type){
        case &quot;select-one&quot;:
        case &quot;select-multiple&quot;:

            if (field.name.length){
                for (j=0, optLen = field.options.length; j &lt; optLen; j++){
                    option = field.options[j];
                    if (option.selected){
                        optValue = &quot;&quot;;
                        if (option.hasAttribute){
                            optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text);
                        } else {
                            optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text);
                        }
                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue));
                    }
                }
            }
            break;

        case undefined:     //fieldset
        case &quot;file&quot;:        //file input
        case &quot;submit&quot;:      //submit button
        case &quot;reset&quot;:       //reset button
        case &quot;button&quot;:      //custom button
            break;

        case &quot;radio&quot;:       //radio button
        case &quot;checkbox&quot;:    //checkbox
            if (!field.checked){
                break;
            }
            /* falls through */

        default:
            //don&apos;t include form fields without names
            if (field.name.length){
                parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value));
            }
    }
}        
return parts.join(&quot;&amp;&quot;);
</code></pre><p>  }</p>
<p>  var btn = document.getElementById(“serialize-btn”);<br>  EventUtil.addHandler(btn, “click”, function(event){</p>
<pre><code>var form = document.forms[0];
alert(serialize(form));
</code></pre><p>  });<br>`</p>
<h3 id="Chapter-15-Canvas"><a href="#Chapter-15-Canvas" class="headerlink" title="Chapter 15 Canvas"></a>Chapter 15 Canvas</h3><h3 id="Chapter-16-HTML5脚本编程"><a href="#Chapter-16-HTML5脚本编程" class="headerlink" title="Chapter 16 HTML5脚本编程"></a>Chapter 16 HTML5脚本编程</h3></li>
</ol>
</li>
<li><ol>
<li>1 cross-document messaging XDM: 在来自不同域的页面间传递消息。</li>
</ol>
</li>
<li><ol>
<li>2 原生拖放(事件)<ol>
<li>dragestart；</li>
<li>drag;</li>
<li>dragend;</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>3 媒体元素</li>
</ol>
</li>
<li><ol>
<li>4 历史状态管理<h3 id="Chapter17-错误与调试"><a href="#Chapter17-错误与调试" class="headerlink" title="Chapter17 错误与调试"></a>Chapter17 错误与调试</h3></li>
</ol>
</li>
<li>17.2 错误处理<br>  错误类型：<ol>
<li>Error：基类型，供开发人员抛出自定义错误</li>
<li>EvalError：错误会使用eval()函数抛出<br><code>new eval();eval=foo;</code></li>
<li>RangeError：错误超出相应范围时触发<br><code>var items1=new Array(-20);var items2=new Array(Number.MAX_VALUE);</code></li>
<li>ReferenceError：找不到对象时抛出<br><code>var obj=x;</code></li>
<li>SyntaxError：语法错误<br><code>eval(&quot;a++b&quot;)</code></li>
<li>TypeError：类型错误，变量中保存意外类型或者访问不存在的方法时。<br><code>var o=new 12;alert(&#39;love&#39; in true);Function.prototype.toString.call(&#39;name&#39;)</code></li>
<li>URIError：使用encodeURI()或者decodeURI()格式错误时抛出。<br><code>//想知道错误类型可以如此利用try-catch语句
try{
someFunction();
}catch(error){
if(error instanceof TypeError){}
else if(error instanceof SyntaxError){}
else{...}
}</code><h3 id="Chapter-18-JS与XML"><a href="#Chapter-18-JS与XML" class="headerlink" title="Chapter 18 JS与XML"></a>Chapter 18 JS与XML</h3><h3 id="Chapter-19-E4X"><a href="#Chapter-19-E4X" class="headerlink" title="Chapter 19 E4X"></a>Chapter 19 E4X</h3><h3 id="Chapter-20-JSON"><a href="#Chapter-20-JSON" class="headerlink" title="Chapter 20 JSON"></a>Chapter 20 JSON</h3><blockquote>
<p>JSON:Javascript Object Notation,JS对象表示法，JS的利用了JS中的一些<br>模式来表示结构化数据的一个严格的子集。仅是一种数据格式不是一种语言。</p>
</blockquote>
</li>
</ol>
</li>
<li>JSON语法：三种类型<ol>
<li>简单值：与JS相同的语法，可在JSON中表示字符串，布尔值，数值和null（不支持undefined）</li>
<li>对象：一种无序的键值对的复杂数据结构类型，值可以是简单值也可以是对象。</li>
<li>数组：一种有序的值的列表的复杂的数据结构类型，通过索引访问元素。<br>JSON不支持变量，函数或者对象实例，仅仅是一种表示结构化数据的格式，虽与JS中表示数据的<br>某些语法相同，但并不局限于JS范畴。</li>
</ol>
</li>
<li><ol>
<li><p>2解析与序列化<br>`<br>JSON.parse();<br>JSON.stringify();<br>toJSON();<br>var book = {<br>title: “Professional JavaScript”,<br>authors: [<br>  “Nicholas C. Zakas”<br>],<br>edition: 3,<br>year: 2011,<br>toJSON: function(){<br>  return this.title;<br>}<br>};<br>var jsonText = JSON.stringify(book, [“title”, “edition”]);</p>
<pre><code>var jsonText = JSON.stringify(book, function(key, value){
    switch(key){
        case &quot;authors&quot;:
            return value.join(&quot;,&quot;)

        case &quot;year&quot;:
            return 5000;

        case &quot;edition&quot;:
            return undefined;

        default:
            return value;
    }
});
</code></pre><p>var jsonText=JSON.stringify(book,null,4);<br>//toJSON()作为函数过滤器的补充，把一个对象传给JSON.stringify()，序列化顺序如下：<br>//1. (存在toJSON)?调用该方法:返回对象本身；<br>// 2.若提供了第二个参数则应用该函数过滤器（传入步骤1的值）<br>//3.对上一步返回的每一个值序列化<br>//4. 若传入了第三个参数则执行相应格式化<br>var book = {</p>
<pre><code>            &quot;title&quot;: &quot;Professional JavaScript&quot;,
             &quot;authors&quot;: [
                 &quot;Nicholas C. Zakas&quot;
             ],
             edition: 3,
             year: 2011,
             releaseDate: new Date(2011, 11, 1)
        };
var jsonText = JSON.stringify(book);
</code></pre><p>  //{“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”],”edition”:3,”year”:2011,”releaseDate”:”2011-11-30T16:00:00.000Z”}<br>var bookCopy = JSON.parse(jsonText, function(key, value){<br> if (key == “releaseDate”){</p>
<pre><code>//return undefined;
return new Date(value);
</code></pre><p> } else {</p>
<pre><code>return value;
</code></pre><p> }<br>});<br>console.log(“releaseDate” in bookCopy);<br>console.log(bookCopy.releaseDate.getFullYear());//2011<br>`</p>
<h3 id="Chapter-21-Ajax与Comet"><a href="#Chapter-21-Ajax与Comet" class="headerlink" title="Chapter 21 Ajax与Comet"></a>Chapter 21 Ajax与Comet</h3><blockquote>
<p>Ajax:Asynchronous JS + XML:能够向服务器请求额外的数据而无须刷新页面，带来更好的用户体验。<br>其核心是XMLHttpRequest(XHR)对象,其为向服务器发送请求和解析服务器响应提供了流畅的接口。能够<br>以异步方式从服务器取得更多的信息。虽然名字中包含XML，但Ajax通信与数据格式无关；无须刷新整个<br>页面即可从服务器取得数据，不局限于XML。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>`<br>function createXHR(){<br>            if (typeof XMLHttpRequest != “undefined”){<br>                return new XMLHttpRequest();<br>            } else if (typeof ActiveXObject != “undefined”){<br>                if (typeof arguments.callee.activeXString != “string”){<br>                    var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                                    “MSXML2.XMLHttp”],<br>                        i, len;</p>
<pre><code>            for (i=0,len=versions.length; i &lt; len; i++){
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex){
                    //skip
                }
            }
        }

        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error(&quot;No XHR object available.&quot;);
    }
}
//如果XHR对象存在就可以写下边代码了
var xhr = createXHR();
//URL是相对执行代码的当前页面，open方法并非真正发送请求而是启动一个备发送的请求
xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);
//send()接收一个参数作为请求主题发送数据，颥不需要发送则必须传入null
//responseText:作为响应主题被返回的文本
//responseXML:如响应内容类型是&apos;text/xml&apos;或&apos;application/xml&apos;该属性将保存包含着相应数据
的XML DOM文档
//status:响应的http状态
//statusText：http状态说明
xhr.send(null);
if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
    alert(xhr.statusText);
    alert(xhr.responseText);
} else {
    alert(&quot;Request was unsuccessful: &quot; + xhr.status);
}
</code></pre><p>`</p>
<h3 id="Chapter22-高级技巧"><a href="#Chapter22-高级技巧" class="headerlink" title="Chapter22 高级技巧"></a>Chapter22 高级技巧</h3><ul>
<li><ol>
<li>1.4函数绑定bind()</li>
</ol>
</li>
<li><ol>
<li>1.5函数柯里化（function curring）</li>
</ol>
</li>
<li><ol>
<li>2防篡改对象<ol>
<li>2.1 不可扩展对象<ol>
<li>Object.preventExtensions();</li>
<li>Object.extensible()</li>
</ol>
</li>
<li>2.2密封对象：Object.seal()</li>
<li>2.3冻结对象:Object.freeze() <h3 id="Chapter-23-离线存储与客户端存储"><a href="#Chapter-23-离线存储与客户端存储" class="headerlink" title="Chapter 23 离线存储与客户端存储"></a>Chapter 23 离线存储与客户端存储</h3><blockquote>
<p>开发离线web应用步骤：</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol>
<li>确保应用知道设备能否上网；</li>
<li>应用必须能够访问一定的资源；</li>
<li>必须有一块本地空间用于保存数据，能否上网都不妨碍读写。<br>`<br>EventUtil.addHandler(window, “online”, function(){<pre><code>    document.getElementById(&quot;status&quot;).innerHTML = &quot;Online&quot;;
});
EventUtil.addHandler(window, &quot;offline&quot;, function(){
    document.getElementById(&quot;status&quot;).innerHTML = &quot;Offline&quot;;
});
</code></pre>`</li>
<li>3数据存储<h3 id="Good-Practise"><a href="#Good-Practise" class="headerlink" title="Good Practise"></a>Good Practise</h3></li>
</ol>
<ul>
<li>可维护性<ol>
<li>可理解性：其他人可以接手代码并理解它的意图和一般途径，无须作者的完整解释</li>
<li>直观性：一目了然，不管其操作过程多么复杂</li>
<li>可适应性：以一种数据上的变化不要求完全重写的方法撰写</li>
<li>可扩展性：架构上已考虑未来允许对核心功能的扩展</li>
<li>可调试性：当有地方出错时，提供足够信息来尽可能直接反馈问题所在</li>
</ol>
</li>
<li>代码约定<ol>
<li>可读性：<ol>
<li>函数和方法：每个要有注释，描述其目的和用于完成任务所可能使用的算法</li>
<li>大段代码：描述下任务的注释</li>
<li>复杂算法： </li>
<li>hack：处理兼容性等问题</li>
</ol>
</li>
<li>变量和命名<ol>
<li>变量名为名词（car，person）；</li>
<li>函数名以动词开始（getName）,返回布尔值的以is开头</li>
<li>使用合乎逻辑的名字</li>
</ol>
</li>
<li>变量类型透明<ol>
<li>初始化：var found=false,count=-1,name=’’</li>
<li>匈牙利标记法指定变量类型： var bFound,iCount,sName,pPerson</li>
<li>使用注释</li>
</ol>
</li>
</ol>
</li>
<li><p>松散耦合</p>
<ol>
<li>解耦html/JS</li>
<li>解耦css/JS</li>
<li><p>解耦应用逻辑/事件处理程序:分离原则</p>
<ol>
<li>勿将event对象传给其它方法，只传给来自event对象中所需的数据；</li>
<li>任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；</li>
<li>任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。</li>
</ol>
<p>`<br>function validateValue(value){<br> value=5*parseInt(value);<br> if(value&gt;10){</p>
<pre><code>//
</code></pre><p> }<br>}<br>function handleKeyPress(){<br> event=EventUtil.getEvent(event);<br> if(event.keyCode==13){</p>
<pre><code>//
</code></pre><p> }<br>}<br>`</p>
</li>
</ol>
</li>
<li>编程事件<ol>
<li>尊重对象所有权<ol>
<li>不要为实例或原型添加属性，方法</li>
<li>不要重定义已存在的方法</li>
</ol>
</li>
<li>避免全局变量<ol>
<li>单一的全局量的延伸便是命名空间的概念<br>YAHOO.util.DOM,YAHOO.util.Event,YAHOO.lang</li>
</ol>
</li>
<li>避免与null比较</li>
<li>使用常量：将数据和使用逻辑分离<ol>
<li>重复值：任何在多处用到的值都应是常量；</li>
<li>用户界面字符串</li>
<li>URLs</li>
<li>任何可能会改变的值</li>
</ol>
</li>
</ol>
</li>
<li>性能<ol>
<li>注意作用域<ol>
<li>避免全局查找</li>
<li>避免with</li>
</ol>
</li>
<li>选择正确的方法<ol>
<li>避免没必要的查找</li>
<li>优化循环</li>
<li>展开循环</li>
<li>避免双重解释</li>
<li>其它注意事项<ol>
<li>原生方法较快：</li>
<li>switch语句较快</li>
<li>位运算符较快</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>最小化语句树<ol>
<li>多个变量声明</li>
<li>插入迭代值</li>
<li>使用数组和对象字面量</li>
</ol>
</li>
<li>优化DOM交互<ol>
<li>最小化现场更新</li>
<li>使用innerHTML</li>
<li>使用事件代理</li>
<li>注意HTMLCollection</li>
</ol>
</li>
<li>部署<ol>
<li>构建过程<ol>
<li>知识产权问题</li>
<li>文件大小</li>
<li>代码组织</li>
</ol>
</li>
<li>验证</li>
<li>压缩<ol>
<li>文件压缩<ol>
<li>删除所有空白</li>
<li>删除所有注释</li>
<li>缩短变量名<br>2.HTTP 压缩<h3 id="Chapter25-新兴API"><a href="#Chapter25-新兴API" class="headerlink" title="Chapter25 新兴API"></a>Chapter25 新兴API</h3><h3 id="ES-Harmony"><a href="#ES-Harmony" class="headerlink" title="ES Harmony"></a>ES Harmony</h3></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>一般性变化<ol>
<li>常量：const</li>
<li>块级作用域及其它作用域<br> let关键字：使用let定义的变量在定义它的代码之外没有定义。</li>
</ol>
</li>
<li>函数<ol>
<li>剩余参数与分布函数<br>`<br>function sum(n1,n2,…ns){<br> var result=n1+n2;<br> for(let i=0,len=ns.length;i&lt;len;i++){<pre><code>result+=n[i]
</code></pre> }<br> return result;<br>}<br>var result=sum(…[1,2,3,4,4]);<br>var result=sum.apply(this,[1,3,4,4,5])<br>`</li>
<li>默认参数值<br><code>function sum(n1,n2=0){
 return n1+n2;
}</code></li>
<li>生成器<br>`<br>function myNumbers(){<br> for(var i=0;i&lt;10;i++){<pre><code>yield i*2;
</code></pre> }<br>}<br>var generator=myNumbers()<br>`</li>
</ol>
</li>
<li>数组及其它<ol>
<li>迭代器<br><code>var colors=[&#39;yellow&#39;,&#39;blue&#39;,&#39;red&#39;];
var iterator=new Iterator(colors)</code></li>
<li>数组领悟<br><code>var numbers=[1,3,4,4,5];
var duplicate=[i for each (i in numbers) if(i%2==0)]</code></li>
<li>解构赋值<br><code>var value1=5,value2=10;
[value1,value2]=[value2,value1]</code></li>
</ol>
</li>
<li>新对象类型<ol>
<li>代理对象<br><code>var proxy=Proxy.create(handler);
var proxy=Proxy.create(handler,myObject);</code><br>捕捉器7种：<ol>
<li>getOwnPropertyDescriptor</li>
<li>getPropertyDescriptor</li>
<li>getOwnPropertyNames</li>
<li>getPropertyName</li>
<li>defineProperty</li>
<li>delete</li>
<li>fix<br>派生捕捉器6种</li>
<li>has</li>
<li>hasOwn</li>
<li>get</li>
<li>set</li>
<li>enumerate</li>
<li>keys</li>
</ol>
</li>
<li>代理函数<br><code>var proxy=Proxy.createFunction(handler,function(){}.function(){})</code></li>
<li>映射map与集合set<br><code>var map=new Map();
map.set(&#39;name&#39;,&#39;Yl&#39;);
map.has(&#39;name&#39;);//true
var set=new Set();
set.add(&#39;name&#39;);
set.has(&#39;name&#39;);//true
set.delete(&#39;name&#39;)</code></li>
<li>weakMap<br><code>var key={},map=new WeakMap();
map.set(key,&#39;hello&#39;);
//解除对键的引用而删除该值
key=null</code></li>
<li>StructType</li>
<li>ArrayType</li>
</ol>
</li>
<li>类<br>`<br>class Person {<br>  constructor(name,age){<pre><code>public name=name;
//public age=age;
private age=age;
get title(){
    return innerTitle=&apos;&apos;
}
set title(value){
    innerTitle=value;
}
</code></pre>  }<br>  sayName(){<pre><code>alert(this.name)
</code></pre>  }<br>  getOlder(years){<pre><code>alert(this.age+=years)
</code></pre>  }<br>}<br>`<ol>
<li>私有成员</li>
<li>getter,setter</li>
<li>继承<br><code>class Employee extends Person
class Employee prototype basePerson</code></li>
</ol>
</li>
<li>模块<br>  `<br>  module MyModule={<pre><code>export let myobject={};
export function hello(){};
function goodbye(){}
</code></pre>  }<br>  import myobject from MyModule<br>  import * from MyModule<br>  //直接使用<br>  console.log(MyModule.hello)<br>  <code>外部模块</code><br>  module MyModule from ‘a.js’<br>  import myobject from MyModule<br>  `<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><code>use strit</code></li>
<li>变量：禁止意外创建全局变量</li>
<li>对象：<ol>
<li>为只读属性赋值==&gt;TypeError</li>
<li>对不可配置的属性使用delete==&gt;TypeError</li>
<li>为不可扩展的对象添加属性==&gt;TypeError</li>
<li>使用对象字面量时属性名必须唯一</li>
</ol>
</li>
<li>函数<ol>
<li>命名函数的参数必须唯一</li>
<li>淘汰了arguments.callee,arguments.caller</li>
</ol>
</li>
<li>eval():在包含上下文中不再创建变量或函数</li>
<li>eval与arguments：不可作为变量引用</li>
<li>抑制this：函数的this始终是指定值，无论指定值是什么</li>
<li>其它：禁用with语句</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Framework resharpe]]></title>
      <url>https://github.com/yanlee26/blog/2016/06/04/framework/</url>
      <content type="html"><![CDATA[<h1 id="js-常用封装总结"><a href="#js-常用封装总结" class="headerlink" title="js 常用封装总结"></a>js 常用封装总结</h1><p>`<br>//自制框架<br>//定义一个对象 - 名字是$$<br>var $$ = function () {<br>};<br>//第二种写法<br>$$.prototype = {<br>    $q:function (str) {<br>        return document.querySelector(str)<br>    },<br>    $qa:function (str) {<br>        return document.querySelectorAll(str)<br>    },<br>    $id: function (str) {<br>        return document.getElementById(str)<br>    },<br>    $tag: function (tag) {<br>        return document.getElementsByTagName(tag)<br>    },<br>    //去除左边空格<br>    ltrim: function (str) {<br>        return str.replace(/(^\s<em>)/g, ‘’);<br>    },<br>    //去除右边空格<br>    rtrim: function (str) {<br>        return str.replace(/(\s</em>$)/g, ‘’);<br>    },<br>    //去除空格<br>    trim: function (str) {<br>        return str.replace(/(^\s<em>)|(\s</em>$)/g, ‘’);<br>    },<br>    //ajax<br>    myAjax: function (URL, fn) {<br>        var xhr = createXHR();    //返回了一个对象，这个对象IE6兼容。<br>        xhr.onreadystatechange = function () {<br>            if (xhr.readyState === 4) {<br>                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) {<br>                    fn(xhr.responseText);<br>                } else {<br>                    alert(“错误的文件！”);<br>                }<br>            }<br>        };<br>        xhr.open(“get”, URL, true);<br>        xhr.send();<br>        //闭包形式，因为这个函数只服务于ajax函数，所以放在里面<br>        function createXHR() {<br>            if (typeof XMLHttpRequest != “undefined”) {<br>                return new XMLHttpRequest();<br>            } else if (typeof ActiveXObject != “undefined”) {<br>                if (typeof arguments.callee.activeXString != “string”) {<br>                    var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                            “MSXML2.XMLHttp”<br>                        ],<br>                        i, len;<br>                    for (i = 0, len = versions.length; i &lt; len; i++) {<br>                        try {<br>                            new ActiveXObject(versions[i]);<br>                            arguments.callee.activeXString = versions[i];<br>                            break;<br>                        } catch (ex) {<br>                            //skip<br>                        }<br>                    }<br>                }<br>                return new ActiveXObject(arguments.callee.activeXString);<br>            } else {<br>                throw new Error(“No XHR object available.”);<br>            }<br>        }<br>    },<br>    //tab<br>    tab: function (id) {<br>        var box = document.getElementById(id);<br>        var spans = box.getElementsByTagName(‘span’);<br>        var lis = box.getElementsByTagName(‘li’);<br>        for (var i = 0; i &lt; spans.length; i++) {<br>            spans[i].index = i;<br>            spans[i].onmouseover = function () {<br>                for (var i = 0; i &lt; spans.length; i++) {<br>                    spans[i].className = ‘’;<br>                    lis[i].className = ‘’;<br>                }<br>                this.className = ‘select’;<br>                lis[this.index].className = ‘select’;<br>            }<br>        }<br>    },<br>    //简单的数据绑定formateString<br>    formateString: function (str, data) {<br>        return str.replace(/@((\w+))/g, function (match, key) {<br>            return typeof data[key] === “undefined” ? ‘’ : data[key]<br>        });<br>    },<br>    //给一个对象扩充功能<br>    extendMany: function () {<br>        var key, i = 0, len = arguments.length, target = null, copy;<br>        if (len === 0) {<br>            return;<br>        } else if (len === 1) {<br>            target = this;<br>        } else {<br>            i++;<br>            target = arguments[0];<br>        }<br>        for (; i &lt; len; i++) {<br>            for (key in arguments[i]) {<br>                copy = arguments[i][key];<br>                target[key] = copy;<br>            }<br>        }<br>        return target;<br>    },<br>    extend: function (tar, source) {<br>        for (var i in source) {<br>            tar[i] = source[i];<br>        }<br>        return tar;<br>    },<br>    random: function (begin, end) {<br>        return Math.floor(Math.random() <em> (end - begin)) + begin;<br>    },<br>    isNumber: function (val) {<br>        return typeof val === ‘number’ &amp;&amp; isFinite(val)<br>    },<br>    isBoolean: function (val) {<br>        return typeof val === “boolean”;<br>    },<br>    isString: function (val) {<br>        return typeof val === “string”;<br>    },<br>    isUndefined: function (val) {<br>        return typeof val === “undefined”;<br>    },<br>    isObj: function (str) {<br>        if (str === null || typeof str === ‘undefined’) {<br>            return false;<br>        }<br>        return typeof str === ‘object’;<br>    },<br>    isNull: function (val) {<br>        return val === null;<br>    },<br>    isArray: function (arr) {<br>        if (arr === null || typeof arr === ‘undefined’) {<br>            return false;<br>        }<br>        return arr.constructor === Array;<br>    }<br>};<br>//在框架中实例化<br>$$ = new $$();<br>$$.extend($$, {<br>    $id: function(id) {<br>        return document.getElementById(id);<br>    },<br>    $tag: function(tag, context) {<br>        if (typeof context == ‘string’) {<br>            context = $$.$id(context);<br>        }<br>        if (context) {<br>            return context.getElementsByTagName(tag);<br>        } else {<br>            return document.getElementsByTagName(tag);<br>        }<br>    },<br>    $class: function(className, context) {<br>        var i = 0,<br>            len, dom = [],<br>            arr = [];<br>        if ($$.isString(context)) {<br>            context = document.getElementById(context);<br>        } else {<br>            context = document;<br>        }<br>        if (context.getElementsByClassName) {<br>            return context.getElementsByClassName(className);<br>        } else {<br>            dom = context.getElementsByTagName(‘</em>‘);<br>            for (i; len = dom.length, i &lt; len; i++) {<br>                if (dom[i].className) {<br>                    arr.push(dom[i]);<br>                }<br>            }<br>        }<br>        return arr;<br>    },<br>    $group: function(content) {<br>        var result = [],<br>            doms = [];<br>        var arr = $$.trim(content).split(‘,’);<br>        for (var i = 0, len = arr.length; i &lt; len; i++) {<br>            var item = $$.trim(arr[i])<br>            var first = item.charAt(0)<br>            var index = item.indexOf(first)<br>            if (first === ‘.’) {<br>                doms = $$.$class(item.slice(index + 1));<br>                pushArray(doms, result)<br>            } else if (first === ‘#’) {<br>                doms = [$$.$id(item.slice(index + 1))] ;<br>                pushArray(doms, result)<br>            } else {<br>                doms = $$.$tag(item);<br>                pushArray(doms, result)<br>            }<br>        }<br>        return result;<br>        function pushArray(doms, result) {<br>            for (var j = 0, domlen = doms.length; j &lt; domlen; j++) {<br>                result.push(doms[j])<br>            }<br>        }<br>    },<br>    $cengci: function(select) {<br>        var sel = $$.trim(select).split(‘ ‘);<br>        var result = [];<br>        var context = [];<br>        for (var i = 0, len = sel.length; i &lt; len; i++) {<br>            result = [];<br>            var item = $$.trim(sel[i]);<br>            var first = sel[i].charAt(0)<br>            var index = item.indexOf(first)<br>            if (first === ‘#’) {<br>                pushArray([$$.$id(item.slice(index + 1))]);<br>                context = result;<br>            } else if (first === ‘.’) {<br>                if (context.length) {<br>                    for (var j = 0, contextLen = context.length; j &lt; contextLen; j++) {<br>                        pushArray($$.$class(item.slice(index + 1), context[j]));<br>                    }<br>                } else {<br>                    pushArray($$.$class(item.slice(index + 1)));<br>                }<br>                context = result;<br>            } else {<br>                if (context.length) {<br>                    for (var j = 0, contextLen = context.length; j &lt; contextLen; j++) {<br>                        pushArray($$.$tag(item, context[j]));<br>                    }<br>                } else {<br>                    pushArray($$.$tag(item));<br>                }<br>                context = result;<br>            }<br>        }</p>
<pre><code>    return context;
    function pushArray(doms) {
        for (var j = 0, domlen = doms.length; j &lt; domlen; j++) {
            result.push(doms[j])
        }
    }
},
$select: function(str) {
    var result = [];
    var item = $$.trim(str).split(&apos;,&apos;);
    for (var i = 0, glen = item.length; i &lt; glen; i++) {
        var select = $$.trim(item[i]);
        var context = [];
        context = $$.$cengci(select);
        pushArray(context);

    }
    return result;
    function pushArray(doms) {
        for (var j = 0, domlen = doms.length; j &lt; domlen; j++) {
            result.push(doms[j])
        }
    }
},
$all: function(selector, context) {
    context = context || document;
    return context.querySelectorAll(selector);
},
</code></pre><p>});<br>$$.extend($$, {<br>    css: function(context, key, value) {<br>        console.log(‘dfdfd’)<br>        var dom = $$.isString(context) ? $$.$all(context) : context;<br>        //Èç¹ûÊÇÊý×é<br>        if (dom.length) {<br>            //ÏÈ¹Ç¼Ü¹Ç¼Ü – Èç¹ûÊÇ»ñÈ¡Ä£Ê½ – Èç¹ûÊÇÉèÖÃÄ£Ê½<br>            //Èç¹ûvalue²»Îª¿Õ£¬Ôò±íÊ¾ÉèÖÃ<br>            if (value) {<br>                for (var i = dom.length - 1; i &gt;= 0; i–) {<br>                    setStyle(dom[i], key, value);<br>                }<br>                //            Èç¹ûvalueÎª¿Õ£¬Ôò±íÊ¾»ñÈ¡<br>            } else {<br>                return getStyle(dom[0]);<br>            }<br>            //Èç¹û²»ÊÇÊý×é<br>        } else {<br>            if (value) {<br>                setStyle(dom, key, value);<br>            } else {<br>                return getStyle(dom);<br>            }<br>        }</p>
<pre><code>    function getStyle(dom) {
        if (dom.currentStyle) {
            return dom.currentStyle[key];
        } else {
            return getComputedStyle(dom, null)[key];
        }
    }

    function setStyle(dom, key, value) {
        dom.style[key] = value;
    }
},
cssNum: function(context, key) {
    return parseFloat($$.css(context, key))
},
show: function(content) {
    var doms = $$.$all(content)
    for (var i = 0, len = doms.length; i &lt; len; i++) {
        $$.css(doms[i], &apos;display&apos;, &apos;block&apos;);
    }
},
hide: function(content) {
    var doms = $$.$all(content)
    for (var i = 0, len = doms.length; i &lt; len; i++) {
        $$.css(doms[i], &apos;display&apos;, &apos;none&apos;);
    }
},
Width: function(id) {
    return $$.$id(id).clientWidth
},
Height: function(id) {
    return $$.$id(id).clientHeight
},
scrollWidth: function(id) {
    return $$.$id(id).scrollWidth
},
scrollHeight: function(id) {
    return $$.$id(id).scrollHeight
},
scrollTop: function(id) {
    return $$.$id(id).scrollTop
},
scrollLeft: function(id) {
    return $$.$id(id).scrollLeft
},
screenHeight: function() {
    return window.screen.height
},
screenWidth: function() {
    return window.screen.width
},
wWidth: function() {
    return document.documentElement.clientWidth
},
wHeight: function() {
    return document.documentElement.clientHeight
},
wScrollHeight: function() {
    return document.body.scrollHeight
},
wScrollWidth: function() {
    return document.body.scrollWidth
},
wScrollTop: function() {
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    return scrollTop
},
wScrollLeft: function() {
    var scrollLeft = document.body.scrollLeft || (document.documentElement &amp;&amp; document.documentElement.scrollLeft);
    return scrollLeft
}
</code></pre><p>})<br>$$.extend($$, {<br>    attr: function(content, key, value) {<br>        var dom = $$.$all(content);<br>        if (dom.length) {<br>            if (value) {<br>                for (var i = 0, len = dom.length; i &lt; len; i++) {<br>                    dom[i].setAttribute(key, value);<br>                }<br>            } else {<br>                return dom[0].getAttribute(key);<br>            }<br>        } else {<br>            if (value) {<br>                dom.setAttribute(key, value);<br>            } else {<br>                return dom.getAttribute(key);<br>            }<br>        }<br>    },<br>    addClass: function(context, name) {<br>        var doms = $$.$all(context);<br>        if (doms.length) {<br>            for (var i = 0, len = doms.length; i &lt; len; i++) {<br>                addName(doms[i]);<br>            }<br>        } else {<br>            addName(doms);<br>        }<br>        function addName(dom) {<br>            dom.className = dom.className + ‘ ‘ + name;<br>        }<br>    },<br>    removeClass: function(context, name) {<br>        var doms = $$.$all(context);<br>        if (doms.length) {<br>            for (var i = 0, len = doms.length; i &lt; len; i++) {<br>                removeName(doms[i]);<br>            }<br>        } else {<br>            removeName(doms);<br>        }<br>        function removeName(dom) {<br>            dom.className = dom.className.replace(name, ‘’);<br>        }<br>    },<br>    hasClass: function(context, name) {<br>        var doms = $$.$all(context)<br>        var flag = true;<br>        for (var i = 0, len = doms.length; i &lt; len; i++) {<br>            flag = flag &amp;&amp; check(doms[i], name)<br>        }</p>
<pre><code>    return flag;
    //ÅÐ¶¨µ¥¸öÔªËØ
    function check(element, name) {
        return -1 &lt; (&quot; &quot; + element.className + &quot; &quot;).indexOf(&quot; &quot; + name + &quot; &quot;)
    }
},
getClass: function(id) {
    var doms = $$.$all(id)
    return $$.trim(doms[0].className).split(&quot; &quot;)
}
</code></pre><p>})<br>$$.extend($$, {<br>    html: function(context, value) {<br>        var doms = $$.$all(context);<br>        if (value) {<br>            for (var i = 0, len = doms.length; i &lt; len; i++) {<br>                doms[i].innerHTML = value;<br>            }<br>        } else {<br>            return doms[0].innerHTML<br>        }<br>    }<br>});<br>$$.extend($$, {<br>    on: function (id, type, fn) {<br>        var dom = $$.isString(id) ? document.getElementById(id) : id;<br>        if (dom.addEventListener) {<br>            dom.addEventListener(type, fn, false);<br>        } else if (dom.attachEvent) {<br>            dom.attachEvent(‘on’ + type, fn);<br>        }<br>    },<br>    un: function (id, type, fn) {<br>        var dom = $$.isString(id) ? document.getElementById(id) : id;<br>        if (dom.removeEventListener) {<br>            dom.removeEventListener(type, fn);<br>        } else if (dom.detachEvent) {<br>            dom.detachEvent(type, fn);<br>        }<br>    },<br>    click: function (id, fn) {<br>        this.on(id, ‘click’, fn);<br>    },<br>    mouseover: function (id, fn) {<br>        this.on(id, ‘mouseover’, fn);<br>    },<br>    mouseout: function (id, fn) {<br>        this.on(id, ‘mouseout’, fn);<br>    },<br>    hover: function (id, fnOver, fnOut) {<br>        if (fnOver) {<br>            this.on(id, “mouseover”, fnOver);<br>        }<br>        if (fnOut) {<br>            this.on(id, “mouseout”, fnOut);<br>        }<br>    },<br>    delegate: function (pid, eventType, selector, fn) {<br>        //参数处理<br>        var parent = $$.$id(pid);<br>        function handle(e) {<br>            var target = $$.GetTarget(e);<br>            if (target.nodeName.toLowerCase() === selector || target.id === selector || target.className.indexOf(selector) != -1) {<br>                fn.call(target);<br>            }<br>        }<br>        parent[eventType] = handle;<br>    },<br>    //事件基础<br>    getEvent: function (event) {<br>        return event ? event : window.event;<br>    },<br>    //获取目标<br>    GetTarget: function (event) {<br>        var e = $$.getEvent(event);<br>        return e.target || e.srcElement;<br>    },<br>    //组织默认行为<br>    preventDefault: function (event) {<br>        var event = $$.getEvent(event);<br>        if (event.preventDefault) {<br>            event.preventDefault();<br>        } else {<br>            event.returnValue = false;<br>        }<br>    },<br>    //阻止冒泡<br>    stopPropagation: function (event) {<br>        var event = $$.getEvent(event);<br>        if (event.stopPropagation) {<br>            event.stopPropagation();<br>        } else {<br>            event.cancelBubble = true;<br>        }<br>    }<br>})<br>$$.extend($$, {<br>    eq: function() {},<br>    first: function() {},<br>    last: function() {},<br>    append: function() {},<br>    empty: function() {},<br>    remove: function() {},<br>    clone: function() {}<br>});<br>$$.extend($$, {<br>    sjson: function(json) {<br>        return JSON.stringify(json);<br>    },<br>    json: function(str) {<br>        return eval(str);<br>    }<br>});<br>$$.cache = {<br>    data: [],<br>    get: function(key) {<br>        console.log(‘111’)<br>        var value = null;<br>        console.log(this.data)<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (key == item.key) {<br>                value = item.value;<br>            }<br>        }<br>        console.log(‘get’ + value)<br>        return value;<br>    },<br>    add: function(key, value) {<br>        var json = { key: key, value: value };<br>        this.data.push(json);<br>    },<br>    delete: function(key) {<br>        var status = false;<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (item.key.trim() == key) {<br>                this.data.splice(i, 1);<br>                status = true;<br>                break;<br>            }<br>        }<br>        return status;<br>    },<br>    update: function(key, value) {<br>        var status = false;<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (item.key.trim() === key.trim()) {<br>                item.value = value.trim();<br>                status = true;<br>                break;<br>            }<br>        }<br>        return status;<br>    },<br>    isExist: function(key) {<br>        for (var i = 0, len = this.data.length; i &lt; len; i++) {<br>            var item = this.data[i]<br>            if (key === item.key) {<br>                return true;<br>            } else {<br>                return false;<br>            }<br>        }<br>    }<br>}<br>$$.cookie = {<br>    setCookie: function(name, value, days, path) {<br>        var name = escape(name);<br>        var value = escape(value);<br>        var expires = new Date();<br>        expires.setTime(expires.getTime() + days <em> 24 </em> 60 <em> 60 </em> 1000);<br>        path = path == “” ? “” : “;path=” + path;<br>        _expires = (typeof hours) == “string” ? “” : “;expires=” + expires.toUTCString();<br>        document.cookie = name + “=” + value + _expires + path;<br>    },<br>    getCookie: function(name) {<br>        var name = escape(name);<br>        var allcookies = document.cookie;<br>        name += “=”;<br>        var pos = allcookies.indexOf(name);<br>        if (pos != -1) {<br>            var start = pos + name.length;<br>            var end = allcookies.indexOf(“;”, start);<br>            if (end == -1) end = allcookies.length;<br>            var value = allcookies.substring(start, end);<br>            return unescape(value);<br>        } else return “”;<br>    },<br>    deleteCookie: function(name, path) {<br>        var name = escape(name);<br>        var expires = new Date(0);<br>        path = path == “” ? “” : “;path=” + path;<br>        document.cookie = name + “=” + “;expires=” + expires.toUTCString() + path;<br>    }<br>}<br>$$.store = (function() {<br>    var api = {},<br>        win = window,<br>        doc = win.document,<br>        localStorageName = ‘localStorage’,<br>        globalStorageName = ‘globalStorage’,<br>        storage;<br>    api.set = function(key, value) {};<br>    api.get = function(key) {};<br>    api.remove = function(key) {};<br>    api.clear = function() {};</p>
<pre><code>if (localStorageName in win &amp;&amp; win[localStorageName]) {
    storage = win[localStorageName];
    api.set = function(key, val) { storage.setItem(key, val) };
    api.get = function(key) {
        return storage.getItem(key) };
    api.remove = function(key) { storage.removeItem(key) };
    api.clear = function() { storage.clear() };

} else if (globalStorageName in win &amp;&amp; win[globalStorageName]) {
    storage = win[globalStorageName][win.location.hostname];
    api.set = function(key, val) { storage[key] = val };
    api.get = function(key) {
        return storage[key] &amp;&amp; storage[key].value };
    api.remove = function(key) { delete storage[key] };
    api.clear = function() {
        for (var key in storage) { delete storage[key] } };

} else if (doc.documentElement.addBehavior) {
    function getStorage() {
        if (storage) {
            return storage }
        storage = doc.body.appendChild(doc.createElement(&apos;div&apos;));
        storage.style.display = &apos;none&apos;;
        // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
        // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
        storage.addBehavior(&apos;#default#userData&apos;);
        storage.load(localStorageName);
        return storage;
    }
    api.set = function(key, val) {
        var storage = getStorage();
        storage.setAttribute(key, val);
        storage.save(localStorageName);
    };
    api.get = function(key) {
        var storage = getStorage();
        return storage.getAttribute(key);
    };
    api.remove = function(key) {
        var storage = getStorage();
        storage.removeAttribute(key);
        storage.save(localStorageName);
    }
    api.clear = function() {
        var storage = getStorage();
        var attributes = storage.XMLDocument.documentElement.attributes;;
        storage.load(localStorageName);
        for (var i = 0, attr; attr = attributes[i]; i++) {
            storage.removeAttribute(attr.name);
        }
        storage.save(localStorageName);
    }
}
return api;
</code></pre><p>})();<br>var store = (function () {<br>    var api               = {},<br>        win               = window,<br>        doc               = win.document,<br>        localStorageName  = ‘localStorage’,<br>        globalStorageName = ‘globalStorage’,<br>        storage;<br>    api.set    = function (key, value) {};<br>    api.get    = function (key)        {};<br>    api.remove = function (key)        {};<br>    api.clear  = function ()           {};<br>    if (localStorageName in win &amp;&amp; win[localStorageName]) {<br>        storage    = win[localStorageName];<br>        api.set    = function (key, val) { storage.setItem(key, val) };<br>        api.get    = function (key)      { return storage.getItem(key) };<br>        api.remove = function (key)      { storage.removeItem(key) };<br>        api.clear  = function ()         { storage.clear() };</p>
<pre><code>} else if (globalStorageName in win &amp;&amp; win[globalStorageName]) {
    storage    = win[globalStorageName][win.location.hostname];
    api.set    = function (key, val) { storage[key] = val };
    api.get    = function (key)      { return storage[key] &amp;&amp; storage[key].value };
    api.remove = function (key)      { delete storage[key] };
    api.clear  = function ()         { for (var key in storage ) { delete storage[key] } };

} else if (doc.documentElement.addBehavior) {
    function getStorage() {
        if (storage) { return storage }
        storage = doc.body.appendChild(doc.createElement(&apos;div&apos;));
        storage.style.display = &apos;none&apos;;
        // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
        // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
        storage.addBehavior(&apos;#default#userData&apos;);
        storage.load(localStorageName);
        return storage;
    }
    api.set = function (key, val) {
        var storage = getStorage();
        storage.setAttribute(key, val);
        storage.save(localStorageName);
    };
    api.get = function (key) {
        var storage = getStorage();
        return storage.getAttribute(key);
    };
    api.remove = function (key) {
        var storage = getStorage();
        storage.removeAttribute(key);
        storage.save(localStorageName);
    }
    api.clear = function () {
        var storage = getStorage();
        var attributes = storage.XMLDocument.documentElement.attributes;;
        storage.load(localStorageName);
        for (var i=0, attr; attr = attributes[i]; i++) {
            storage.removeAttribute(attr.name);
        }
        storage.save(localStorageName);
    }
}
return api;
</code></pre><p>})();<br>Function.prototype.before = function( func ) {<br>    var <strong>self = this;<br>    return function() {<br>        if ( func.apply( this, arguments ) === false ) {<br>            return false;<br>        }<br>        return </strong>self.apply( this, arguments );<br>    }<br>}<br>Function.prototype.after = function( func ) {<br>    var <strong>self = this;<br>    return function() {<br>        var ret = </strong>self.apply( this, arguments );<br>        if( ret === false) {<br>            return false;<br>        }<br>        func.apply( this, arguments );<br>        return ret;<br>    }<br>}<br>`</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Prefessional JS resharpe]]></title>
      <url>https://github.com/yanlee26/blog/2016/06/04/prefesional/</url>
      <content type="html"><![CDATA[<h1 id="高程封装总结"><a href="#高程封装总结" class="headerlink" title="高程封装总结"></a>高程封装总结</h1><p>`<br>/**</p>
<ul>
<li><p>Created by 立 on 2016-12-24.<br>*/<br>//C 5 对象按某一项比较<br>function createComparisonFunction(propertyName) {</p>
<p> return function(object1, object2){</p>
<pre><code>var value1 = object1[propertyName];
var value2 = object2[propertyName];

if (value1 &lt; value2){
    return -1;
} else if (value1 &gt; value2){
    return 1;
} else {
    return 0;
}
</code></pre><p> };<br>}</p>
</li>
</ul>
<p>//C 8跨浏览器取得窗口左边和上边位置<br>var leftPos = (typeof window.screenLeft == “number”) ?<br>    window.screenLeft : window.screenX;<br>var topPos = (typeof window.screenTop == “number”) ?<br>    window.screenTop : window.screenY;</p>
<p>//size<br>if (typeof pageWidth != “number”){<br>    if (document.compatMode == “CSS1Compat”){<br>        pageWidth = document.documentElement.clientWidth;<br>        pageHeight = document.documentElement.clientHeight;<br>    } else {<br>        pageWidth = document.body.clientWidth;<br>        pageHeight = document.body.clientHeight;<br>    }<br>}<br>//C9 客户端代理检测<br>var client = function(){</p>
<pre><code>//rendering engines
var engine = {
    ie: 0,
    gecko: 0,
    webkit: 0,
    khtml: 0,
    opera: 0,

    //complete version
    ver: null
};

//browsers
var browser = {

    //browsers
    ie: 0,
    firefox: 0,
    safari: 0,
    konq: 0,
    opera: 0,
    chrome: 0,

    //specific version
    ver: null
};


//platform/device/OS
var system = {
    win: false,
    mac: false,
    x11: false,

    //mobile devices
    iphone: false,
    ipod: false,
    ipad: false,
    ios: false,
    android: false,
    nokiaN: false,
    winMobile: false,

    //game systems
    wii: false,
    ps: false
};

//detect rendering engines/browsers
var ua = navigator.userAgent;
if (window.opera){
    engine.ver = browser.ver = window.opera.version();
    engine.opera = browser.opera = parseFloat(engine.ver);
} else if (/AppleWebKit\/(\S+)/.test(ua)){
    engine.ver = RegExp[&quot;$1&quot;];
    engine.webkit = parseFloat(engine.ver);

    //figure out if it&apos;s Chrome or Safari
    if (/Chrome\/(\S+)/.test(ua)){
        browser.ver = RegExp[&quot;$1&quot;];
        browser.chrome = parseFloat(browser.ver);
    } else if (/Version\/(\S+)/.test(ua)){
        browser.ver = RegExp[&quot;$1&quot;];
        browser.safari = parseFloat(browser.ver);
    } else {
        //approximate version
        var safariVersion = 1;
        if (engine.webkit &lt; 100){
            safariVersion = 1;
        } else if (engine.webkit &lt; 312){
            safariVersion = 1.2;
        } else if (engine.webkit &lt; 412){
            safariVersion = 1.3;
        } else {
            safariVersion = 2;
        }

        browser.safari = browser.ver = safariVersion;
    }
} else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){
    engine.ver = browser.ver = RegExp[&quot;$1&quot;];
    engine.khtml = browser.konq = parseFloat(engine.ver);
} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){
    engine.ver = RegExp[&quot;$1&quot;];
    engine.gecko = parseFloat(engine.ver);

    //determine if it&apos;s Firefox
    if (/Firefox\/(\S+)/.test(ua)){
        browser.ver = RegExp[&quot;$1&quot;];
        browser.firefox = parseFloat(browser.ver);
    }
} else if (/MSIE ([^;]+)/.test(ua)){
    engine.ver = browser.ver = RegExp[&quot;$1&quot;];
    engine.ie = browser.ie = parseFloat(engine.ver);
}

//detect browsers
browser.ie = engine.ie;
browser.opera = engine.opera;


//detect platform
var p = navigator.platform;
system.win = p.indexOf(&quot;Win&quot;) == 0;
system.mac = p.indexOf(&quot;Mac&quot;) == 0;
system.x11 = (p == &quot;X11&quot;) || (p.indexOf(&quot;Linux&quot;) == 0);

//detect windows operating systems
if (system.win){
    if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)){
        if (RegExp[&quot;$1&quot;] == &quot;NT&quot;){
            switch(RegExp[&quot;$2&quot;]){
                case &quot;5.0&quot;:
                    system.win = &quot;2000&quot;;
                    break;
                case &quot;5.1&quot;:
                    system.win = &quot;XP&quot;;
                    break;
                case &quot;6.0&quot;:
                    system.win = &quot;Vista&quot;;
                    break;
                case &quot;6.1&quot;:
                    system.win = &quot;7&quot;;
                    break;
                default:
                    system.win = &quot;NT&quot;;
                    break;
            }
        } else if (RegExp[&quot;$1&quot;] == &quot;9x&quot;){
            system.win = &quot;ME&quot;;
        } else {
            system.win = RegExp[&quot;$1&quot;];
        }
    }
}

//mobile devices
system.iphone = ua.indexOf(&quot;iPhone&quot;) &gt; -1;
system.ipod = ua.indexOf(&quot;iPod&quot;) &gt; -1;
system.ipad = ua.indexOf(&quot;iPad&quot;) &gt; -1;
system.nokiaN = ua.indexOf(&quot;NokiaN&quot;) &gt; -1;

//windows mobile
if (system.win == &quot;CE&quot;){
    system.winMobile = system.win;
} else if (system.win == &quot;Ph&quot;){
    if(/Windows Phone OS (\d+.\d+)/.test(ua)){;
        system.win = &quot;Phone&quot;;
        system.winMobile = parseFloat(RegExp[&quot;$1&quot;]);
    }
}


//determine iOS version
if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1){
    if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)){
        system.ios = parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;));
    } else {
        system.ios = 2;  //can&apos;t really detect - so guess
    }
}

//determine Android version
if (/Android (\d+\.\d+)/.test(ua)){
    system.android = parseFloat(RegExp.$1);
}

//gaming systems
system.wii = ua.indexOf(&quot;Wii&quot;) &gt; -1;
system.ps = /playstation/i.test(ua);

//return it
return {
    engine:     engine,
    browser:    browser,
    system:     system
};
</code></pre><p>}();<br>//闭包应用实例<br>var Counter = (function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>})();<br>// C11 matchesSelector()<br>function matchesSelector(element, selector){<br>    if (element.matchesSelector){<br>        return element.matchesSelector(selector);<br>    } else if (element.msMatchesSelector){<br>        return element.msMatchesSelector(selector);<br>    } else if (element.mozMatchesSelector){<br>        return element.mozMatchesSelector(selector);<br>    } else if (element.webkitMatchesSelector){<br>        return element.webkitMatchesSelector(selector);<br>    } else {<br>        throw new Error(“Not supported.”);<br>    }<br>}</p>
<p>if (matchesSelector(document.body, “body”)){<br>    alert(“It’s page 1!”);<br>}//C13跨浏览器事件处理程序<br>var EventUtil = {</p>
<pre><code>addHandler: function(element, type, handler){
    if (element.addEventListener){
        element.addEventListener(type, handler, false);
    } else if (element.attachEvent){
        element.attachEvent(&quot;on&quot; + type, handler);
    } else {
        element[&quot;on&quot; + type] = handler;
    }
},

getButton: function(event){
    if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)){
        return event.button;
    } else {
        switch(event.button){
            case 0:
            case 1:
            case 3:
            case 5:
            case 7:
                return 0;
            case 2:
            case 6:
                return 2;
            case 4: return 1;
        }
    }
},

getCharCode: function(event){
    if (typeof event.charCode == &quot;number&quot;){
        return event.charCode;
    } else {
        return event.keyCode;
    }
},

getClipboardText: function(event){
    var clipboardData =  (event.clipboardData || window.clipboardData);
    return clipboardData.getData(&quot;text&quot;);
},

getEvent: function(event){
    return event ? event : window.event;
},

getRelatedTarget: function(event){
    if (event.relatedTarget){
        return event.relatedTarget;
    } else if (event.toElement){
        return event.toElement;
    } else if (event.fromElement){
        return event.fromElement;
    } else {
        return null;
    }

},

getTarget: function(event){
    return event.target || event.srcElement;
},

getWheelDelta: function(event){
    if (event.wheelDelta){
        return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta);
    } else {
        return -event.detail * 40;
    }
},

preventDefault: function(event){
    if (event.preventDefault){
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
},

removeHandler: function(element, type, handler){
    if (element.removeEventListener){
        element.removeEventListener(type, handler, false);
    } else if (element.detachEvent){
        element.detachEvent(&quot;on&quot; + type, handler);
    } else {
        element[&quot;on&quot; + type] = null;
    }
},

setClipboardText: function(event, value){
    if (event.clipboardData){
        event.clipboardData.setData(&quot;text/plain&quot;, value);
    } else if (window.clipboardData){
        window.clipboardData.setData(&quot;text&quot;, value);
    }
},

stopPropagation: function(event){
    if (event.stopPropagation){
        event.stopPropagation();
    } else {
        event.cancelBubble = true;
    }
}
</code></pre><p>};<br>    //通过一个函数处理多个事件<br>var handler = function(event){<br>    switch(event.type){<br>        case “click”:<br>            alert(“Clicked”);<br>            break;</p>
<pre><code>    case &quot;mouseover&quot;:
        event.target.style.backgroundColor = &quot;red&quot;;
        break;

    case &quot;mouseout&quot;:
        event.target.style.backgroundColor = &quot;&quot;;
        break;
}
</code></pre><p>};<br>    //touch事件<br>function handleTouchEvent(event){<br>    //only for one touch<br>    if (event.touches.length == 1){</p>
<pre><code>    var output = document.getElementById(&quot;output&quot;);
    switch(event.type){
        case &quot;touchstart&quot;:
            output.innerHTML = &quot;Touch started (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;;
            break;
        case &quot;touchend&quot;:
            output.innerHTML += &quot;&lt;br&gt;Touch ended (&quot; + event.changedTouches[0].clientX + &quot;,&quot; + event.changedTouches[0].clientY + &quot;)&quot;;
            break;
        case &quot;touchmove&quot;:
            event.preventDefault();  //prevent scrolling
            output.innerHTML += &quot;&lt;br&gt;Touch moved (&quot; + event.changedTouches[0].clientX + &quot;,&quot; + event.changedTouches[0].clientY + &quot;)&quot;;
            break;
    }
}
</code></pre><p>}<br>document.addEventListener(“touchstart”, handleTouchEvent, false);<br>document.addEventListener(“touchend”, handleTouchEvent, false);<br>document.addEventListener(“touchmove”, handleTouchEvent, false);<br>    //EventDelegation事件委托<br>(function(){<br>var list = document.getElementById(“myLinks”);</p>
<p>EventUtil.addHandler(list, “click”, function(event){<br>    event = EventUtil.getEvent(event);<br>    var target = EventUtil.getTarget(event);</p>
<pre><code>switch(target.id){
    case &quot;doSomething&quot;:
        document.title = &quot;I changed the document&apos;s title&quot;;
        break;

    case &quot;goSomewhere&quot;:
        location.href = &quot;http://www.wrox.com&quot;;
        break;

    case &quot;sayHi&quot;:
        alert(&quot;hi&quot;);
        break;
}
</code></pre><p>});</p>
<p>})();<br>// C14 表单自动切换焦点<br>(function(){</p>
<pre><code>function tabForward(event){
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);

    if (target.value.length == target.maxLength){
        var form = target.form;

        for (var i=0, len=form.elements.length; i &lt; len; i++) {
            if (form.elements[i] == target) {
                if (form.elements[i+1]){
                    form.elements[i+1].focus();
                }
                return;
            }
        }
    }
}

var textbox1 = document.getElementById(&quot;txtTel1&quot;),
    textbox2 = document.getElementById(&quot;txtTel2&quot;),
    textbox3 = document.getElementById(&quot;txtTel3&quot;);

EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward);
EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward);
EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);
</code></pre><p>})();<br>    //表单序列化<br>function serialize(form){<br>    var parts = [],<br>        field = null,<br>        i,<br>        len,<br>        j,<br>        optLen,<br>        option,<br>        optValue;</p>
<pre><code>for (i=0, len=form.elements.length; i &lt; len; i++){
    field = form.elements[i];

    switch(field.type){
        case &quot;select-one&quot;:
        case &quot;select-multiple&quot;:

            if (field.name.length){
                for (j=0, optLen = field.options.length; j &lt; optLen; j++){
                    option = field.options[j];
                    if (option.selected){
                        optValue = &quot;&quot;;
                        if (option.hasAttribute){
                            optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text);
                        } else {
                            optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text);
                        }
                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue));
                    }
                }
            }
            break;

        case undefined:     //fieldset
        case &quot;file&quot;:        //file input
        case &quot;submit&quot;:      //submit button
        case &quot;reset&quot;:       //reset button
        case &quot;button&quot;:      //custom button
            break;

        case &quot;radio&quot;:       //radio button
        case &quot;checkbox&quot;:    //checkbox
            if (!field.checked){
                break;
            }
        /* falls through */

        default:
            //don&apos;t include form fields without names
            if (field.name.length){
                parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value));
            }
    }
}
return parts.join(&quot;&amp;&quot;);
</code></pre><p>}<br>var btn = document.getElementById(“serialize-btn”);<br>EventUtil.addHandler(btn, “click”, function(event){<br>    var form = document.forms[0];<br>    alert(serialize(form));<br>});<br>// C21 XHR兼容性判断<br>function createXHR(){<br>    if (typeof XMLHttpRequest != “undefined”){<br>        return new XMLHttpRequest();<br>    } else if (typeof ActiveXObject != “undefined”){<br>        if (typeof arguments.callee.activeXString != “string”){<br>            var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                    “MSXML2.XMLHttp”],<br>                i, len;</p>
<pre><code>        for (i=0,len=versions.length; i &lt; len; i++){
            try {
                new ActiveXObject(versions[i]);
                arguments.callee.activeXString = versions[i];
                break;
            } catch (ex){
                //skip
            }
        }
    }

    return new ActiveXObject(arguments.callee.activeXString);
} else {
    throw new Error(&quot;No XHR object available.&quot;);
}
</code></pre><p>}<br>var xhr = createXHR();<br>xhr.open(“get”, “example.txt”, false);<br>xhr.send(null);<br>if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){<br>    alert(xhr.statusText);<br>    alert(xhr.responseText);<br>} else {<br>    alert(“Request was unsuccessful: “ + xhr.status);<br>}<br>    //POST请求<br>(function(){<br>    function createXHR(){<br>        if (typeof XMLHttpRequest != “undefined”){<br>            return new XMLHttpRequest();<br>        } else if (typeof ActiveXObject != “undefined”){<br>            if (typeof arguments.callee.activeXString != “string”){<br>                var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                        “MSXML2.XMLHttp”],<br>                    i, len;</p>
<pre><code>            for (i=0,len=versions.length; i &lt; len; i++){
                try {
                    var xhr = new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    return xhr;
                } catch (ex){
                    //skip
                }
            }
        }

        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error(&quot;No XHR object available.&quot;);
    }
}

function serialize(form){
    var parts = new Array();
    var field = null;

    for (var i=0, len=form.elements.length; i &lt; len; i++){
        field = form.elements[i];

        switch(field.type){
            case &quot;select-one&quot;:
            case &quot;select-multiple&quot;:
                for (var j=0, optLen = field.options.length; j &lt; optLen; j++){
                    var option = field.options[j];
                    if (option.selected){
                        var optValue = &quot;&quot;;
                        if (option.hasAttribute){
                            optValue = (option.hasAttribute(&quot;value&quot;) ?
                                option.value : option.text);
                        } else {
                            optValue = (option.attributes[&quot;value&quot;].specified ?
                                option.value : option.text);
                        }
                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; +
                            encodeURIComponent(optValue));
                    }
                }
                break;

            case undefined:     //fieldset
            case &quot;file&quot;:        //file input
            case &quot;submit&quot;:      //submit button
            case &quot;reset&quot;:       //reset button
            case &quot;button&quot;:      //custom button
                break;

            case &quot;radio&quot;:       //radio button
            case &quot;checkbox&quot;:    //checkbox
                if (!field.checked){
                    break;
                }
            /* falls through */

            default:
                parts.push(encodeURIComponent(field.name) + &quot;=&quot; +
                    encodeURIComponent(field.value));
        }
    }
    return parts.join(&quot;&amp;&quot;);
}

function submitData(){
    var xhr = createXHR();
    xhr.onreadystatechange = function(event){
        if (xhr.readyState == 4){
            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
                alert(xhr.responseText);
            } else {
                alert(&quot;Request was unsuccessful: &quot; + xhr.status);
            }
        }
    };

    xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);
    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
    var form = document.getElementById(&quot;user-info&quot;);
    xhr.send(serialize(form));
}
</code></pre><p>})()<br>// C22高级技巧<br>//在任何值上调用Object原生的toString（）都会返回一个[[object NativeConstructorName]],<br>//每个类内部都有一个[[Class]]属性，就指定了上述字符串中的构造函数名。<br>//判断类型函数<br>function isArray(value){<br>    return Object.prototype.toString.call(value)===”[object Array]”<br>}<br>function isFunction(value){<br>    return Object.prototype.toString.call(value)===”[object Function]”<br>}<br>function isRegExp(value){<br>    return Object.prototype.toString.call(value)===”[object RegExp]”<br>}<br>function isString(value){<br>    return Object.prototype.toString.call(value)===”[object String]”<br>}<br>function isNumber(value){<br>    return Object.prototype.toString.call(value)===”[object Number]”<br>}<br>    //检测非原生?<br>function isNativeJSON(value){<br>    return window.JSON&amp;&amp;Object.prototype.call(value)===”[object JSON]”<br>}<br>    //作用域安全的构造函数<br>function Person(name, age, job){<br>    if (this instanceof Person){<br>        this.name = name;<br>        this.age = age;<br>        this.job = job;<br>    } else {<br>        return new Person(name, age, job);<br>    }<br>}<br>    //组合使用原型链或者寄生组合<br>function Polygon(sides){<br>    if (this instanceof Polygon) {<br>        this.sides = sides;<br>        this.getArea = function(){<br>            return 0;<br>        };<br>    } else {<br>        return new Polygon(sides);<br>    }<br>}<br>function Rectangle(width, height){<br>    Polygon.call(this, 2);<br>    this.width = width;<br>    this.height = height;<br>    this.getArea = function(){<br>        return this.width * this.height;<br>    };<br>}<br>Rectangle.prototype = new Polygon();<br>    //惰性载入<br>function createXHR(){<br>    if (typeof XMLHttpRequest != “undefined”){<br>        createXHR = function(){<br>            return new XMLHttpRequest();<br>        };<br>    } else if (typeof ActiveXObject != “undefined”){<br>        createXHR = function(){<br>            if (typeof arguments.callee.activeXString != “string”){<br>                var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                        “MSXML2.XMLHttp”],<br>                    i, len;</p>
<pre><code>            for (i=0,len=versions.length; i &lt; len; i++){
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                } catch (ex){
                    //skip
                }
            }
        }

        return new ActiveXObject(arguments.callee.activeXString);
    };
} else {
    createXHR = function(){
        throw new Error(&quot;No XHR object available.&quot;);
    };
}

return createXHR();
</code></pre><p>}<br>var createXHR = (function(){<br>    if (typeof XMLHttpRequest != “undefined”){<br>        return function(){<br>            return new XMLHttpRequest();<br>        };<br>    } else if (typeof ActiveXObject != “undefined”){<br>        return function(){<br>            if (typeof arguments.callee.activeXString != “string”){<br>                var versions = [“MSXML2.XMLHttp.6.0”, “MSXML2.XMLHttp.3.0”,<br>                        “MSXML2.XMLHttp”],<br>                    i, len;</p>
<pre><code>            for (i=0,len=versions.length; i &lt; len; i++){
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex){
                    //skip
                }
            }
        }

        return new ActiveXObject(arguments.callee.activeXString);
    };
} else {
    return function(){
        throw new Error(&quot;No XHR object available.&quot;);
    };
}
</code></pre><p>})();<br>    //函数柯里化<br>function curry(fn){<br>    var args = Array.prototype.slice.call(arguments, 1);<br>    return function(){<br>        var innerArgs = Array.prototype.slice.call(arguments),<br>            finalArgs = args.concat(innerArgs);<br>        return fn.apply(null, finalArgs);<br>    };<br>}<br>function bind(fn, context){<br>    var args = Array.prototype.slice.call(arguments, 2);<br>    return function(){<br>        var innerArgs = Array.prototype.slice.call(arguments),<br>            finalArgs = args.concat(innerArgs);<br>        return fn.apply(context, finalArgs);<br>    };<br>}<br>// C23 离线应用与客户端存储<br>var CookieUtil = {</p>
<pre><code>get: function (name){
    var cookieName = encodeURIComponent(name) + &quot;=&quot;,
        cookieStart = document.cookie.indexOf(cookieName),
        cookieValue = null,
        cookieEnd;

    if (cookieStart &gt; -1){
        cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart);
        if (cookieEnd == -1){
            cookieEnd = document.cookie.length;
        }
        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
    }

    return cookieValue;
},

set: function (name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);

    if (expires instanceof Date) {
        cookieText += &quot;; expires=&quot; + expires.toGMTString();
    }

    if (path) {
        cookieText += &quot;; path=&quot; + path;
    }

    if (domain) {
        cookieText += &quot;; domain=&quot; + domain;
    }

    if (secure) {
        cookieText += &quot;; secure&quot;;
    }

    document.cookie = cookieText;
},

unset: function (name, path, domain, secure){
    this.set(name, &quot;&quot;, new Date(0), path, domain, secure);
}
</code></pre><p>};<br>var SubCookieUtil = {</p>
<pre><code>get: function (name, subName){
    var subCookies = this.getAll(name);
    if (subCookies){
        return subCookies[subName];
    } else {
        return null;
    }
},

getAll: function(name){
    var cookieName = encodeURIComponent(name) + &quot;=&quot;,
        cookieStart = document.cookie.indexOf(cookieName),
        cookieValue = null,
        cookieEnd,
        subCookies,
        i,
        parts,
        result = {};

    if (cookieStart &gt; -1){
        cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart)
        if (cookieEnd == -1){
            cookieEnd = document.cookie.length;
        }
        cookieValue = document.cookie.substring(cookieStart + cookieName.length, cookieEnd);

        if (cookieValue.length &gt; 0){
            subCookies = cookieValue.split(&quot;&amp;&quot;);

            for (i=0, len=subCookies.length; i &lt; len; i++){
                parts = subCookies[i].split(&quot;=&quot;);
                result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
            }

            return result;
        }
    }

    return null;
},

set: function (name, subName, value, expires, path, domain, secure) {

    var subcookies = this.getAll(name) || {};
    subcookies[subName] = value;
    this.setAll(name, subcookies, expires, path, domain, secure);

},

setAll: function(name, subcookies, expires, path, domain, secure){

    var cookieText = encodeURIComponent(name) + &quot;=&quot;,
        subcookieParts = new Array(),
        subName;

    for (subName in subcookies){
        if (subName.length &gt; 0 &amp;&amp; subcookies.hasOwnProperty(subName)){
            subcookieParts.push(encodeURIComponent(subName) + &quot;=&quot; + encodeURIComponent(subcookies[subName]));
        }
    }

    if (subcookieParts.length &gt; 0){
        cookieText += subcookieParts.join(&quot;&amp;&quot;);

        if (expires instanceof Date) {
            cookieText += &quot;; expires=&quot; + expires.toGMTString();
        }

        if (path) {
            cookieText += &quot;; path=&quot; + path;
        }

        if (domain) {
            cookieText += &quot;; domain=&quot; + domain;
        }

        if (secure) {
            cookieText += &quot;; secure&quot;;
        }
    } else {
        cookieText += &quot;; expires=&quot; + (new Date(0)).toGMTString();
    }

    document.cookie = cookieText;

},

unset: function (name, subName, path, domain, secure){
    var subcookies = this.getAll(name);
    if (subcookies){
        delete subcookies[subName];
        this.setAll(name, subcookies, null, path, domain, secure);
    }
},

unsetAll: function(name, path, domain, secure){
    this.setAll(name, null, new Date(0), path, domain, secure);
}
</code></pre><p>};<br>function getLocalStorage(){<br>    if (typeof localStorage == “object”){<br>        return localStorage;<br>    } else if (typeof globalStorage == “object”){<br>        return globalStorage[location.host];<br>    } else {<br>        throw new Error(“Local storage not available.”);<br>    }<br>}</p>
<p>`</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Events]]></title>
      <url>https://github.com/yanlee26/blog/2016/03/03/events/</url>
      <content type="html"><![CDATA[<h1 id="web-events-值均为script"><a href="#web-events-值均为script" class="headerlink" title="web events(值均为script)"></a>web events(值均为script)</h1><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><ol>
<li>window事件属性（适用于body标签）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onafterprint</td>
<td style="text-align:center">在打印文档之后运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onbeforeprint</td>
<td style="text-align:center">在文档打印之前运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onbeforeonload</td>
<td style="text-align:center">在文档加载之前运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:center">当窗口失去焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:center">当错误发生时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onfocus</td>
<td style="text-align:center">当窗口获得焦点时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onhaschange</td>
<td style="text-align:center">当文档改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:center">当文档加载时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmessage</td>
<td style="text-align:center">当触发消息时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onoffline</td>
<td style="text-align:center">当文档离线时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ononline</td>
<td style="text-align:center">当文档上线时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpagehide</td>
<td style="text-align:center">当窗口隐藏时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpageshow</td>
<td style="text-align:center">当窗口可见时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpopstate</td>
<td style="text-align:center">当文档执行再执行操作（redo）时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onresize</td>
<td style="text-align:center">当调整窗口大小时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onstorage</td>
<td style="text-align:center">当文档加载加载时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onundo</td>
<td style="text-align:center">当 Web Storage 区域更新时（存储空间中的数据发生变化时）</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onunload</td>
<td style="text-align:center">当用户离开文档时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li><p>form事件属性(适用于所有h5元素，常用于表单)<br>| Properties    | Description | Mark|<br>| :———— |:————–:|—–:|<br>| onblur  | 当元素失去焦点时运行脚本||<br>| onchange  | 当元素改变时运行脚本||<br>| oncontextmenu  | 当触发上下文菜单时运行脚本|New|<br>| onfocus  | 当元素获得焦点时运行脚本|New|<br>| onformchange  | 当表单改变时运行脚本|New|<br>| onforminput  | 当表单获得用户输入时运行脚本|New|<br>| oninput  | 当元素获得用户输入时运行脚本|New|<br>| oninvalid  | 当元素无效时运行脚本|New|<br>| onreset  | 当表单重置时运行脚本。HTML 5 不支持||<br>| onselect  | 当选取元素时运行脚本||<br>| onsubmit  | 当提交表单时运行脚本||</p>
</li>
<li><p>keyboard事件(适用于所有h5元素)<br>| Properties    | Description | Mark|<br>| :———— |:————–:|—–:|<br>| onkeydown  | 当按下按键时运行脚本||<br>| onkeypress  | 当按下并松开按键时运行脚本||<br>| onkeyup  | 当松开按键时运行脚本||</p>
</li>
<li>mouse事件(适用于所有h5元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onclick</td>
<td style="text-align:center">当单击鼠标时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ondblclick</td>
<td style="text-align:center">当双击鼠标时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ondrag</td>
<td style="text-align:center">当拖动元素时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragend</td>
<td style="text-align:center">当拖动操作结束时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragenter</td>
<td style="text-align:center">当元素被拖动至有效的拖放目标时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragleave</td>
<td style="text-align:center">当元素离开有效拖放目标时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragover</td>
<td style="text-align:center">当元素被拖动至有效拖放目标上方时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondragstart</td>
<td style="text-align:center">当拖动操作开始时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondrop</td>
<td style="text-align:center">当被拖动元素正在被拖放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onmousedown</td>
<td style="text-align:center">当按下鼠标按钮时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmousemove</td>
<td style="text-align:center">当鼠标指针移动时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseout</td>
<td style="text-align:center">当鼠标指针移出元素时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseover</td>
<td style="text-align:center">当鼠标指针移至元素之上时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmouseup</td>
<td style="text-align:center">当松开鼠标按钮时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">onmousewheel</td>
<td style="text-align:center">当转动鼠标滚轮时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onscroll</td>
<td style="text-align:center">当滚动元素滚动元素的滚动条时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>media事件(适用于所有h5元素,常用于媒体元素)</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onabort</td>
<td style="text-align:center">当发生中止事件时运行脚本</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">oncanplay</td>
<td style="text-align:center">当媒介能够开始播放但可能因缓冲而需要停止时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">oncanplaythrough</td>
<td style="text-align:center">当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ondurationchange</td>
<td style="text-align:center">当媒介长度改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onemptied</td>
<td style="text-align:center">当媒介资源元素突然为空时（网络错误、加载错误等）运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onended</td>
<td style="text-align:center">当媒介已抵达结尾时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:center">当在元素加载期间发生错误时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadeddata</td>
<td style="text-align:center">当加载媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadedmetadata</td>
<td style="text-align:center">当媒介元素的持续时间以及其他媒介数据已加载时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onloadstart</td>
<td style="text-align:center">当浏览器开始加载媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onpause</td>
<td style="text-align:center">当媒介数据暂停时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onplay</td>
<td style="text-align:center">当媒介数据将要开始播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onplaying</td>
<td style="text-align:center">当媒介数据已开始播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onprogress</td>
<td style="text-align:center">当浏览器正在取媒介数据时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onratechange</td>
<td style="text-align:center">当媒介数据的播放速率改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onreadystatechange</td>
<td style="text-align:center">当就绪状态（ready-state）改变时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onseeked</td>
<td style="text-align:center">当媒介元素的定位属性 [1] 不再为真且定位已结束时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onseeking</td>
<td style="text-align:center">当媒介元素的定位属性为真且定位已开始时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onstalled</td>
<td style="text-align:center">当取回媒介数据过程中（延迟）存在错误时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onsuspend</td>
<td style="text-align:center">当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">ontimeupdate</td>
<td style="text-align:center">当媒介改变其播放位置时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onvolumechange</td>
<td style="text-align:center">当媒介改变音量亦或当音量被设置为静音时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
<tr>
<td style="text-align:left">onwaiting</td>
<td style="text-align:center">当媒介已停止播放但打算继续播放时运行脚本</td>
<td style="text-align:right">New</td>
</tr>
</tbody>
</table>
<ol>
<li>其它事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onshow</td>
<td style="text-align:center">当 <menu> 元素在上下文显示时触发</menu></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">ontoggle</td>
<td style="text-align:center">当用户打开或关闭 <details> 元素时触发</details></td>
</tr>
</tbody>
</table>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><blockquote>
<p> 理解click的300ms的延迟响应<br>   Click事件在移动手机开发中有300ms的延迟，因为在手机早期，浏览器系统有放大和缩放功能，用户在屏幕上点击两次之后，<br>   系统会触发放大或者缩放功能，因此系统做了一个处理，当触摸一次后，在300ms这段时间内有没有触摸第二次，<br>   如果触摸了第二次的话，说明是触发放大或缩放功能，否则的话是click事件。因此当click时候，所有用户必须等待于300ms后才<br>   会触发click事件。所以当在移动端使用click事件的时候，会感觉到有300ms的迟钝。</p>
</blockquote>
<ol>
<li>touch事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">touchstart</td>
<td style="text-align:center">当手指放在屏幕上触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchmove</td>
<td style="text-align:center">当手指在屏幕上滑动时，连续地触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchend</td>
<td style="text-align:center">当手指从屏幕上离开时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touchcancel</td>
<td style="text-align:center">当系统停止跟踪时触发; 该事件暂时使用不到</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">touches</td>
<td style="text-align:center">表示当前跟踪的触摸操作的touch对象的数组</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">targetTouches</td>
<td style="text-align:center">特定于事件目标的touch对象的数组</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">changedTouches</td>
<td style="text-align:center">上次触摸以来发生了什么改变的touch对象的数组</td>
</tr>
</tbody>
</table>
<ol>
<li>gesture事件</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">Properties</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">gesturestart</td>
<td style="text-align:center">当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">gesturechange</td>
<td style="text-align:center">当触摸屏幕的任何一个手指的位置发生改变的时候触发</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">gestureend</td>
<td style="text-align:center">当任何一个手指从屏幕上面移开时触发</td>
</tr>
</tbody>
</table>
<blockquote>
<p>触摸事件和手势事件的之间关系：<br>当一个手指放在屏幕上时，会触发touchstart事件，而另一个手指触摸在屏幕上时<br>触发gesturestart事件，随后触发基于该手指的touchstart事件。<br>如果一个或两个手指在屏幕上滑动时，将会触发gesturechange事件，但是只要有一个手指移开时候，则会触发gestureend事件，<br>紧接着会触发touchend事件。<br>手势的专有属性:<br>rotation: 表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从0开始；<br>scale: 表示2个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始的，并随距离拉大而增长。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS skills]]></title>
      <url>https://github.com/yanlee26/blog/2015/12/01/cssskills/</url>
      <content type="html"><![CDATA[<h1 id="CSS-使用技巧"><a href="#CSS-使用技巧" class="headerlink" title="CSS 使用技巧"></a>CSS 使用技巧</h1><ul>
<li>文字<ol>
<li>水平居中<br><code>text-aligh:center</code></li>
<li>垂直居中<br><code>div{height:35px;line-height:35px}//1/n容器高度</code></li>
</ol>
</li>
<li>容器<ol>
<li>水平居中<br><code>div{width:760px;margin:0 auto}</code></li>
<li>垂直居中<br><code>.outer{
 position:relative;
 height:480px;
}
.inner{
position:absolute;
top:50%;
height:240px;
margin-top:-120px;
//然后，将小容器定位为absolute，再将它的左上角沿y轴下移50%，最后将它margin-top上移本身高度的50%即可。
}</code></li>
</ol>
</li>
<li>图片宽度自适应<br>  <code>img{max-width:100%}</code></li>
<li>3D按钮<br>  <code>button {
　　　　background: #888;
　　　　border: 1px solid;
　　　　border-color: #999 #777 #777 #999;
　　}</code></li>
<li>font属性</li>
</ul>
<p><code>body { 
　　　　font-family: Arial, Helvetica, sans-serif; 
　　　　font-size: 13px; 
　　　　font-weight: normal; 
　　　　font-variant: small-caps; 
　　　　font-style: italic; 
　　　　line-height: 150%; 
　　}
body { 
　　　　font: italic small-caps normal 13px/150% Arial, Helvetica, sans-serif; 
　　}</code></p>
<ul>
<li>link状态设置顺序<br>  <code>a:link 
　　a:visited 
　　a:hover 
　　a:active</code></li>
<li><p>IE条件注释<br><code>&lt;!--[if IE]&gt; 
　　　　&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie-stylesheet.css&quot; /&gt; 
　　&lt; ![endif]--&gt;</code></p>
</li>
<li><p>CSS 优先级<br>`<br>　　行内样式 &gt; id样式 &gt; class样式 &gt; 标签名样式</p>
</li>
</ul>
<p>`</p>
<ul>
<li>font-size基准<br><code>body {font-size:62.5%;}
//浏览器的缺省字体大小是16px，你可以先将基准字体大小设为10px：</code></li>
<li>Text-transform和Font Variant<br><code>p {text-transform: uppercase} 
　　p {text-transform: lowercase} 
　　p {text-transform: capitalize}</code></li>
<li>reset<br>`</li>
</ul>
<p>`</p>
<ul>
<li>图片列表<br><code>ul {list-style: none}
　　ul li { 
　　　　background-image: url(&quot;path-to-your-image&quot;); 
　　　　background-repeat: none; 
　　　　background-position: 0 0.5em; 
　　}</code></li>
<li>三角形<br><code>.triangle { 
　　　　border-color: transparent transparent green transparent;
　　　　border-style: solid; 
　　　　border-width: 0px 300px 300px 300px; 
　　　　height: 0px; 
　　　　width: 0px; 
　　}</code></li>
<li>禁止自动换行<br><code>p { white-space:nowrap; }</code></li>
<li>用图片替换文字—有时我们需要在标题栏中使用图片，但是又必须保证搜索引擎能够读到标题<br><code>h1 { 
　　　　text-indent:-9999px; 
　　　　background:url(&quot;h1-image.jpg&quot;) no-repeat; 
　　　　width:200px; 
　　　　height:50px; 
　　}</code></li>
<li>焦点突出<br><code>input:focus { border: 2px solid green; }</code></li>
<li>CSS 提示框<br><code>&lt;a class=&quot;tooltip&quot; href=&quot;#&quot;&gt;链接文字 &lt;span&gt;提示文字&lt;/span&gt;&lt;/a&gt;
a.tooltip {position: relative} 
　　a.tooltip span {display:none; padding:5px; width:200px;} 
　　a:hover {background:#fff;} /*background-color is a must for IE6*/ 
　　a.tooltip:hover span{display:inline; position:absolute;}</code></li>
<li>固定位置<br><code>body{ margin:0;padding:100px 0 0 0;}
　　div#header{
　　　　position:absolute;
　　　　top:0;
　　　　left:0;
　　　　width:100%;
　　　　height:&lt;length&gt;;
　　}
　　@media screen{
　　　　body&gt;div#header{position: fixed;}
　　}
　　* html body{overflow:hidden;}
　　* html div#content{height:100%;overflow:auto;}</code></li>
<li>图片预加载<br><a href="https://perishablepress.com/3-ways-preload-images-css-javascript-ajax/" target="_blank" rel="external">预加载</a></li>
<li>CSS选择器<br><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="external">CSS选择器</a></li>
<li>背景图定位<br><a href="http://www.ruanyifeng.com/blog/2008/05/css_background_image_positioning.html" target="_blank" rel="external">定位</a></li>
</ul>
<h3 id="3D旋转视频展示区"><a href="#3D旋转视频展示区" class="headerlink" title="3D旋转视频展示区"></a>3D旋转视频展示区</h3><p>`</p>
<p><style><br>body {<br>    margin-top: 5em;<br>    text-align: center;<br>    color: #414142;<br>    background: rgb(246,241,232);<br>    /<em>制作多背景</em>/<br>    background-image: -ms-radial-gradient(farthest-side ellipse at center,  rgba(246,241,232,.85) 39%,rgba(212,204,186,.5) 100%), url(“<a href="http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg">http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg</a>“);<br>    background-image: -webkit-radial-gradient(farthest-side ellipse at center,  rgba(246,241,232,.85) 39%,rgba(212,204,186,.5) 100%), url(“<a href="http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg">http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg</a>“);<br>    background-image: radial-gradient( farthest-side ellipse at center,  rgba(246,241,232,.85) 39%,rgba(212,204,186,.5) 100%), url(“<a href="http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg">http://fs0.139js.com/file/s_jpg_857b081bjw1du3kveu19sj.jpg</a>“);<br>    /<em>控制背景图像尺寸</em>/<br>    background-size: cover;<br>}</p>
<p>h1, em, #information {<br>    display: block;<br>    font-size: 25px;<br>    font-weight: normal;<br>    margin: 2em auto;<br>}</p>
<p>a {<br>    color: #414142;<br>    font-style: normal;<br>    text-decoration: none;<br>    font-size: 20px;<br>}</p>
<p>a:hover {<br>    text-decoration: underline;<br>}</p>
<p>#container {<br>    margin: 0 auto;<br>    width: 1024px;<br>}</p>
<p>.wrapper {<br>    display: inline-block;<br>    width: 310px;<br>    height: 100px;<br>    vertical-align: top;<br>    margin: 1em 1.5em 2em 0;<br>    cursor: pointer;<br>    position: relative;<br>    font-family: Tahoma, Arial;<br>    -webkit-perspective: 4000px;<br>    -moz-perspective: 4000px;<br>    -ms-perspective: 4000px;<br>    -o-perspective: 4000px;<br>    perspective: 4000px;<br>}</p>
<p>.item {<br>    height: 100px;<br>    -webkit-transform-style: preserve-3d;<br>    -moz-transform-style: preserve-3d;<br>    -ms-transform-style: preserve-3d;<br>    -o-transform-style: preserve-3d;<br>    transform-style: preserve-3d;<br>    /<em>给每个列表项添加过渡动画效果</em>/<br>    -webkit-transition: -webkit-transform .6s;<br>    -moz-transition: -moz-transform .6s;<br>    -ms-transition: -ms-transform .6s;<br>    -o-transition: -o-transform .6s;<br>    transition: transform .6s;<br>}</p>
<p>.item:hover {<br>    /<em>悬浮状态改变每个列表项的transform效果</em>/<br>    -webkit-transform: translateZ(-50px) rotateX(95deg);<br>    -moz-transform: translateZ(-50px) rotateX(95deg);<br>    -ms-transform: translateZ(-50px) rotateX(95deg);<br>    -o-transform: translateZ(-50px) rotateX(95deg);<br>    transform: translateZ(-50px) rotateX(95deg);<br>}<br>.itemimg {<br>    display: block;<br>    position: absolute;<br>    top: 0;<br>    /<em>设置列表项图片的圆角和阴影效果</em>/<br>    border-radius: 3px;<br>    box-shadow: 0px 3px 8px rgba(0,0,0,0.3);<br>   -webkit-transform: translateZ(50px);<br>   -moz-transform: translateZ(50px);<br>   -ms-transform: translateZ(50px);<br>   -o-transform: translateZ(50px);<br>    transform: translateZ(50px);<br>   -webkit-transition: all .6s;<br>   -moz-transition: all .6s;<br>   -ms-transition: all .6s;<br>   -o-transition: all .6s;<br>    transition: all .6s;<br>    width: 310px;<br>    height: 100px;<br> }</p>
<p>.item .information {<br>    display: block;<br>    position: absolute;<br>    top: 0;<br>    height: 80px;<br>    width: 290px;<br>    text-align: left;<br>    border-radius: 15px;<br>    padding: 10px;<br>    font-size: 12px;<br>    text-shadow: 1px 1px1pxrgba(255,255,255,0.5);<br>    box-shadow: none;<br>    background: rgb(236,241,244);<br>    /<em>给底层显示文本的层级设置渐变效果</em>/<br>    background: -webkit-linear-gradient(to bottom,  rgba(236,241,244,1) 0%,rgba(190,202,217,1) 100%);<br>    background: -ms-linear-gradient(to bottom,  rgba(236,241,244,1) 0%,rgba(190,202,217,1) 100%);<br>    background: linear-gradient(to bottom,  rgba(236,241,244,1) 0%,rgba(190,202,217,1) 100%);<br>    -webkit-transform: rotateX(-90deg) translateZ(50px);<br>    -moz-transform: rotateX(-90deg) translateZ(50px);<br>    -ms-transform: rotateX(-90deg) translateZ(50px);<br>    -o-transform: rotateX(-90deg) translateZ(50px);<br>    transform: rotateX(-90deg) translateZ(50px);<br>    -webkit-transition: all .6s;<br>    -moz-transition: all .6s;<br>    -ms-transition: all .6s;<br>    -o-transition: all .6s;<br>    transition: all .6s;<br> }</p>
<p>.information strong {<br>    display: block;<br>    margin: .2em 0 .5em 0;<br>    font-size: 20px;<br>    font-family: “Oleo Script”;<br>  }<br>.item:hoverimg {<br>    /<em>列表项悬浮状态时，去掉图片的阴影效果</em>/<br>    box-shadow: none;<br>    border-radius: 15px;<br>}</p>
<p>.item:hover .information {<br>    box-shadow: 0px 3px 8px rgba(0,0,0,0.3);<br>    border-radius: 3px;<br> }<br></style></p>
<div id="container"><br>        <h1>CSS3 3D变形制作视频展示区</h1><br>        <div class="wrapper"><br>            <div class="item"><br>                <img src="http://pic2.qiyipic.com/image/20140415/4e/32/5f/v_105669963_m_601_180_101.jpg"><br>                <span class="information"><br>                    <strong>澳门风云</strong>闻名中外，曾担任美国赌场保安总顾问的魔术手石一坚，终回流澳门退休，更宴请各方朋友到来庆祝生日宴.<br>                </span><br>            </div><br>        </div>

<pre><code>    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic4.qiyipic.com/image/20140417/b5/01/81/a_100003950_m_601_m2_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;改过迁善&lt;/strong&gt;该剧讲述了金明民饰演的律师在失忆后回顾自己以往的所作所为心生忏悔，为弥补自己犯下的错误而与自己曾经工作过的律师事务所对簿公堂的故事。
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic1.qiyipic.com/common/lego/20140521/4515581d06cc4d5b8ab320da2cf3778d.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;父子刑警&lt;/strong&gt;本剧改编自雫井修介小说《Bitter Blood》。剧中，新晋刑警•佐原夏辉（佐藤健饰）被分配到银座警察
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic5.qiyipic.com/image/20140319/7a/8d/4f/a_100003478_m_601_m1_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;果宝特攻3&lt;/strong&gt;果宝特攻3,顾名思义是果宝特攻的第二部续集,已在国家广播电影电视总局备案.暂定剧情为:菠萝吹雪偶然间穿越到了古代的水果世界
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic0.qiyipic.com/image/20140517/ce/e8/42/v_106167752_m_601_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;红眼&lt;/strong&gt;1988年7月16日，从汉城始发的列车发生了一起严重的交通事故，造成100多人死亡。
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;img src=&quot;http://pic6.qiyipic.com/image/20140303/da/e9/aa/v_105073913_m_601_180_101.jpg&quot; /&gt;
            &lt;span class=&quot;information&quot;&gt;
            &lt;strong&gt;熊出没之夺宝熊兵&lt;/strong&gt;一场漆黑雨夜的意外事故，一段笑料十足的误打误撞，将两个外表相似却内容各异的箱子调换。
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>`</p>
<ul>
<li>分页<br>`<br>ul.pagination {<br>  display: inline-block;<br>  padding: 0;<br>  margin: 0;<br>}</li>
</ul>
<p>ul.pagination li {display: inline;}</p>
<p>ul.pagination li a {<br>    color: black;<br>    float: left;<br>    padding: 8px 16px;<br>    text-decoration: none;<br>}</p>
<p>ul.pagination li a.active {<br>    background-color: #4CAF50;<br>    color: white;<br>}</p>
<p>ul.pagination li a:hover:not(.active) {background-color: #ddd;}<br>//html<br>ul.pagination&gt;li&gt;a<em>8<br>//面包屑导航<br>ul.breadcrumb {<br>    padding: 8px 16px;<br>    list-style: none;<br>    background-color: #eee;<br>}<br>ul.breadcrumb li {display: inline;}<br>ul.breadcrumb li+li:before {<br>    padding: 8px;<br>    color: black;<br>    content: “/\00a0”;<br>}<br>ul.breadcrumb li a {color: green;}<br>//html<br>ul&gt;li&gt;a</em>5<br>`</p>
</div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Common tips]]></title>
      <url>https://github.com/yanlee26/blog/2015/09/03/common/</url>
      <content type="html"><![CDATA[<h1 id="JS经典案例"><a href="#JS经典案例" class="headerlink" title="JS经典案例"></a>JS经典案例</h1><h3 id="图片轮播jquery"><a href="#图片轮播jquery" class="headerlink" title="图片轮播jquery"></a>图片轮播jquery</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">	&lt;title&gt;图片轮播&lt;/title&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		body,div,span,img,a&#123;margin:0;padding: 0;text-decoration: none;&#125;</div><div class="line">		#container&#123;position: relative;width: 400px;height: 450px;overflow: hidden;margin: 20px auto;border:3px solid red;&#125;</div><div class="line">		#list&#123;width: 2800px;height: 450px;position: absolute;z-index: 1;&#125;</div><div class="line">		#list img&#123;width: 400px;height: 450px;float: left;&#125;</div><div class="line">		#buttons&#123;position: absolute;float: left;width: 100px;height: 10px;bottom:50px;left:175px;z-index: 2;&#125;</div><div class="line">		#buttons span&#123;float:left;height: 10px;width: 10px;margin-right: 5px;cursor: pointer;border:1px solid #000;border-radius: 50%;background: #ccc;z-index: 2;&#125;</div><div class="line">		#buttons .on&#123;background: red;&#125;</div><div class="line">		.arrow&#123;cursor: pointer; display: none;position:absolute;height: 30px;width: 30px;top:175px;font-size: 25px;line-height: 25px;text-align:center;color: #ccc;z-index: 2;background-color: RGBA(0,0,0,.3);&#125;</div><div class="line">		.arrow:hover&#123;background-color: RGBA(0,0,0,.6);&#125;</div><div class="line">		#container:hover .arrow&#123;display: block;&#125;</div><div class="line">		#prev&#123;left: 25px;&#125;</div><div class="line">		#next&#123;right: 25px;&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">	&lt;script&gt;</div><div class="line">		window.onload=function () &#123;//页面加载调用</div><div class="line">			var container=document.getElementById(&apos;container&apos;);</div><div class="line">			var list=document.getElementById(&apos;list&apos;);</div><div class="line">			var buttons=document.getElementById(&apos;buttons&apos;).getElementsByTagName(&apos;span&apos;);</div><div class="line">			var prev=document.getElementById(&apos;prev&apos;);</div><div class="line">			var next=document.getElementById(&apos;next&apos;);</div><div class="line">			var index=1;//用于索引当前按钮</div><div class="line">			var len=5;//图片数量</div><div class="line">			var animated = false;//判断切换是否进行</div><div class="line">			var interval = 3000;//自动播放计时器3s</div><div class="line">			var timer;//定时器</div><div class="line">			 function animate (offset) &#123;//动画切换</div><div class="line">			 	animated=true;//切换进行中</div><div class="line">			 	var time=300;//位移总时间</div><div class="line">			 	var inteval=10;//位移时间间隔</div><div class="line">			 	var times=time/inteval;//位移次数</div><div class="line">                var speed = offset/times;//位移速度</div><div class="line">			 	var left= parseInt(list.style.left)+offset;//目标值</div><div class="line"></div><div class="line"></div><div class="line">			 	var go=function () &#123;</div><div class="line">			 		//这两种情况表示还在切换中</div><div class="line">                    if ( (speed &gt; 0 &amp;&amp; parseInt(list.style.left) &lt; left) || (speed &lt; 0 &amp;&amp; parseInt(list.style.left) &gt; left)) &#123;</div><div class="line">                        list.style.left = parseInt(list.style.left) + speed + &apos;px&apos;;</div><div class="line">                        setTimeout(go, inteval);//继续执行切换go()函数  </div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        list.style.left = left+ &apos;px&apos;;</div><div class="line">		                if(left&lt;-400*len)&#123;</div><div class="line">		                	list.style.left=&quot;-400px&quot;;</div><div class="line">		                &#125;</div><div class="line">		                if(left&gt;-400)&#123;</div><div class="line">		                	list.style.left=-400*len+&quot;px&quot;;</div><div class="line">		                &#125;</div><div class="line">                        animated = false;//切换完成 </div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                go();</div><div class="line">			 	&#125;</div><div class="line">                </div><div class="line">           </div><div class="line">           //用于为按钮添加样式</div><div class="line">		    function showButton() &#123;     </div><div class="line">		       //先找出原来有.on类的按钮，并移除其类</div><div class="line">		        for (var i = 0; i &lt; buttons.length ; i++) &#123;  </div><div class="line">		                  if( buttons[i].className == &apos;on&apos;)&#123;</div><div class="line">		                buttons[i].className = &apos;&apos;;     </div><div class="line">		                           break;</div><div class="line">		            &#125;</div><div class="line">		        &#125;        </div><div class="line">		        //为当前按钮添加类，索引下标从0开始，故需减1</div><div class="line">		        buttons[index - 1].className = &apos;on&apos;;</div><div class="line">		    &#125;</div><div class="line"></div><div class="line">//自动播放</div><div class="line">            function play() &#123;</div><div class="line">                timer = setTimeout(function () &#123;</div><div class="line">                    next.onclick();</div><div class="line">                    play();</div><div class="line">                &#125;, interval);</div><div class="line">            &#125;</div><div class="line">            //清除定时器</div><div class="line">            function stop() &#123;</div><div class="line">                clearTimeout(timer);</div><div class="line">            &#125;</div><div class="line">//右点击</div><div class="line">           next.onclick = function () &#123;</div><div class="line">           		if (animated) &#123;//如果切换还在进行，则直接结束，直到切换完成</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">           		if(index==5)&#123;</div><div class="line">           			index=1;</div><div class="line">           			&#125;</div><div class="line">           			else&#123;</div><div class="line">           				index+=1;</div><div class="line">           			&#125;           		</div><div class="line">                animate(-400);</div><div class="line">                showButton();</div><div class="line">            &#125;</div><div class="line"> //左点击          </div><div class="line">            prev.onclick = function () &#123;</div><div class="line">    			if (animated) &#123;//如果切换还在进行，则直接结束，直到切换完成</div><div class="line">    	         return;</div><div class="line">        	     &#125;</div><div class="line">            	if(index==1)&#123;</div><div class="line">            		index=5;</div><div class="line">            		&#125;</div><div class="line">            		else&#123;</div><div class="line">            			index-=1;</div><div class="line">            		&#125;</div><div class="line">            	</div><div class="line">                animate(400);</div><div class="line">                showButton(); </div><div class="line">                &#125;</div><div class="line">               </div><div class="line">            //通过循环为按钮添加点击事件</div><div class="line">            for (var i=0;i&lt;buttons.length;i++) &#123;</div><div class="line">            	buttons[i].onclick=function() &#123;</div><div class="line">            		if (animated) &#123;//如果切换还在进行，则直接结束，直到切换完成</div><div class="line">	    	         return;</div><div class="line">	        	     &#125;</div><div class="line">                  	//当继续点击按钮时不切换</div><div class="line">                  	if(this.className==&apos;on&apos;)&#123;</div><div class="line">                  		return;</div><div class="line">                  	&#125;</div><div class="line">                  	//通过获取按钮的标签自定义属性index，得到索引值，再计算差值</div><div class="line">                  	var myIndex=parseInt(this.getAttribute(&apos;index&apos;));</div><div class="line">                  	//真正的偏移量</div><div class="line">                  	var offset=-400*(myIndex-index);</div><div class="line">                  	animate(offset);</div><div class="line">                  	//将点击按钮的index属性置为当前</div><div class="line">                  	index=myIndex;</div><div class="line">                  	showButton();</div><div class="line">                  &#125;  </div><div class="line">              &#125; </div><div class="line">	//父容器的移入移出事件</div><div class="line">            container.onmouseover = stop;</div><div class="line">            container.onmouseout = play;</div><div class="line">            play();//自动播放</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=&quot;container&quot;&gt;</div><div class="line">		&lt;div id=&apos;list&apos; style=&apos;left: -400px&apos;&gt;</div><div class="line">			&lt;img src=&quot;img/5.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">			&lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">			&lt;img src=&quot;img/2.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">			&lt;img src=&quot;img/3.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">			&lt;img src=&quot;img/4.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">			&lt;img src=&quot;img/5.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">			&lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;div id=&apos;buttons&apos;&gt;</div><div class="line">			&lt;span index=&apos;1&apos; class=&quot;on&quot;&gt;&lt;/span&gt;</div><div class="line">			&lt;span index=&apos;2&apos;&gt;&lt;/span&gt;</div><div class="line">			&lt;span index=&apos;3&apos;&gt;&lt;/span&gt;</div><div class="line">			&lt;span index=&apos;4&apos;&gt;&lt;/span&gt;</div><div class="line">			&lt;span index=&apos;5&apos;&gt;&lt;/span&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;a href=&quot;javascript:;&quot; id=&apos;prev&apos; class=&quot;arrow&quot;&gt;&amp;lt;&lt;/a&gt;</div><div class="line">		&lt;a href=&quot;javascript:;&quot; id=&apos;next&apos; class=&quot;arrow&quot;&gt;&amp;gt;&lt;/a&gt;		</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="瀑布流js"><a href="#瀑布流js" class="headerlink" title="瀑布流js"></a>瀑布流js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[How browsers work?]]></title>
      <url>https://github.com/yanlee26/blog/2015/07/02/browsers_work/</url>
      <content type="html"><![CDATA[<h1 id="标准浏览器的幕后"><a href="#标准浏览器的幕后" class="headerlink" title="标准浏览器的幕后"></a>标准浏览器的幕后</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>所谓的浏览器<h3 id="主流浏览器：IE-FF-Safari-Chrome-Opera"><a href="#主流浏览器：IE-FF-Safari-Chrome-Opera" class="headerlink" title="主流浏览器：IE,FF,Safari,Chrome,Opera"></a>主流浏览器：IE,FF,Safari,Chrome,Opera</h3></li>
</ul>
<ul>
<li>部分开源的有FF,Chrome,Safari，W3C统计这三大浏览器占领市场的6成份额。</li>
</ul>
<ul>
<li>浏览器主要功能特性<blockquote>
<p>The browser main functionality is to present the web resource you choose, by requesting it from the server and displaying it on the browser window. </p>
</blockquote>
</li>
</ul>
<ul>
<li>浏览器的主要功能是呈现你所选择的资源，通过向服务端请求并展示在浏览器窗口。</li>
<li>浏览器用户交互有很多类似之处，其中便是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Address bar for inserting the URI---url地址栏</div><div class="line">Back and forward buttons---前进后退按钮</div><div class="line">Bookmarking options---书签选择</div><div class="line">A refresh and stop buttons for refreshing and stopping the loading of current documents---刷新和停止刷新和阻止加载当前文档</div><div class="line">Home button that gets you to your home page---主页</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Strangely enough, the browser’s user interface is not specified in any formal specification, it is just good practices shaped over years of experience and by browsers imitating each other(浏览器用户界面并非以任何标准区分而区分，而是多年的应用习惯塑造了了其不谋而合的特性). The HTML5 specification doesn’t define UI elements a browser must have, but lists some common elements. Among those are the address bar, status bar and tool bar. There are, of course, features unique to a specific browser like Firefox downloads manager.<br>More on that in the user interface chapter.</p>
<ul>
<li>浏览器高水平结构<h3 id="主要组件如下"><a href="#主要组件如下" class="headerlink" title="主要组件如下"></a>主要组件如下</h3></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.The user interface （UI界面）- this includes the address bar, back/forward button, bookmarking menu etc. Every part of the browser display except the main window where you see the requested page.</div><div class="line">2.The browser engine（引擎） - the interface for querying and manipulating the rendering engine.</div><div class="line">3. The rendering engine（渲染引擎） - responsible for displaying the requested content. For example if the requested content is HTML, it is responsible for parsing the HTML and CSS and displaying the parsed content on the screen.</div><div class="line">4. Networking（网络） - used for network calls, like HTTP requests. It has platform independent interface and underneath implementations for each platform.</div><div class="line">5. UI backend（UI后端） - used for drawing basic widgets like combo boxes and windows. It exposes a generic interface that is not platform specific. Underneath it uses the operating system user interface methods.</div><div class="line">6. JavaScript interpreter（JS解释器）. Used to parse and execute the JavaScript code.</div><div class="line">7.Data storage（数据存储）. This is a persistence layer. The browser needs to save all sorts of data on the hard disk, for examples, cookies. The new HTML specification (HTML5) defines &apos;web database&apos; which is a complete (although light) database in the browser.</div></pre></td></tr></table></figure>
<p><img src="http://img.mukewang.com/582dba090001a25806270387.png" alt="browser 主要组件"><br>*请注意，Chrome与大多数浏览器不同，它拥有多个呈现引擎实例，每个标签一个。 每个选项卡是一个单独的过程。</p>
<ul>
<li>组件通信</li>
</ul>
<ul>
<li>FF和Chrome都有专门的通信结构，下边讨论。<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><blockquote>
<p>The responsibility of the rendering engine is well… Rendering, that is display of the requested contents on the browser screen.</p>
</blockquote>
</li>
<li>渲染即在浏览器上显示请求的内容<br>By default the rendering engine can display HTML and XML documents and images. It can display other types through a plug-in (a browser extension). An example is displaying PDF using a PDF viewer plug-in. We will talk about plug-ins and extensions in a special chapter. In this chapter we will focus on the main use case - displaying HTML and images that are formatted using CSS.</li>
</ul>
<ol>
<li>渲染引擎—Rendering engines<blockquote>
<p>Our reference browsers - Firefox, Chrome and Safari are built upon two rendering engines. Firefox uses Gecko - a “home made” Mozilla rendering engine. Both Safari and Chrome use Webkit.</p>
</blockquote>
</li>
</ol>
<ul>
<li>FF,Chrome,Safari 建立在两个引擎之上。FF运用Gecko内核—一个家装的Mozilla渲染引擎。Safari和Chorme用的是Webkit内核。<br>Webkit is an open source rendering engine which started as an engine for the Linux platform and was modified by Apple to support Mac and Windows. See <a href="http://webkit.org/" target="_blank" rel="external">http://webkit.org/</a> for more details.</li>
<li>Webkit是一个开源渲染引擎，起初在linux平台作引擎并被Apple改造应用到Mac和window系统。</li>
</ul>
<ol>
<li>主流（main flow）<blockquote>
<p>The rendering engine will start getting the contents of the requested document from the networking layer. This will usually be done in 8K chunks.</p>
</blockquote>
</li>
</ol>
<ul>
<li>渲染引擎从网络层获取文档内容，这通常在8k快完成。<img src="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" alt=""></li>
<li>渲染引擎将以解析html文档和转换标签到所谓的文档树—DOM节点上开始。它将解析样式数据，包含内敛样式和外联样式。这些样式信息以及可视化的指令将用于创建另一个树–渲染树。</li>
<li>渲染树包含具有视觉属性（visual attributes如颜色和尺寸）的矩形。 矩形以正确的顺序显示在屏幕上。<br>在渲染树的构造之后，它经过<strong>“布局(layout)”</strong>过程。 这意味着给每个节点在其应该出现在屏幕上的确切坐标。 下一个阶段是<strong>绘画(pianting)</strong> - 渲染树将被遍历，每个节点将使用UI后端图层绘制。<br>重要的是要了解这是一个<strong>渐进(gtadual process)</strong>的过程。 为了获得更好的用户体验，渲染引擎将尽快尝试在屏幕上显示内容。 它不会等到所有的HTML被解析之后才开始构建和布局渲染树。 内容的一部分将被解析和显示，同时该过程继续保持来自网络的其余内容。</li>
</ul>
<ol>
<li>主流示例, 解析和DOM树结构<br><img src="http://img.mukewang.com/582dbd3e0001335605000393.png" alt="Webkit main flow"><br><img src="http://img.mukewang.com/582dbfd100014e8107310396.png" alt="Mozilla&#39;s Gecko rendering engine main flow"><blockquote>
<p>Although Webkit and Gecko use slightly different terminology, the flow is basically the same.<br>a.一般解析</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<p>Since parsing is a very significant(重要，有意义) process within the rendering engine, we will go into it a little more deeply. Let’s begin with a little introduction about parsing.<br>Parsing a document means translating it to some structure that makes sense（转换成有意义的结构） - something the code can understand and use. The result of parsing is usually a tree of nodes that represent the structure of the document（解析的结果通常是表示文档结构的节点树）. It is called a parse tree or a syntax tree（解析树||语法树）.</p>
</blockquote>
</li>
</ul>
<ul>
<li>Parsing is based on the syntax rules the document obeys - the language or format it was written in. Every format you can parse must have deterministic（确定性） grammar consisting of vocabulary and syntax rules. It is called a context free grammar. Human languages are not such languages and therefore cannot be parsed with conventional parsing techniques.</li>
</ul>
<ul>
<li>Parser +Lexer combination组合<blockquote>
<p>arsing can be separated into two sub processes - lexical analysis and syntax analysis.<br>Lexical analysis is the process of breaking the input into tokens(词法分析是将输入分解成符记的过程). Tokens are the language vocabulary - the collection of valid building blocks. In human language it will consist of all the words that appear in the dictionary for that language.<br>Syntax analysis is the applying of the language syntax rules（语法分析就是语言语法规则的运用）.<br>Parsers usually divide the work between two components - the lexer(sometimes called tokenizer) that is responsible for breaking the input into valid tokens, and the parser that is responsible for constructing the parse tree by analyzing the document structure according to the language syntax rules. The lexer knows how to strip irrelevant characters like white spaces and line breaks.<br><img src="http://img.mukewang.com/582e362c0001b3a506400407.png" alt="from source document to parse trees"></p>
</blockquote>
</li>
</ul>
<ul>
<li>The parsing process is iterative. The parser will usually ask the lexer for a new token and try to match the token with one of the syntax rules. If a rule is matched, a node corresponding to the token will be added to the parse tree and the parser will ask for another token.<br>If no rule matches, the parser will store the token internally, and keep asking for tokens until a rule matching all the internally stored tokens is found. If no rule is found then the parser will raise an exception. This means the document was not valid and contained syntax errors.</li>
</ul>
<ul>
<li>Translation改变<blockquote>
<p>Many times the parse tree is not the final product. Parsing is often used in translation - transforming the input document to another format. An example is compilation. The compiler that compiles a source code into machine code first parses it into a parse tree and then translates the tree into a machine code document.<br><img src="http://img.mukewang.com/582e3a850001ce7405000294.png" alt="compilation flow"></p>
</blockquote>
</li>
<li><p>解析示例</p>
</li>
<li><p>Formal definitions for vocabulary and syntax词法标准定义<br>Vocabulary is usually expressed by <a href="http://www.regular-expressions.info/" target="_blank" rel="external">regular expressions</a>.<br>We said that a language can be parsed by regular parsers if its grammar is a context frees grammar. An intuitive definition of a context free grammar is a grammar that can be entirely expressed in BNF. For a formal definition see <a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="external">http://en.wikipedia.org/wiki/Context-free_grammar</a></p>
</li>
<li>Types of parsers解析器类型<br>There are two basic types of parsers - top down parsers(自上而下) and bottom up parsers（自下而上）.</li>
<li>Generating parsers automatically—自动生成解析器<blockquote>
<p>There are tools that can generate a parser for you. They are called parser generators(解析生成器). You feed them with the grammar of your language - its vocabulary and syntax rules and they generate a working parser. Creating a parser requires a deep understanding of parsing and its not easy to create an optimized parser by hand, so parser generators can be very useful.<br>Webkit uses two well known parser generators - <strong><em>Flex</em></strong> for creating a lexer and <strong><em>Bison</em></strong> for creating a parser (you might run into them with the names Lex and Yacc). Flex input is a file containing regular expression definitions of the tokens. Bison’s input is the language syntax rules in BNF format.<br>b. HTML Parser—html解析： to parse the HTML markup into a parse tree.</p>
</blockquote>
</li>
<li>html语法定义<blockquote>
<p>The vocabulary and syntax of HTML are defined in <a href="http://img.mukewang.com/582e3aaa00017cbb04000305.png" target="_blank" rel="external">specifications</a>created by the w3c organization. The current version is HTML4 and work on HTML5 is in progress.</p>
</blockquote>
</li>
<li>非自由上下文（context free）语法<blockquote>
<p>As we have seen in the parsing introduction, grammar syntax can be defined formally using formats like BNF.<br>Unfortunately all the conventional parser topics do not apply to HTML (I didn’t bring them up just for fun - they will be used in parsing CSS and JavaScript). HTML cannot easily be defined by a context free grammar that parsers need.<br>There is a formal format for defining HTML -<strong><em> DTD</em></strong> (Document Type Definition) - but it is not a context free grammar.<br>This appears strange at first site - HTML is rather close to XML .There are lots of available XML parsers. There is an XML variation of HTML - XHTML - so what’s the big difference?<br>The difference is that HTML approach is more <strong><em>“forgiving”</em></strong>, it lets you omit certain tags which are added implicitly, sometimes omit the start or end of tags etc. On the whole it’s a “soft” syntax, as opposed to XML’s stiff and demanding syntax.<br>Apparently this seemingly small difference makes a world of a difference. On one hand this is the main reason why HTML is so popular - it forgives your mistakes and makes life easy for the web author. On the other hand, it makes it difficult to write a format grammar. So to summarize - HTML cannot be parsed easily, not by conventional parsers since its grammar is not a context free grammar, and not by XML parsers(html不能由常规解析器轻易解析，因为它的语法不是上下文自由的语法，不能由XML解析器（解析）).</p>
</blockquote>
</li>
<li>HTML DTD<blockquote>
<p>DTD有一些变体。 严格模式仅符合规范，但其他模式包含对浏览器过去使用的标记的支持。 目的是向后兼容旧内容。 当前严格的DTD在这里：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd</a></p>
</blockquote>
</li>
<li>DOM<br>The output tree（输出树） - the parse tree is a tree of DOM element （元素DOM）and attribute nodes（节点属性）. It is the object presentation of the HTML document and the interface of HTML elements to the outside world like JavaScript（是一个代表HTML文档和HTML元素对外部世界如JS提供接口的对象）. <blockquote>
<p>When I say the tree contains DOM nodes, I mean the tree is constructed of elements that implement one of the DOM interfaces(包含DOM节点的树，便是由实现接口之一的元素们构成的树). Browsers use concrete implementations that have other attributes used by the browser internally.</p>
</blockquote>
</li>
<li>The parsing algorithm—解析算法<br>htnl不能被自上而下的解析规则解析，原因是：</li>
</ul>
<ol>
<li>语言的原谅本质</li>
<li>浏览器含有传统的容错机制去支持广为人知的无效html的事实</li>
<li>解析进程可重入。通常来源在解析期间不会更改，但在html中，包含‘document.write’的脚本标记可以添加额外的标记，因此解析过程实际上会修改输入。<br>无法用正规解析技术，浏览器为html创造了自定义解析器。<br><img src="http://img.mukewang.com/582e3edc00011ece03260341.png" alt="HTML parsing flow"></li>
</ol>
<ul>
<li>The tokenization algorithm—标记化算法<blockquote>
<p>The algorithm’s output is an HTML token. 算法输出就是一个HTML符记。<br>The algorithm is expressed as a <strong><em>state machine（状态机）</em></strong>. Each state consumes one or more characters of the input stream and updates the next state according to those characters. The decision is influenced by the current tokenization state and by the tree construction state. This means the same consumed character will yield different results for the correct next state, depending on the current state. The algorithm is too complex to bring fully, so let’s see a simple example that will help us understand the principal.<img src="http://img.mukewang.com/582dba090001a25806270387.png" alt="Tokening the example input"></p>
</blockquote>
</li>
<li>构建树算法<blockquote>
<p>When the parser is created the Document object is created.解析器被构建则文档对象被构建。</p>
</blockquote>
</li>
<li>解析结束后行为<blockquote>
<p>At this stage the browser will mark the document as interactive and start parsing scripts that are in “deferred” mode - those who should be executed after the document is parsed. The document state will be then set to “complete” and a “load” event will be fired.<br><em>此阶段，浏览器将文档标记为交互式并解析出于延迟模式的脚本—解析文档之后执行的脚本。而后，文档状态将设置为完成，并触发加载事件</em></p>
</blockquote>
</li>
<li>浏览器容错<br><em>你从未获取到‘Invalid Syntax</em>错误在html页面，浏览器修理无效内容并继续。<br>c. CSS解析<blockquote>
<p>the CSS specification defines CSS lexical and syntax grammar .CSS的特点决定了CSS lexical 和语法</p>
</blockquote>
</li>
<li>webkit CSS 解析器<blockquote>
<p>Webkit uses <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" target="_blank" rel="external">Flex and Bison</a> parser generators to create parsers automatically from the CSS grammar files. <img src="http://img.mukewang.com/582dbd3e0001335605000393.png" alt="parsing CSS"><br>d. 脚本解析<br>见js部分<br>e.脚本及样式处理规则</p>
</blockquote>
</li>
<li>脚本<blockquote>
<p>The model of the web is synchronous(异步的). Authors expect scripts to be parsed and executed immediately when the parser reaches a <script> tag. The parsing of the document halts until the script was executed. If the script is external then the resource must be first fetched from the network - this is also done synchronously, the parsing halts until the resource is fetched. This was the model for many years and is also specified in HTML 4 and 5 specifications. Authors could mark the script as “defer” and thus it will not halt the document parsing and will execute after it is parsed. HTML5 adds an option to mark the script as asynchronous so it will be parsed and executed by a different thread.</p>
</blockquote>
</li>
<li>Speculative parsing—推测解析<blockquote>
<p>Both Webkit and Firefox do this optimization. While executing scripts, another thread parses the rest of the document and finds out what other resources need to be loaded from the network and loads them. These way resources can be loaded on parallel connections and the overall speed is better. Note - the speculative parser doesn’t modify the DOM tree and leaves that to the main parser, it only parses references to external resources like external scripts, style sheets and images.<br><em>Webkit和Firefox都会进行这种优化。 在执行脚本时，另一个线程解析文档的其余部分，并找出需要从网络加载的其他资源并加载它们。 这些方式资源可以并行连接加载，整体速度更好。 注意 - 推测解析器不修改DOM树并将其留给主解析器，它只解析对外部资源的引用，如外部脚本，样式表和图像。</em></p>
</blockquote>
</li>
<li>样式<blockquote>
<p>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don’t change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. Webkit blocks scripts only when they try to access for certain style properties that may be effected by unloaded style sheets.(当存在仍在加载和解析的样式表时，FF会阻止所有脚本；Webkit只在用户视图访问某些可能被卸载的样式表影响的样式属性时阻止脚本)</p>
</blockquote>
</li>
</ul>
<ol>
<li>Render tree—渲染树 构建<br>While the DOM tree is being constructed, the browser constructs another tree, the render tree. This tree is of visual elements in the order in which they will be displayed. <blockquote>
<p>Firefox calls the elements in the render tree “frames”. Webkit uses the term renderer or render object. </p>
</blockquote>
</li>
</ol>
<ul>
<li>渲染树相对于DOM树<br>The renderers correspond to the DOM elements, but the relation is not one to one(渲染器与DOM元素对应，但不是一一对应). Non visual DOM elements will not be inserted in the render tree. An example is the “head” element. Also elements whose display attribute was assigned to “none” will not appear in the tree (elements with “hidden” visibility attribute will appear in the tree).<img src="http://img.mukewang.com/582dbfd100014e8107310396.png" alt="The render tree and the corresponding DOM tree"></li>
<li>渲染树构建流<br>In Firefox, the presentation is registered as a listener for DOM updates. The presentation delegates frame creation to the “FrameConstructor” and the constructor resolves style(see style computation) and creates a frame.<br>In Webkit the process of resolving the style and creating a renderer is called “attachment”. Every DOM node has an “attach” method. Attachment is synchronous, node insertion to the DOM tree calls the new node “attach” method.<br>火狐的呈现被设置为DOM更新的监听，此呈现代理了frameConstructorframe对frame的构建且此构建解决了样式并创造了frame；Webkit中的解决样式和构建render的过程被称为粘贴，每个DOM节点都有一个粘贴的方法。<br>Processing the html and body tags results in the construction of the render tree root. The root render object corresponds to what the CSS spec calls the containing block - the top most block that contains all other blocks. Its dimensions are the viewport - the browser window display area dimensions. Firefox calls it ViewPortFrame and Webkit calls it RenderView. This is the render object that the document point to. The rest of the tree is constructed as a DOM nodes insertion. （处理html和body标签导致渲染树根的构造。根渲染对象对于CSS规范调用包含块–包含所有其他块最顶层的块。其尺寸即viewport–浏览器窗口显示区域的尺寸。FF调用其ViewPortFrame和Webkit调用其RenderVIew。）<br>See CSS2 on this topic - <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">http://www.w3.org/TR/CSS21/intro.html#processing-model</a></li>
<li>样式计算<br>Style data is a very large construct, holding the numerous style properties, this can cause memory problems.<br>Finding the matching rules for each element can cause performance issues if it’s not optimized. Traversing the entire rule list for each element to find matches is a heavy task. Selectors can have complex structure that can cause the matching process to start on a seemingly promising path that is proven to be futile and another path has to be tried.<br>For example - this compound selector:<br>div div div div{<br>…<br>}<br>Means the rules apply to a “<div>“ who is the descendant of 3 divs. Suppose you want to check if the rule applies for a given “<div>“ element. You choose a certain path up the tree for checking. You may need to traverse the node tree up just to find out there are only two divs and the rule does not apply. You then need to try other paths in the tree.<br>Applying the rules involves quite complex cascade rules that define the hierarchy of the rules.<br>Let’s see how the browsers face these issues:<br>a. 共享样式数据<br>Webkit nodes references style objects (RenderStyle) These objects can be shared by nodes in some conditions. The nodes are siblings or cousins and（webkit节点指样式对象（renderstyle），某些情况下该对象可以为节点所共享。节点是兄弟表关系和）:<br>1.The elements must be in the same mouse state (e.g., one can’t be in :hover while the other isn’t).元素必须在一些鼠标状态<br>2.Neither element should have an id—也不能共用ID<br>3.The tag names should match—标签名应匹配<br>4.The class attributes should match—class属性应匹配<br>5.The set of mapped attributes must be identical—映射属性应匹配<br>6.The link states must match—链接状态应匹配<br>7.The focus states must match—焦点状态应匹配<br>8.Neither element should be affected by attribute selectors, where affected is defined as having any selector match that uses an attribute selector in any position within the selector at all。元素不应受属性选择器影响。<br>9.There must be no inline style attribute on the elements.元素不能有内联样式。<br>10.There must be no sibling selectors in use at all. WebCore simply throws a global switch when any sibling selector is encountered and disables style sharing for the entire document when they are present. This includes the + selector and selectors like :first-child and :last-child.必须没有使用同级选择器。<br>b. FireFox 树规则（有额外的树—规则树和样式文本树，针对更容易的样式计算）<br>Firefox has two extra trees for easier style computation - the rule tree and style context tree. Webkit also has style objects but they are not stored in a tree like the style context tree, only the DOM node points to its relevant style.<img src="http://img.mukewang.com/582e362c0001b3a506400407.png" alt="Firefox style context tree"><br>The style contexts contain end values（样式文本包含终值）. The values are computed by applying all the matching rules in the correct order and performing manipulations that transform them from logical to concrete values. For example - if the logical value is percentage of the screen it will be calculated and transformed to absolute units. The rule tree idea is really clever. It enables sharing these values between nodes to avoid computing them again. This also saves space.<br>All the matched rules are stored in a tree. The bottom nodes in a path have higher priority. The tree contains all the paths for rule matches that were found. Storing the rules is done lazily. The tree isn’t calculated at the beginning for every node, but whenever a node style needs to be computed the computed paths are added to the tree.<br>The idea is to see the tree paths as words in a lexicon. Lets say we already computed this rule tree:<br>Suppose we need to match rules for another element in the content tree, and find out the matched rules (in the correct order) are B - E - I. </li>
<li>Division into structs—分成结构<br>The style contexts are divided into structs(结构体). Those structs contain style information for a certain category like border or color. All the properties in a struct are either inherited or non inherited（所有属性在结构体中要么继承要么非继承）. Inherited properties are properties that unless defined by the element, are inherited from its parent. Non inherited properties (called “reset” properties) use default values if not defined.<br>The tree helps us by caching entire structs (containing the computed end values) in the tree（此树帮我等缓存所有结构体）. The idea is that if the bottom node didn’t supply a definition for a struct, a cached struct in an upper node can be used.</li>
<li>用树规则计算样式文本<br>When computing the style context for a certain element, we first compute a path in the rule tree or use an existing one. We then begin to apply the rules in the path to fill the structs in our new style context. We start at the bottom node of the path - the one with the highest precedence (usually the most specific selector) and traverse the tree up until our struct is full. If there is no specification for the struct in that rule node, then we can greatly optimize - we go up the tree until we find a node that specifies it fully and simply point to it - that’s the best optimization - the entire struct is shared. This saves computation of end values and memory.<br>If we find partial definitions we go up the tree until the struct is filled.<br>If we didn’t find any definitions for our struct, then in case the struct is an “inherited” type - we point to the struct of our parent in the context tree, in this case we also succeeded in sharing structs. If its a reset struct then default values will be used.<br>If the most specific node does add values then we need to do some extra calculations for transforming it to actual values. We then cache the result in the tree node so it can be used by children.<br>The resulting rule tree will look like this (the nodes are marked with the node name : the # of rule they point at):<img src="http://img.mukewang.com/582e3a850001ce7405000294.png" alt="The rule tree"><br><img src="http://img.mukewang.com/582e3aaa00017cbb04000305.png" alt="The context tree"><br>Suppose we parse the HTML and get to the second <div> tag. We need to create a style context for this node and fill its style structs.<br>We will match the rules and discover that the matching rules for the <div> are 1 ,2 and 6. This means there is already an existing path in the tree that our element can use and we just need to add another node to it for rule 6 (node F in the rule tree).<br>We will create a style context and put it in the context tree. The new style context will point to node F in the rule tree.<br>c. Manipulating the rules for an easy match—操作规则方便匹配<br>There are several sources for style rules:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CSS rules, either in external style sheets or in style elements.</div><div class="line">p &#123;color:blue&#125;</div><div class="line">Inline style attributes like</div><div class="line">&lt;p style=&quot;color:blue&quot; /&gt;</div><div class="line">HTML visual attributes (which are mapped to relevant style rules)</div><div class="line">&lt;p bgcolor=&quot;blue&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The last two are easily matched to the element since he owns the style attributes and HTML attributes can be mapped using the element as the key.(最后两个很容易地匹配到了元素因其拥有样式属性和html可以利用元素作为key去键映射的属性)<br>d. 正确的瀑布流顺序运用规则</p>
<ul>
<li>Style sheet cascade order—CSS规则<br>A declaration for a style property can appear in several style sheets, and several times inside a style sheet. This means the order of applying the rules is very important. This is called the “cascade” order. According to CSS2 spec, the cascade order is (from low to high)级联顺序（由低到高）:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Browser declarations:浏览器声明</div><div class="line">User normal declarations：用户正常声明</div><div class="line">Author normal declarations：作者正常声明</div><div class="line">Author important declarations：作者重要声明</div><div class="line">User important declarations：用户重要声明</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The browser declarations are least important and the user overrides the author only if the declaration was marked as important. Declarations with the same order will be sorted by specifity and then the order they are specified. The HTML visual attributes are translated to matching CSS declarations . They are treated as author rules with low priority.</p>
<ul>
<li><p>种类<br>选择器特性由CSS2规范定义如下：<br>如果声明是from是一个’style’属性，而不是一个带选择器的规则，则计数1，否则为0（= a）<br>计数选择器中的ID属性的数量（= b）<br>计数选择器中其他属性和伪类的数量（= c）<br>计数选择器中元素名称和伪元素的数量（= d）<br>连接四个数字a-b-c-d（在具有大基数的数字系统中）给出特异性。<br>您需要使用的数字基数由您在某个类别中拥有的最高计数来定义。<br>例如，如果a = 14，您可以使用十六进制基。 在不太可能的情况下，如果a = 17，您将需要一个17位数字基数。 后面的情况可能发生在这样的选择器：html body div div p …（17标签在你的选择器..不是很可能）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Some examples:</div><div class="line"></div><div class="line">* &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</div><div class="line">li &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</div><div class="line">li:first-line &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line">ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line">ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</div><div class="line">h1 + *[rel=up]&#123;&#125; /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</div><div class="line">ul ol li.red &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</div><div class="line">li.red.level &#123;&#125; /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</div><div class="line">#x34y &#123;&#125; /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</div><div class="line">style=&quot;&quot; /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div></pre></td></tr></table></figure>
</li>
<li><p>规则排序<br>After the rules are matched, they are sorted according to the cascade rules. Webkit uses bubble sort for small lists and merge sort for big ones. Webkit implements sorting by overriding the “&gt;” operator for the rules:</p>
</li>
</ul>
<figure class="highlight plain"><figcaption><span>bool operator >(CSSRuleData& r1, CSSRuleData& r2)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int spec1 = r1.selector()-&gt;specificity();</div><div class="line">int spec2 = r2.selector()-&gt;specificity();</div><div class="line">return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Gradual process—渐进过程<br>Webkit使用标记是否已加载所有顶级样式表（包括@imports）的标志。 如果在附加时样式未完全加载 - 使用占位符并在文档中标记，并且一旦样式表被加载，它们将被重新计算。</li>
</ul>
<ol>
<li>Layout</li>
</ol>
<ul>
<li>Dirty bit system脏位系统<br>In order not to do a full layout for every small change, browser use a “dirty bit” system. A renderer that is changed or added marks itself and its children as “dirty” - needing layout.</li>
</ul>
<p>There are two flags - “dirty” and “children are dirty”. Children are dirty means that although the renderer itself may be ok, it has at least one child that needs a layout.</p>
<ul>
<li>Global and incremental layout—全局和增量布局<img src="http://img.mukewang.com/582e3edc00011ece03260341.png" alt="Incremental layout - only dirty renderers and their children are layed out"></li>
<li>Asynchronous and Synchronous layout—异同布渲染</li>
<li>Optimizations—选择</li>
<li>The layout process 布局过程<br>The layout usually has the following pattern:</li>
</ul>
<p>Parent renderer determines its own width.<br>Parent goes over children and:<br>Place the child renderer (sets its x and y).<br>Calls child layout if needed(they are dirty or we are in a global layout or some other reason) - this calculates the child’s height.<br>Parent uses children accumulative heights and the heights of the margins and paddings to set it own height - this will be used by the parent renderer’s parent.<br>Sets its dirty bit to false.<br>Firefox uses a “state” object(nsHTMLReflowState) as a parameter to layout (termed “reflow”). Among others the state includes the parents width.<br>The output of Firefox layout is a “metrics” object(nsHTMLReflowMetrics). It will contain the renderer computed height.</p>
<ul>
<li>Width calculation 宽度计算</li>
<li>Line breaking 换行</li>
</ul>
<ol>
<li>Painting—喷涂</li>
</ol>
<ul>
<li>全局和增量<br>Like layout, painting can also be global - the entire tree is painted - or incremental. In incremental painting, some of the renderers change in a way that does not affect the entire tree. The changed renderer invalidates it’s rectangle on the screen. This causes the OS to see it as a “dirty region” and generate a “paint” event. The OS does it cleverly and coalesces several regions into one. In Chrome it is more complicated because the renderer is in a different process then the main process. Chrome simulates the OS behavior to some extent. The presentation listens to these events and delegates the message to the render root. The tree is traversed until the relevant renderer is reached. It will repaint itself (and usually its children).</li>
<li>喷涂规则<br>The stacking order of a block renderer is:<br>1.background color<br>2.background image<br>3.border<br>4.children<br>5.outline</li>
<li>FF 布局列表<br>Firefox goes over the render tree and builds a display list for the painted rectangular. It contains the renderers relevant for the rectangular, in the right painting order (backgrounds of the renderers, then borders etc).<br>That way the tree needs to be traversed only once for a repaint instead of several times - painting all backgrounds, then all images , then all borders etc.<br>Firefox optimizes the process by not adding elements that will be hidden, like elements completely beneath other opaque elements.</li>
<li>Webkit rectangle storage矩形存储<br>Before repainting, webkit saves the old rectangle as a bitmap. It then paints only the delta between the new and old rectangles. </li>
</ul>
<ol>
<li>动态改变<br>The browsers try to do the minimal possible actions in response to a change. So changes to an elements color will cause only repaint of the element. Changes to the element position will cause layout and repaint of the element, its children and possibly siblings. Adding a DOM node will cause layout and repaint of the node. Major changes, like increasing font size of the “html” element, will cause invalidation of caches, relyout and repaint of the entire tree.</li>
<li>渲染引擎线程</li>
</ol>
<ul>
<li>事件循环</li>
</ul>
<ol>
<li>CSS2 视觉模型</li>
</ol>
<ul>
<li>canvas</li>
<li>CSS Box model<br><img src="http://img.mukewang.com/582e40270001579c05090348.jpg" alt="box model"></li>
<li>Positioning scheme—定位方案</li>
<li>Box types—盒类型<br>Block box: forms a block - have their own rectangle on the browser window.<br>Inline box: does not have its own block, but is inside a containing block.<br>Blocks are formatted vertically one after the other. Inlines are formatted horizontally.<img src="http://img.mukewang.com/582e409300018abe03500324.png" alt="block-inlineBlock"></li>
<li>定位<br>a. relative<br>b. floats<br>c. absolute and fixed</li>
<li>Layered representation—分层表现</li>
</ul>
<ol>
<li>资源</li>
</ol>
<p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">how browsers work</a></p>
</script></p></blockquote></li></ul>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Youth]]></title>
      <url>https://github.com/yanlee26/blog/2015/01/02/youth/</url>
      <content type="html"><![CDATA[<blockquote>
<p>志不朽者虽难必易，行不止者虽远必臻!</p>
</blockquote>
<h1 id="Youth"><a href="#Youth" class="headerlink" title=" Youth"></a><center> Youth</center></h1><p>　　Youth isn’t a time of life; it is a state of mind; it is not a matter of rosy cheeks,<br>red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions;<br>it is the freshness of the deep springs of life.</p>
<p>　　Youth means a temperamental predominance of courage over timidity, of the appetite for<br>adventure over the love of ease. This often exists in a man of 60 more than a boy of 20.<br>Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p>
<p>　　Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust<br> bows the heart and turns the spirit back to dust.</p>
<p>　　Whether 60 or 16, there is in every human being’s the lure of wonder, the unfailing childlike appetite for<br> what’s next and the joy of the game of living. In the center of my heart and your heart there is a wireless<br> station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the infinite,<br> so long are you young.</p>
<p>   When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism,<br> then you are grown old, even at 20; but as long as your aerials are up, to catch waves of optimism,<br> there is hope you may die young at 80.</p>
<hr>
<h1 id="青春"><a href="#青春" class="headerlink" title="青春"></a><center>青春</center></h1><p>　　青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。</p>
<p>　　青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，<br>    方堕暮年。</p>
<p>　　岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p>
<p>　　无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，<br>    只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。</p>
<p>　　一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，<br>    捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p>
]]></content>
    </entry>
    
  
  
</search>
