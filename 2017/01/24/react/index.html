<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="这世间，唯有梦想与好姑娘不可辜负！">
    

    <!--Author-->
    
        <meta name="author" content="Yan Li">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="react学习---Learning React.js is easier than you think"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="这世间，唯有梦想与好姑娘不可辜负！" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Frank_lyan&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>react学习---Learning React.js is easier than you think - Frank_lyan&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Resharpe Your Saw</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/yanlee26">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>react学习---Learning React.js is easier than you think</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2017-01-24
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Hexo/">#Hexo</a> <a href="/tags/clean-blog/">#clean_blog</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/react/">react</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <blockquote>
<ul>
<li>原文：<a href="https://edgecoders.com/learning-react-js-is-easier-than-you-think-fbd6dc4d935a" target="_blank" rel="external">Learning React.js is easier than you think</a></li>
<li>原文作者：<a href="https://edgecoders.com/@samerbuna" target="_blank" rel="external">Samer Buna</a></li>
</ul>
</blockquote>
<h1 id="学习-React-js-比你想象的要简单"><a href="#学习-React-js-比你想象的要简单" class="headerlink" title="学习 React.js 比你想象的要简单"></a>学习 React.js 比你想象的要简单</h1><h2 id="通过-Medium-中的一篇文章来学习-React-js-的基本原理"><a href="#通过-Medium-中的一篇文章来学习-React-js-的基本原理" class="headerlink" title="通过 Medium 中的一篇文章来学习 React.js 的基本原理"></a>通过 Medium 中的一篇文章来学习 React.js 的基本原理</h2><p><img src="https://cdn-images-1.medium.com/max/1600/1*YsPpBr_PgtyTR6CFDmKU9g.png" alt=""></p>
<p>你有没有注意到在 React 的 logo 中隐藏着一个六角星？只是顺便提下…<br>去年我写了一本简短的关于学习 React.js 的书，有 100 页左右。今年，我要挑战自己 —— 将其总结成一篇文章，并向 Medium 投稿。</p>
<p>这篇文章不是讲什么是 React 或者 <a href="https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76" target="_blank" rel="external">你该怎样学习 React</a>。这是在面向那些已经熟悉了 JavaScript 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_blank" rel="external">DOM API</a> 的人的 React.js 基本原理介绍</p>
<p>*本文采用嵌入式 jsComplete 代码段，所以为了方便阅读，你需要一个合适的屏幕宽度</p>
<p>下面所有的代码都仅供参考。它们也纯粹是为了表达概念而提供的例子。它们中的大多数有更好的实践方式。</p>
<p>您可以编辑和执行下面的任何代码段。使用 <strong>Ctrl+Enter</strong> 执行代码。每一段的右下角有一个点击后可以在 <a href="https://jscomplete.com/repl" target="_blank" rel="external">jsComplete/repl</a> 进行全屏模式编辑或运行代码的链接。</p>
<hr>
<h4 id="1-React-就是一切皆组件"><a href="#1-React-就是一切皆组件" class="headerlink" title="1 React 就是一切皆组件"></a>1 React 就是一切皆组件</h4><p>React 是围绕可重用组件的概念设计的。你定义小组件并将它们组合在一起形成更大的组件。</p>
<p>无论大小，所有组件都是可重用的，甚至在不同的项目中也是如此。</p>
<p>React 组件最简单的形式，就是一个普通的 JavaScript 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Button (props) &#123;</div><div class="line">  // 这里返回一个 DOM 元素，例如：</div><div class="line">  return &lt;button type=&quot;submit&quot;&gt;&#123;props.label&#125;&lt;/button&gt;;</div><div class="line">&#125;</div><div class="line">// 将按钮组件呈现给浏览器</div><div class="line">ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode)</div></pre></td></tr></table></figure>
<center>例 1：编辑上面的代码并按 Ctrl+Enter 键执行</center>&gt;<br>（译者注：译文暂时没有这个功能，请访问原文使用此功能，下同）<br><br>&gt; 括号中的 button 标签将稍后解释。现在不要担心它们。<code>ReactDOM</code> 也将稍后解释，但如果你想测试这个例子和所有接下来的例子，上述 <code>render</code> 函数是你所需的。（React 将要接管和控制的是 <code>ReactDOM.render</code> 的第 2 个参数即目标 DOM 元素）。在 jsComplete REPL 中，你可以使用特殊的变量 <code>mountNode</code>。<br><br>例 1 的注意事项：<br><br>- 组件名称首字母大写，<code>Button</code>。必须要这样做是因为我们将处理 HTML 元素和 React 元素的混合。小写名称是为 HTML 元素保留的。事实上，将 React 组件命名为 “button” 然后你就会发现 ReactDOM 会忽略这个函数，仅仅是将其作为一个普通的空 HTML 按钮来渲染。<br><br>- 每个组件都接收一个属性列表，就像 HTML 元素一样。在 React 中，这个列表被称为<strong>属性</strong>。虽然你可以将一个函数随意命名。<br><br>- 在上面 Button 函数组件的返回输出中，我们奇怪地写了段看上去像 HTML 的代码。这实际上既不是 JavaScript 也不是 HTML，老实说，这甚至不是 React.js。然而它非常流行，以至于成为 React 应用程序中的默认值。这就是所谓的 <a href="https://facebook.github.io/jsx/" target="_blank" rel="external"><strong>JSX</strong></a>，这是一个JavaScript 的扩展。JSX 也是一个<strong>折中方案</strong>！继续尝试并在上面的函数中返回其他 HTML 元素，看看它们是如何被支持的（例如，返回一个文本输入元素）。<br><br>#### 2 JSX 输出的是什么？<br><br>上面的例 1 可以用没有 JSX 的纯 React.js 编写，如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Button (props) &#123;</div><div class="line">  return React.createElement(</div><div class="line">    &quot;button&quot;,</div><div class="line">    &#123; type: &quot;submit&quot; &#125;,</div><div class="line">    props.label</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">// 要使用 Button，你可以这么做</div><div class="line">ReactDOM.render(</div><div class="line">  React.createElement(Button, &#123; label: &quot;Save&quot; &#125;),</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure><br><br><center>例 2：不使用 JSX 编写 React 组件</center>

<p>在 React 顶级 API 中，<code>createElement</code> 函数是主函数。这是你需要学习的 7 个 API 中的 1 个。React 的 API 就是这么小。</p>
<p>就像 DOM 自身有一个 document.createElement 函数来创建一个由标签名指定的元素一样，React 的 <code>createElement</code> 函数是一个高级函数，有和 <code>document.createElement</code> 同样的功能，但它也可以用于创建一个表示 React 组件的元素。当我们使用上面例 2 中的按钮组件时，我们使用的是后者。</p>
<p>不像 <code>document.createElement</code>，React 的 <code>createElement</code> 在接收第二个参数后，接收一个动态参数，它表示所创建元素的子元素。所以 <code>createElement</code> 实际上创建了一个<strong>树</strong>。</p>
<p>这里就是这样的一个例子（底层实现,函数化组件）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const InputForm = React.createElement(</div><div class="line">  &quot;form&quot;,</div><div class="line">  &#123; target: &quot;_blank&quot;, action: &quot;https://google.com/search&quot; &#125;,</div><div class="line">  React.createElement(&quot;div&quot;, null, &quot;Enter input and click Search&quot;),</div><div class="line">  React.createElement(&quot;input&quot;, &#123; className: &quot;big-input&quot; &#125;),</div><div class="line">  React.createElement(Button, &#123; label: &quot;Search&quot; &#125;)</div><div class="line">);</div><div class="line"></div><div class="line">// InputForm 使用 Button 组件，所以我们需要这样做：</div><div class="line">function Button (props) &#123;</div><div class="line">  return React.createElement(</div><div class="line">    &quot;button&quot;,</div><div class="line">    &#123; type: &quot;submit&quot; &#125;,</div><div class="line">    props.label</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后我们可以通过 .render 方法直接使用 InputForm</div><div class="line">ReactDOM.render(InputForm, mountNode);</div></pre></td></tr></table></figure>
<center>例 3：React 创建元素的 API</center>

<p>上面例子中的一些事情值得注意：</p>
<ul>
<li><code>InputForm</code> 不是一个 React 组件；它仅仅是一个 React <strong>元素</strong>。这就是为什么我们可以在 <code>ReactDOM.render</code> 中直接使用它并且可以在调用时不使用 <code>&lt;InputForm /&gt;</code> 的原因。</li>
<li>React.createElement 函数在前两个参数后接收了多个参数。从第3个参数开始的参数列表构成了创建元素的子项列表。</li>
<li>我们可以嵌套 <code>React.createElement</code> 调用，因为它是 JavaScript。</li>
<li>当这个元素不需要属性时，React.createElement 的第二个参数可以为空或者是一个空对象。</li>
<li>我们可以在 React 组件中混合 HTML 元素。你可以将 HTML 元素作为内置的 React 组件。</li>
<li>React 的 API 试图和 DOM API 一样，这就是为什么我们在 input 元素中使用 <code>className</code> 代替 <code>class</code> 的原因。我们都希望如果 React 的 API 成为 DOM API 本身的一部分，因为，你知道，它要好得多。</li>
</ul>
<p>上述的代码是当你引入 React 库的时候浏览器是怎样理解的。浏览器不会处理任何 JSX 业务。然而，我们更喜欢看到和使用 HTML，而不是那些 <code>createElement</code> 调用（想象一下只使用 <code>document.createElement</code> 构建一个网站！）。这就是 JSX 存在的原因。取代上述调用 <code>React.createElement</code> 的方式，我们可以使用一个非常简单类似于 HTML 的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const InputForm =</div><div class="line">  &lt;form target=&quot;_blank&quot; action=&quot;https://google.com/search&quot;&gt;</div><div class="line">    &lt;div&gt;Enter input and click Search&lt;/div&gt;</div><div class="line">    &lt;input className=&quot;big-input&quot; name=&quot;q&quot; /&gt;</div><div class="line">    &lt;Button label=&quot;Search&quot; /&gt;</div><div class="line">  &lt;/form&gt;;</div><div class="line"></div><div class="line">// InputForm “仍然”使用 Button 组件，所以我们也需要这样。</div><div class="line">// JXS 或者普通的表单都会这样做</div><div class="line">function Button (props) &#123;</div><div class="line">  // 这里返回一个 DOM 元素。例如：</div><div class="line">  return &lt;button type=&quot;submit&quot;&gt;&#123;props.label&#125;&lt;/button&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后我们可以直接通过 .render 使用 InputForm</div><div class="line">ReactDOM.render(InputForm, mountNode);</div></pre></td></tr></table></figure>
<center>例 4：为什么在 React 中 JSX 受欢迎（和例 3 相比）</center>  

<p>注意上面的几件事：</p>
<ul>
<li>这不是 HTML 代码。比如，我们仍然可以使用 <code>className</code> 代替 <code>class</code>。</li>
<li>我们仍在考虑怎样让上述的 JavaScript 看起来像是 HTML。看一下我在最后是怎样添加的。</li>
</ul>
<p>我们在上面（例 4）中写的就是 JSX。然而，我们要将编译后的版本（例 3）给浏览器。要做到这一点，我们需要使用一个预处理器将 JSX 版本转换为 <code>React.createElement</code> 版本。</p>
<p>这就是 JSX。这是一种折中的方案，允许我们用类似 HTML 的语法来编写我们的 React 组件，这是一个很好的方法。</p>
<blockquote>
<p>“Flux” 在头部作为韵脚来使用，但它也是一个非常受欢迎的 <a href="https://facebook.github.io/flux/" target="_blank" rel="external">应用架构application architecture</a>，由 Facebook 推广。最出名的是 Redux，Flux 和 React 非常合适。</p>
</blockquote>
<p>JSX，可以单独使用，不仅仅适用于 React。</p>
<h4 id="3-你可以在-JavaScript-的任何地方使用-JSX"><a href="#3-你可以在-JavaScript-的任何地方使用-JSX" class="headerlink" title="3 你可以在 JavaScript 的任何地方使用 JSX"></a>3 你可以在 JavaScript 的任何地方使用 JSX</h4><p>在 JSX 中，你可以在一对花括号内使用任何 JavaScript 表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const RandomValue = () =&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &#123; Math.floor(Math.random() * 100) &#125;</div><div class="line">  &lt;/div&gt;;</div><div class="line">// 使用：</div><div class="line">ReactDOM.render(&lt;RandomValue /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 5：在 JSX 中使用 JavaScript 表达式</center>

<p>任何 JavaScript 表达式可以直接放在花括号中。这相当于在 JavaScript 中插入 <code>${}</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="external">模板 template literals</a>。</p>
<p>这是 JSX 内唯一的约束：只有表达式。例如，你不能使用 <code>if</code> 语句，但三元表达式是可以的。</p>
<p>JavaScript 变量也是表达式，所以当组件接受属性列表时（不包括 <code>RandomValue</code> 组件，<code>props</code> 是可选择的），你可以在花括号里使用这些属性。我们在上述（例 1）的 <code>Button</code> 组件是这样使用的。</p>
<p>JavaScript 对象也是表达式。有些时候我们在花括号中使用 JavaScript 对象，这看起来像是使用了两个花括号，但是在花括号中确实只有一个对象。其中一个用例就是将 CSS 样式对象传递给响应中的特殊样式属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const ErrorDisplay = (&#123;message&#125;) =&gt;</div><div class="line">  &lt;div style=&#123; &#123; color: &apos;red&apos;, backgroundColor: &apos;yellow&apos; &#125; &#125;&gt;</div><div class="line">    &#123;message&#125;</div><div class="line">  &lt;/div&gt;;</div><div class="line"></div><div class="line">// 使用</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;ErrorDisplay</div><div class="line">    message=&quot;These aren&apos;t the droids you&apos;re looking for&quot;</div><div class="line">  /&gt;,</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure>
<center>例 6：一个对象传递特殊的 React 样式参数</center>

<p>注意我<strong>解构(destructured )</strong>的只是在属性参数之外的信息。这只是 JavaScript。还要注意上面的样式属性是一个特殊的属性（同样，它不是 HTML，它更接近 DOM API）。我们使用一个对象作为样式属性的值并且这个对象定义样式就像我们使用 JavaScript 那样（我们可以这样做）。</p>
<p>你可以在 JSX 中使用 React 元素。因为这也是一个表达式（记住，一个 React 元素只是一个函数调用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const MaybeError = (&#123;errorMessage&#125;) =&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &#123;errorMessage &amp;&amp; &lt;ErrorDisplay message=&#123;errorMessage&#125; /&gt;&#125;</div><div class="line">  &lt;/div&gt;;</div><div class="line"></div><div class="line">// MaybeError 组件使用 ErrorDisplay 组件</div><div class="line">const ErrorDisplay = (&#123;message&#125;) =&gt;</div><div class="line">  &lt;div style=&#123; &#123; color: &apos;red&apos;, backgroundColor: &apos;yellow&apos; &#125; &#125;&gt;</div><div class="line">    &#123;message&#125;</div><div class="line">  &lt;/div&gt;;</div><div class="line"></div><div class="line">// 现在我们使用 MaybeError 组件：</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;MaybeError</div><div class="line">    errorMessage=&#123;Math.random() &gt; 0.5 ? &apos;Not good&apos; : &apos;&apos;&#125;</div><div class="line">  /&gt;,</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure>
<center>例 7：一个 React 元素是一个可以通过 {} 使用的表达式</center>

<p>上述 <code>MaybeError</code> 组件只会在有 <code>errorMessage</code> 传入或者另外有一个空的 <code>div</code> 才会显示 <code>ErrorDisplay</code> 组件。React 认为 <code>{true}</code>、 <code>{false}</code><br><code>{undefined}</code> 和 <code>{null}</code> 是有效元素，不呈现任何内容。</p>
<p>我们也可以在 JSX 中使用所有的 JavaScript 的集合方法（<code>map</code>、<code>reduce</code> 、<code>filter</code>、 <code>concat</code> 等）。因为他们返回的也是表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const Doubler = (&#123;value=[1, 2, 3]&#125;) =&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &#123;value.map(e =&gt; e * 2)&#125;</div><div class="line">  &lt;/div&gt;;</div><div class="line"></div><div class="line">// 使用下面内容 </div><div class="line">ReactDOM.render(&lt;Doubler /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 8：在 {} 中使用数组</center>

<p>请注意我是如何给出上述 <code>value</code> 属性的默认值的，因为这全部都只是 JavaScript。注意我只是在 div 中输出一个数组表达式。React 是完全可以的。它只会在文本节点(text node)中放置每一个加倍的值。</p>
<h4 id="4-你可以使用-JavaScript-类写-React-组件"><a href="#4-你可以使用-JavaScript-类写-React-组件" class="headerlink" title="4 你可以使用 JavaScript 类写 React 组件"></a>4 你可以使用 JavaScript 类写 React 组件</h4><p>简单的函数组件非常适合简单的需求，但是有的时候我们需要的更多。React 也支持通过使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">JavaScript 类</a>来创建组件。这里 <code>Button</code> 组件（在例 1 中）就是使用类的语法编写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Button extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;button&gt;&#123;this.props.label&#125;&lt;/button&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用（相同的语法）</div><div class="line">ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 9：使用 JavaScript 类创建组件</center>

<p>类的语法是非常简单的：定义一个扩展的 <code>React.Component</code> 类（另一个你需要学习的 React 的顶级 API）。该类定义了一个单一的实例函数 —— <code>render()</code>，并使函数返回虚拟 DOM 对象。每一次我们使用基于类的 <code>Button</code> 组件（例如，通过 <code>&lt;Button ... /&gt;</code>）,React 将从这个基于类的组件(class-based component)中实例化对象，并在 DOM 树中使用该对象。</p>
<p>这就是为什么上面的例子中我们可以在 JSX 中使用 <code>this.props.label</code> 渲染输出的原因，因为每一个组件都有一个特殊的称为 <code>props</code> 的 <strong>实例(instance)</strong> 属性，这让所有的值传递给该组件时被实例化。</p>
<p>由于我们有一个与组件的单个使用相关联的(associated with)实例，所以我们可以按照自己的意愿定制(customize)该实例。例如，我们可以通过使用常规 JavaScript 构造函数来构造它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Button extends React.Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.id = Date.now();</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;button id=&#123;this.id&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 10：自定义组件实例</center>

<p>我们也可以定义类的原型并且在任何我们希望的地方使用，包括在返回的 JSX 输出的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Button extends React.Component &#123;</div><div class="line">  clickCounter = 0;</div><div class="line"></div><div class="line">  handleClick = () =&gt; &#123;</div><div class="line">    console.log(`Clicked: $&#123;++this.clickCounter&#125;`);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;button id=&#123;this.id&#125; onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">        &#123;this.props.label&#125;</div><div class="line">      &lt;/button&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 11：使用类的属性（通过单击保存按钮进行测试）</center>

<p>注意上述例 11 中的几件事情</p>
<ul>
<li><code>handleClick</code> 函数使用 JavaScript 新提出的 <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="external">class-field syntax</a> 语法。这仍然是 stage-2，但是这是访问组件安装实例（感谢箭头函数）最好的选择（因为很多原因）。然而，你需要使用类似 Babel 的编译器解码为 stage-2（或者仅仅是类字段语法）来让上述代码工作。 jsComplete REPL 有预编译(pre-configured)功能。</li>
<li>我们利用同样的类领域（class-field）语法也定义了<code>clickCounter</code>实例变量，这允许我们跳过一个class constructor的一并调用。</li>
<li>当我们特殊化<code>handleClick</code>函数以作为react属性值，我们并没调用它。我们仅仅传递给<code>handleClick</code>函数的<em>引用(reference )</em>。在那个层次调用函数是使用react的常见错误之一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 错误：</div><div class="line">onClick=&#123;this.handleClick()&#125;</div><div class="line"></div><div class="line">// 正确：</div><div class="line">onClick=&#123;this.handleClick&#125;</div></pre></td></tr></table></figure>
<h4 id="5-React-中的事件：两个重要的区别"><a href="#5-React-中的事件：两个重要的区别" class="headerlink" title="5 React 中的事件：两个重要的区别"></a>5 React 中的事件：两个重要的区别</h4><p>当处理 React 元素中的事件时，我们与 DOM API 的处理方式有两个非常重要的区别：</p>
<ul>
<li>所有 React 元素属性（包括事件）都使用 <strong>camelCase</strong> 命名，而不是 <strong>lowercase</strong>。例如是 <code>onClick</code> 而不是 <code>onclick</code>。</li>
<li>我们将实际的 JavaScript 函数引用(reference)传递给事件处理程序，而不是字符串。例如是 <code>onClick={handleClick}</code> 而不是 <code>onClick=&quot;handleClick&quot;</code>。</li>
</ul>
<p>React 用自己的对象包装 DOM 对象事件以优化事件处理的性能，但是在事件处理程序内部，我们仍然可以访问 DOM 对象上所有可以访问的方法。React 将经过包装的事件对象传递给每个调用函数。例如，为了防止表单提交默认提交操作，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Form extends React.Component &#123;</div><div class="line">  handleSubmit = (event) =&gt; &#123;</div><div class="line">    event.preventDefault();</div><div class="line">    console.log(&apos;Form submitted&apos;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class="line">        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">ReactDOM.render(&lt;Form /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 12：使用包装过的对象???</center>

<h4 id="6-每一个-React-组件都有一个故事：第-1-部分"><a href="#6-每一个-React-组件都有一个故事：第-1-部分" class="headerlink" title="6 每一个 React 组件都有一个故事：第 1 部分"></a>6 每一个 React 组件都有一个故事：第 1 部分</h4><p>以下仅适用于类组件（扩展 <code>React.Component</code>）。函数组件有一个稍微不同的故事。</p>
<ol>
<li>首先，我们定义了一个模板来创建组件中的元素。</li>
<li>然后，我们在某处使用 React。例如，在 <code>render</code> 内部调用其他的组件，或者直接使用 <code>ReactDOM.render</code>。</li>
<li>然后，React 实例化一个对象然后给它设置 <strong>props</strong> 然后我们可以通过 <code>this.props</code> 访问。这些属性都是我们在第 2 步传入的。</li>
<li>因为这些全部都是 JavaScript，<code>constructor</code> 方法将会被调用（如果定义的话）。这是我们称之为的第一个：<strong>组件生命周期方法</strong>。</li>
<li>接下来 React 计算渲染之后的输出方法（虚拟 DOM 节点）。</li>
<li>因为这是 React 第一次渲染元素，React 将会与浏览器连通（代表我们使用 DOM API）来显示元素。这整个过程称为 <strong>mounting</strong>。</li>
<li>接下来 React 调用另一个生命周期函数，称为 <code>componentDidMount</code>。我们可以这样使用这个方法，例如：在 DOM 上做一些我们现在知道的在浏览器中存在的东西。在此生命周期方法之前，我们使用的 DOM 都是虚拟的。</li>
<li>一些组件的故事到此结束，其他组件得到卸载浏览器 DOM 中的各种原因。在后一种情况发生时，会调用另一个生命周期的方法，<code>componentWillUnmount</code>。</li>
<li>任何 mounted 的元素的 <strong>状态</strong>都可能会改变。该元素的父级可能会重新渲染。无论哪种情况，mounted 的元素都可能接收到不同的属性集。React 的魔力就是这儿，我们实际上需要的正是 React 的这一点！在这一点之前，说实话，我们并不需要 React。</li>
<li>组价的故事还在继续，但是在此之前，我们需要理解我所说的这种 <strong>状态</strong>。</li>
</ol>
<h4 id="7-React-组件可以具有私有状态"><a href="#7-React-组件可以具有私有状态" class="headerlink" title="7 React 组件可以具有私有状态"></a>7 React 组件可以具有私有状态</h4><p>以下只适用于类组件。我有没有提到有人叫表象而已(presentational-only)的组件 <strong>dumb</strong>？</p>
<p>状态类是任何 React 类组件中的一个特殊字段。React 检测（monitors ）每一个组件状态的变化，但是为了 React 更加有效，我们必须通过 React 的另一个 API 改变状态字段，这就是我们要学习的另一个 API —— <code>this.setState</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class CounterButton extends React.Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    clickCounter: 0,</div><div class="line">    currentTimestamp: new Date(),</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  handleClick = () =&gt; &#123;</div><div class="line">    this.setState((prevState) =&gt; &#123;</div><div class="line">     return &#123; clickCounter: prevState.clickCounter + 1 &#125;;</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">   setInterval(() =&gt; &#123;</div><div class="line">     this.setState(&#123; currentTimestamp: new Date() &#125;)</div><div class="line">    &#125;, 1000);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;Click&lt;/button&gt;</div><div class="line">        &lt;p&gt;Clicked: &#123;this.state.clickCounter&#125;&lt;/p&gt;</div><div class="line">        &lt;p&gt;Time: &#123;this.state.currentTimestamp.toLocaleString()&#125;&lt;/p&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用</div><div class="line">ReactDOM.render(&lt;CounterButton /&gt;, mountNode);</div></pre></td></tr></table></figure>
<center>例 13：setState 的 API</center>

<p>这可能是最重要的一个例子因为这将是你完全理解 React 基础知识的方式。这个例子之后，还有一些小事情需要学习，但从那时起主要是你和你的 JavaScript 技能。</p>
<p>让我们来看一下例 13，从类开始，总共有两个，一个是一个初始化的有初始值为 <code>0</code> 的 <code>clickCounter</code> 对象和一个从 <code>new Date()</code> 开始的 <code>currentTimestamp</code>。</p>
<p>另一个类是 <code>handleClick</code> 函数，在渲染方法中我们给按钮元素传入 <code>onClick</code> 事件。通过使用 <code>setState</code> 的 <code>handleClick</code> 方法修改了组件的实例状态。要注意到这一点。</p>
<p>另一个我们修改状态的地方是在一个内部的定时器，开始在内部的 <code>componentDidMount</code> 生命周期方法。它每秒钟调用一次并且执行另一个函数调用 <code>this.setState</code>。</p>
<p>在渲染方法中，我们使用具有正常读语法的状态上的两个属性（没有专门的 API）。</p>
<p>现在，注意我们更新状态使用两种不同的方式： </p>
<ol>
<li>通过传入一个函数然后返回一个对象。我们在 <code>handleClick</code> 函数内部这样做。</li>
<li>通过传入一个正则对象，我们在在区间回调(interval callback)中这样做。</li>
</ol>
<p>这两种方式都是可以接受的，但是当你同时读写状态时，第一种方法是首选的（我们这样做）。在区间回调中，我们只向状态写入而不读它。当有问题时，总是使用第一个函数作为参数语法。伴随着竞争条件这更安全，因为 <code>setstate</code> 实际上是一个异步方法。</p>
<p>我们应该怎样更新状态呢？我们返回一个有我们想要更新的的值的对象。注意，在调用 <code>setState</code> 时，我们全部都从状态中传入一个属性或者全都不。这完全是可以的因为 <code>setState</code> 实际上 <strong>合并</strong> 了你通过它（返回值的函数参数）与现有的状态，所以，没有指定一个属性在调用 <code>setState</code> 时意味着我们不希望改变属性（但不删除它）。</p>
<h4 id="8-React-will-react"><a href="#8-React-will-react" class="headerlink" title="8 React will react"></a>8 React will react</h4><p>React 的名字是从状态改变的 <strong>反应</strong>中得来的（虽然没有反应，但也是在一个时间表中）。这里有一个笑话，React 应该被命名为 <strong>Schedule</strong>！</p>
<p>然而，当任何组件的状态被更新时，我们用肉眼观察到的是:对该更新的反应，并自动反映了浏览器 DOM 中的更新（如果需要的话）。</p>
<p>将渲染函数的输入视为两种：</p>
<ul>
<li>通过父元素传入的属性</li>
<li>以及可以随时更新的内部私有状态</li>
</ul>
<p>当渲染函数的输入改变时，输出可能也会改变。</p>
<p>React 保存了渲染的历史记录，当它看到一个渲染与前一个不同时，它将计算它们之间的差异，并将其有效地转换为在 DOM 中执行的实际 DOM 操作。(React keeps a record of the history of renders and when it sees that one render is different than the previous one, it’ll compute the difference between them and efficiently translate it into actual DOM operations that get executed in the DOM.)</p>
<h4 id="9-React-是你的代理"><a href="#9-React-是你的代理" class="headerlink" title="9 React 是你的代理"></a>9 React 是你的代理</h4><p>您可以将 React 看作是我们用来与浏览器通信的代理。以上面的当前时间戳显示为例。取代每一秒我们都需要手动去浏览器调用 DOM API 操作来查找和更新 <code>p#timestamp</code> 元素，我们仅仅改变组件的状态属性，React 做的工作代表我们与浏览器的通信。我相信这就是为什么 React 这么受欢迎的真正原因；我们只是不喜欢和浏览器先生谈话（以及它所说的 DOM 语言的很多方言），并且 React 自愿代理，免费的！</p>
<h4 id="10-每一个-React-组件都有一个故事：第-2-部分"><a href="#10-每一个-React-组件都有一个故事：第-2-部分" class="headerlink" title="10 每一个 React 组件都有一个故事：第 2 部分"></a>10 每一个 React 组件都有一个故事：第 2 部分</h4><p>现在我们知道了一个组件的状态，当该状态发生变化的时候，我们来了解一下关于这个过程的最后几个概念。</p>
<ol>
<li>当组件的状态被更新时，或者它的父进程决定更改它传递给组件的属性时，组件可能需要重新渲染。</li>
<li>如果后者发生，React 会调用另一个生命周期方法：<code>componentWillReceiveProps</code>。</li>
<li>如果状态对象或传递的属性改变了，React 有一个重要的决定要做：组件是否应该在 DOM 中更新？这就是为什么它调用另一个重要的生命周期方法 <code>shouldComponentUpdate</code> 的原因 。此方法是一个实际问题，因此，如果需要自行定制或优化渲染过程，则必须通过返回 true 或 false 来回答这个问题。</li>
<li>如果没有自定义 <code>shouldComponentUpdate</code>，React 的默认事件在大多数情况下都能处理的很好。</li>
<li>首先，这个时候会调用另一生命周期的方法：<code>componentWillUpdate</code>。然后，React 将计算新渲染过的输出，并将其与最后渲染的输出进行对比。</li>
<li>如果渲染过的输出和之前的相同，React 不进行处理（不需要和浏览器先生对话）。</li>
<li>如果有不同的地方，React 将不同传达给浏览器，像我们之前看到的那样。</li>
<li>在任何情况下，一旦一个更新程序发生了，无论以何种方式（即使有相同的输出），React 会调用最后的生命周期方法：<code>componentDidUpdate</code>。</li>
</ol>
<p>生命周期方法是逃生舱口。如果你没有做什么特别的事情，你可以在没有它们的情况下创建完整的应用程序。它们非常方便地分析应用程序中正在发生的事情，并进一步优化 React 更新的性能。</p>
<hr>
<p>信不信由你，通过上面所学的知识（或部分知识），你可以开始创建一些有趣的 React 应用程序。如果你渴望更多，看看我的 <a href="https://www.pluralsight.com/courses/react-js-getting-started?aid=701j0000001heIoAAI&amp;promo=&amp;oid=&amp;utm_source=google&amp;utm_medium=ppc&amp;utm_campaign=US_Dynamic&amp;utm_content=&amp;utm_term=&amp;gclid=CNOAj_2-j9UCFUpNfgod4V0Fdg" target="_blank" rel="external"><strong>Pluralsight 的 React.js 入门课程</strong></a>。</p>
<p><strong>感谢阅读。如果您觉得这篇文章有帮助，请点击原文中的 💚。请关注我的更多关于 React.js 和 JavaScript 的文章</strong>。</p>
<hr>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/yanlee26" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 Yan Li<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>