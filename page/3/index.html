<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT, Frank_Lyan,  Blog, Node.js, Git, JS, JAVASCRIPT, HTML, CSS, jQuery,Stylus" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Frank_Lyan's Blog">
<meta property="og:url" content="https://yanlee26.github.io/page/3/index.html">
<meta property="og:site_name" content="Frank_Lyan's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Frank_Lyan's Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6382889515761010000,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://yanlee26.github.io/page/3/"/>

  <title> Frank_Lyan's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Frank_Lyan's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">progressive programing</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search fa-lg"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/02/browsers_work/" itemprop="url">
                  How browsers work?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-01T20:31:23Z" content="2015-07-01">
              2015-07-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术译文/" itemprop="url" rel="index">
                    <span itemprop="name">技术译文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="标准浏览器的幕后"><a href="#标准浏览器的幕后" class="headerlink" title="标准浏览器的幕后"></a>标准浏览器的幕后</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>所谓的浏览器<h3 id="主流浏览器：IE-FF-Safari-Chrome-Opera"><a href="#主流浏览器：IE-FF-Safari-Chrome-Opera" class="headerlink" title="主流浏览器：IE,FF,Safari,Chrome,Opera"></a>主流浏览器：IE,FF,Safari,Chrome,Opera</h3></li>
</ul>
<ul>
<li>部分开源的有FF,Chrome,Safari，W3C统计这三大浏览器占领市场的6成份额。</li>
</ul>
<ul>
<li>浏览器主要功能特性<blockquote>
<p>The browser main functionality is to present the web resource you choose, by requesting it from the server and displaying it on the browser window. </p>
</blockquote>
</li>
</ul>
<ul>
<li>浏览器的主要功能是呈现你所选择的资源，通过向服务端请求并展示在浏览器窗口。</li>
<li>浏览器用户交互有很多类似之处，其中便是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Address bar for inserting the URI---url地址栏</div><div class="line">Back and forward buttons---前进后退按钮</div><div class="line">Bookmarking options---书签选择</div><div class="line">A refresh and stop buttons for refreshing and stopping the loading of current documents---刷新和停止刷新和阻止加载当前文档</div><div class="line">Home button that gets you to your home page---主页</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Strangely enough, the browser’s user interface is not specified in any formal specification, it is just good practices shaped over years of experience and by browsers imitating each other(浏览器用户界面并非以任何标准区分而区分，而是多年的应用习惯塑造了了其不谋而合的特性). The HTML5 specification doesn’t define UI elements a browser must have, but lists some common elements. Among those are the address bar, status bar and tool bar. There are, of course, features unique to a specific browser like Firefox downloads manager.<br>More on that in the user interface chapter.</p>
<ul>
<li>浏览器高水平结构<h3 id="主要组件如下"><a href="#主要组件如下" class="headerlink" title="主要组件如下"></a>主要组件如下</h3></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.The user interface （UI界面）- this includes the address bar, back/forward button, bookmarking menu etc. Every part of the browser display except the main window where you see the requested page.</div><div class="line">2.The browser engine（引擎） - the interface for querying and manipulating the rendering engine.</div><div class="line">3. The rendering engine（渲染引擎） - responsible for displaying the requested content. For example if the requested content is HTML, it is responsible for parsing the HTML and CSS and displaying the parsed content on the screen.</div><div class="line">4. Networking（网络） - used for network calls, like HTTP requests. It has platform independent interface and underneath implementations for each platform.</div><div class="line">5. UI backend（UI后端） - used for drawing basic widgets like combo boxes and windows. It exposes a generic interface that is not platform specific. Underneath it uses the operating system user interface methods.</div><div class="line">6. JavaScript interpreter（JS解释器）. Used to parse and execute the JavaScript code.</div><div class="line">7.Data storage（数据存储）. This is a persistence layer. The browser needs to save all sorts of data on the hard disk, for examples, cookies. The new HTML specification (HTML5) defines &apos;web database&apos; which is a complete (although light) database in the browser.</div></pre></td></tr></table></figure>
<p><img src="http://img.mukewang.com/582dba090001a25806270387.png" alt="browser 主要组件"><br>*请注意，Chrome与大多数浏览器不同，它拥有多个呈现引擎实例，每个标签一个。 每个选项卡是一个单独的过程。</p>
<ul>
<li>组件通信</li>
</ul>
<ul>
<li>FF和Chrome都有专门的通信结构，下边讨论。<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><blockquote>
<p>The responsibility of the rendering engine is well… Rendering, that is display of the requested contents on the browser screen.</p>
</blockquote>
</li>
<li>渲染即在浏览器上显示请求的内容<br>By default the rendering engine can display HTML and XML documents and images. It can display other types through a plug-in (a browser extension). An example is displaying PDF using a PDF viewer plug-in. We will talk about plug-ins and extensions in a special chapter. In this chapter we will focus on the main use case - displaying HTML and images that are formatted using CSS.</li>
</ul>
<ol>
<li>渲染引擎—Rendering engines<blockquote>
<p>Our reference browsers - Firefox, Chrome and Safari are built upon two rendering engines. Firefox uses Gecko - a “home made” Mozilla rendering engine. Both Safari and Chrome use Webkit.</p>
</blockquote>
</li>
</ol>
<ul>
<li>FF,Chrome,Safari 建立在两个引擎之上。FF运用Gecko内核—一个家装的Mozilla渲染引擎。Safari和Chorme用的是Webkit内核。<br>Webkit is an open source rendering engine which started as an engine for the Linux platform and was modified by Apple to support Mac and Windows. See <a href="http://webkit.org/" target="_blank" rel="external">http://webkit.org/</a> for more details.</li>
<li>Webkit是一个开源渲染引擎，起初在linux平台作引擎并被Apple改造应用到Mac和window系统。</li>
</ul>
<ol>
<li>主流（main flow）<blockquote>
<p>The rendering engine will start getting the contents of the requested document from the networking layer. This will usually be done in 8K chunks.</p>
</blockquote>
</li>
</ol>
<ul>
<li>渲染引擎从网络层获取文档内容，这通常在8k快完成。<img src="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" alt=""></li>
<li>渲染引擎将以解析html文档和转换标签到所谓的文档树—DOM节点上开始。它将解析样式数据，包含内敛样式和外联样式。这些样式信息以及可视化的指令将用于创建另一个树–渲染树。</li>
<li>渲染树包含具有视觉属性（visual attributes如颜色和尺寸）的矩形。 矩形以正确的顺序显示在屏幕上。<br>在渲染树的构造之后，它经过<strong>“布局(layout)”</strong>过程。 这意味着给每个节点在其应该出现在屏幕上的确切坐标。 下一个阶段是<strong>绘画(pianting)</strong> - 渲染树将被遍历，每个节点将使用UI后端图层绘制。<br>重要的是要了解这是一个<strong>渐进(gtadual process)</strong>的过程。 为了获得更好的用户体验，渲染引擎将尽快尝试在屏幕上显示内容。 它不会等到所有的HTML被解析之后才开始构建和布局渲染树。 内容的一部分将被解析和显示，同时该过程继续保持来自网络的其余内容。</li>
</ul>
<ol>
<li>主流示例, 解析和DOM树结构<br><img src="http://img.mukewang.com/582dbd3e0001335605000393.png" alt="Webkit main flow"><br><img src="http://img.mukewang.com/582dbfd100014e8107310396.png" alt="Mozilla&#39;s Gecko rendering engine main flow"><blockquote>
<p>Although Webkit and Gecko use slightly different terminology, the flow is basically the same.<br>a.一般解析</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<p>Since parsing is a very significant(重要，有意义) process within the rendering engine, we will go into it a little more deeply. Let’s begin with a little introduction about parsing.<br>Parsing a document means translating it to some structure that makes sense（转换成有意义的结构） - something the code can understand and use. The result of parsing is usually a tree of nodes that represent the structure of the document（解析的结果通常是表示文档结构的节点树）. It is called a parse tree or a syntax tree（解析树||语法树）.</p>
</blockquote>
</li>
</ul>
<ul>
<li>Parsing is based on the syntax rules the document obeys - the language or format it was written in. Every format you can parse must have deterministic（确定性） grammar consisting of vocabulary and syntax rules. It is called a context free grammar. Human languages are not such languages and therefore cannot be parsed with conventional parsing techniques.</li>
</ul>
<ul>
<li>Parser +Lexer combination组合<blockquote>
<p>arsing can be separated into two sub processes - lexical analysis and syntax analysis.<br>Lexical analysis is the process of breaking the input into tokens(词法分析是将输入分解成符记的过程). Tokens are the language vocabulary - the collection of valid building blocks. In human language it will consist of all the words that appear in the dictionary for that language.<br>Syntax analysis is the applying of the language syntax rules（语法分析就是语言语法规则的运用）.<br>Parsers usually divide the work between two components - the lexer(sometimes called tokenizer) that is responsible for breaking the input into valid tokens, and the parser that is responsible for constructing the parse tree by analyzing the document structure according to the language syntax rules. The lexer knows how to strip irrelevant characters like white spaces and line breaks.<br><img src="http://img.mukewang.com/582e362c0001b3a506400407.png" alt="from source document to parse trees"></p>
</blockquote>
</li>
</ul>
<ul>
<li>The parsing process is iterative. The parser will usually ask the lexer for a new token and try to match the token with one of the syntax rules. If a rule is matched, a node corresponding to the token will be added to the parse tree and the parser will ask for another token.<br>If no rule matches, the parser will store the token internally, and keep asking for tokens until a rule matching all the internally stored tokens is found. If no rule is found then the parser will raise an exception. This means the document was not valid and contained syntax errors.</li>
</ul>
<ul>
<li>Translation改变<blockquote>
<p>Many times the parse tree is not the final product. Parsing is often used in translation - transforming the input document to another format. An example is compilation. The compiler that compiles a source code into machine code first parses it into a parse tree and then translates the tree into a machine code document.<br><img src="http://img.mukewang.com/582e3a850001ce7405000294.png" alt="compilation flow"></p>
</blockquote>
</li>
<li><p>解析示例</p>
</li>
<li><p>Formal definitions for vocabulary and syntax词法标准定义<br>Vocabulary is usually expressed by <a href="http://www.regular-expressions.info/" target="_blank" rel="external">regular expressions</a>.<br>We said that a language can be parsed by regular parsers if its grammar is a context frees grammar. An intuitive definition of a context free grammar is a grammar that can be entirely expressed in BNF. For a formal definition see <a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="external">http://en.wikipedia.org/wiki/Context-free_grammar</a></p>
</li>
<li>Types of parsers解析器类型<br>There are two basic types of parsers - top down parsers(自上而下) and bottom up parsers（自下而上）.</li>
<li>Generating parsers automatically—自动生成解析器<blockquote>
<p>There are tools that can generate a parser for you. They are called parser generators(解析生成器). You feed them with the grammar of your language - its vocabulary and syntax rules and they generate a working parser. Creating a parser requires a deep understanding of parsing and its not easy to create an optimized parser by hand, so parser generators can be very useful.<br>Webkit uses two well known parser generators - <strong><em>Flex</em></strong> for creating a lexer and <strong><em>Bison</em></strong> for creating a parser (you might run into them with the names Lex and Yacc). Flex input is a file containing regular expression definitions of the tokens. Bison’s input is the language syntax rules in BNF format.<br>b. HTML Parser—html解析： to parse the HTML markup into a parse tree.</p>
</blockquote>
</li>
<li>html语法定义<blockquote>
<p>The vocabulary and syntax of HTML are defined in <a href="http://img.mukewang.com/582e3aaa00017cbb04000305.png" target="_blank" rel="external">specifications</a>created by the w3c organization. The current version is HTML4 and work on HTML5 is in progress.</p>
</blockquote>
</li>
<li>非自由上下文（context free）语法<blockquote>
<p>As we have seen in the parsing introduction, grammar syntax can be defined formally using formats like BNF.<br>Unfortunately all the conventional parser topics do not apply to HTML (I didn’t bring them up just for fun - they will be used in parsing CSS and JavaScript). HTML cannot easily be defined by a context free grammar that parsers need.<br>There is a formal format for defining HTML -<strong><em> DTD</em></strong> (Document Type Definition) - but it is not a context free grammar.<br>This appears strange at first site - HTML is rather close to XML .There are lots of available XML parsers. There is an XML variation of HTML - XHTML - so what’s the big difference?<br>The difference is that HTML approach is more <strong><em>“forgiving”</em></strong>, it lets you omit certain tags which are added implicitly, sometimes omit the start or end of tags etc. On the whole it’s a “soft” syntax, as opposed to XML’s stiff and demanding syntax.<br>Apparently this seemingly small difference makes a world of a difference. On one hand this is the main reason why HTML is so popular - it forgives your mistakes and makes life easy for the web author. On the other hand, it makes it difficult to write a format grammar. So to summarize - HTML cannot be parsed easily, not by conventional parsers since its grammar is not a context free grammar, and not by XML parsers(html不能由常规解析器轻易解析，因为它的语法不是上下文自由的语法，不能由XML解析器（解析）).</p>
</blockquote>
</li>
<li>HTML DTD<blockquote>
<p>DTD有一些变体。 严格模式仅符合规范，但其他模式包含对浏览器过去使用的标记的支持。 目的是向后兼容旧内容。 当前严格的DTD在这里：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd</a></p>
</blockquote>
</li>
<li>DOM<br>The output tree（输出树） - the parse tree is a tree of DOM element （元素DOM）and attribute nodes（节点属性）. It is the object presentation of the HTML document and the interface of HTML elements to the outside world like JavaScript（是一个代表HTML文档和HTML元素对外部世界如JS提供接口的对象）. <blockquote>
<p>When I say the tree contains DOM nodes, I mean the tree is constructed of elements that implement one of the DOM interfaces(包含DOM节点的树，便是由实现接口之一的元素们构成的树). Browsers use concrete implementations that have other attributes used by the browser internally.</p>
</blockquote>
</li>
<li>The parsing algorithm—解析算法<br>htnl不能被自上而下的解析规则解析，原因是：</li>
</ul>
<ol>
<li>语言的原谅本质</li>
<li>浏览器含有传统的容错机制去支持广为人知的无效html的事实</li>
<li>解析进程可重入。通常来源在解析期间不会更改，但在html中，包含‘document.write’的脚本标记可以添加额外的标记，因此解析过程实际上会修改输入。<br>无法用正规解析技术，浏览器为html创造了自定义解析器。<br><img src="http://img.mukewang.com/582e3edc00011ece03260341.png" alt="HTML parsing flow"></li>
</ol>
<ul>
<li>The tokenization algorithm—标记化算法<blockquote>
<p>The algorithm’s output is an HTML token. 算法输出就是一个HTML符记。<br>The algorithm is expressed as a <strong><em>state machine（状态机）</em></strong>. Each state consumes one or more characters of the input stream and updates the next state according to those characters. The decision is influenced by the current tokenization state and by the tree construction state. This means the same consumed character will yield different results for the correct next state, depending on the current state. The algorithm is too complex to bring fully, so let’s see a simple example that will help us understand the principal.<img src="http://img.mukewang.com/582dba090001a25806270387.png" alt="Tokening the example input"></p>
</blockquote>
</li>
<li>构建树算法<blockquote>
<p>When the parser is created the Document object is created.解析器被构建则文档对象被构建。</p>
</blockquote>
</li>
<li>解析结束后行为<blockquote>
<p>At this stage the browser will mark the document as interactive and start parsing scripts that are in “deferred” mode - those who should be executed after the document is parsed. The document state will be then set to “complete” and a “load” event will be fired.<br><em>此阶段，浏览器将文档标记为交互式并解析出于延迟模式的脚本—解析文档之后执行的脚本。而后，文档状态将设置为完成，并触发加载事件</em></p>
</blockquote>
</li>
<li>浏览器容错<br><em>你从未获取到‘Invalid Syntax</em>错误在html页面，浏览器修理无效内容并继续。<br>c. CSS解析<blockquote>
<p>the CSS specification defines CSS lexical and syntax grammar .CSS的特点决定了CSS lexical 和语法</p>
</blockquote>
</li>
<li>webkit CSS 解析器<blockquote>
<p>Webkit uses <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#parser_generators" target="_blank" rel="external">Flex and Bison</a> parser generators to create parsers automatically from the CSS grammar files. <img src="http://img.mukewang.com/582dbd3e0001335605000393.png" alt="parsing CSS"><br>d. 脚本解析<br>见js部分<br>e.脚本及样式处理规则</p>
</blockquote>
</li>
<li>脚本<blockquote>
<p>The model of the web is synchronous(异步的). Authors expect scripts to be parsed and executed immediately when the parser reaches a <script> tag. The parsing of the document halts until the script was executed. If the script is external then the resource must be first fetched from the network - this is also done synchronously, the parsing halts until the resource is fetched. This was the model for many years and is also specified in HTML 4 and 5 specifications. Authors could mark the script as “defer” and thus it will not halt the document parsing and will execute after it is parsed. HTML5 adds an option to mark the script as asynchronous so it will be parsed and executed by a different thread.</p>
</blockquote>
</li>
<li>Speculative parsing—推测解析<blockquote>
<p>Both Webkit and Firefox do this optimization. While executing scripts, another thread parses the rest of the document and finds out what other resources need to be loaded from the network and loads them. These way resources can be loaded on parallel connections and the overall speed is better. Note - the speculative parser doesn’t modify the DOM tree and leaves that to the main parser, it only parses references to external resources like external scripts, style sheets and images.<br><em>Webkit和Firefox都会进行这种优化。 在执行脚本时，另一个线程解析文档的其余部分，并找出需要从网络加载的其他资源并加载它们。 这些方式资源可以并行连接加载，整体速度更好。 注意 - 推测解析器不修改DOM树并将其留给主解析器，它只解析对外部资源的引用，如外部脚本，样式表和图像。</em></p>
</blockquote>
</li>
<li>样式<blockquote>
<p>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don’t change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. Webkit blocks scripts only when they try to access for certain style properties that may be effected by unloaded style sheets.(当存在仍在加载和解析的样式表时，FF会阻止所有脚本；Webkit只在用户视图访问某些可能被卸载的样式表影响的样式属性时阻止脚本)</p>
</blockquote>
</li>
</ul>
<ol>
<li>Render tree—渲染树 构建<br>While the DOM tree is being constructed, the browser constructs another tree, the render tree. This tree is of visual elements in the order in which they will be displayed. <blockquote>
<p>Firefox calls the elements in the render tree “frames”. Webkit uses the term renderer or render object. </p>
</blockquote>
</li>
</ol>
<ul>
<li>渲染树相对于DOM树<br>The renderers correspond to the DOM elements, but the relation is not one to one(渲染器与DOM元素对应，但不是一一对应). Non visual DOM elements will not be inserted in the render tree. An example is the “head” element. Also elements whose display attribute was assigned to “none” will not appear in the tree (elements with “hidden” visibility attribute will appear in the tree).<img src="http://img.mukewang.com/582dbfd100014e8107310396.png" alt="The render tree and the corresponding DOM tree"></li>
<li>渲染树构建流<br>In Firefox, the presentation is registered as a listener for DOM updates. The presentation delegates frame creation to the “FrameConstructor” and the constructor resolves style(see style computation) and creates a frame.<br>In Webkit the process of resolving the style and creating a renderer is called “attachment”. Every DOM node has an “attach” method. Attachment is synchronous, node insertion to the DOM tree calls the new node “attach” method.<br>火狐的呈现被设置为DOM更新的监听，此呈现代理了frameConstructorframe对frame的构建且此构建解决了样式并创造了frame；Webkit中的解决样式和构建render的过程被称为粘贴，每个DOM节点都有一个粘贴的方法。<br>Processing the html and body tags results in the construction of the render tree root. The root render object corresponds to what the CSS spec calls the containing block - the top most block that contains all other blocks. Its dimensions are the viewport - the browser window display area dimensions. Firefox calls it ViewPortFrame and Webkit calls it RenderView. This is the render object that the document point to. The rest of the tree is constructed as a DOM nodes insertion. （处理html和body标签导致渲染树根的构造。根渲染对象对于CSS规范调用包含块–包含所有其他块最顶层的块。其尺寸即viewport–浏览器窗口显示区域的尺寸。FF调用其ViewPortFrame和Webkit调用其RenderVIew。）<br>See CSS2 on this topic - <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">http://www.w3.org/TR/CSS21/intro.html#processing-model</a></li>
<li>样式计算<br>Style data is a very large construct, holding the numerous style properties, this can cause memory problems.<br>Finding the matching rules for each element can cause performance issues if it’s not optimized. Traversing the entire rule list for each element to find matches is a heavy task. Selectors can have complex structure that can cause the matching process to start on a seemingly promising path that is proven to be futile and another path has to be tried.<br>For example - this compound selector:<br>div div div div{<br>…<br>}<br>Means the rules apply to a “<div>“ who is the descendant of 3 divs. Suppose you want to check if the rule applies for a given “<div>“ element. You choose a certain path up the tree for checking. You may need to traverse the node tree up just to find out there are only two divs and the rule does not apply. You then need to try other paths in the tree.<br>Applying the rules involves quite complex cascade rules that define the hierarchy of the rules.<br>Let’s see how the browsers face these issues:<br>a. 共享样式数据<br>Webkit nodes references style objects (RenderStyle) These objects can be shared by nodes in some conditions. The nodes are siblings or cousins and（webkit节点指样式对象（renderstyle），某些情况下该对象可以为节点所共享。节点是兄弟表关系和）:<br>1.The elements must be in the same mouse state (e.g., one can’t be in :hover while the other isn’t).元素必须在一些鼠标状态<br>2.Neither element should have an id—也不能共用ID<br>3.The tag names should match—标签名应匹配<br>4.The class attributes should match—class属性应匹配<br>5.The set of mapped attributes must be identical—映射属性应匹配<br>6.The link states must match—链接状态应匹配<br>7.The focus states must match—焦点状态应匹配<br>8.Neither element should be affected by attribute selectors, where affected is defined as having any selector match that uses an attribute selector in any position within the selector at all。元素不应受属性选择器影响。<br>9.There must be no inline style attribute on the elements.元素不能有内联样式。<br>10.There must be no sibling selectors in use at all. WebCore simply throws a global switch when any sibling selector is encountered and disables style sharing for the entire document when they are present. This includes the + selector and selectors like :first-child and :last-child.必须没有使用同级选择器。<br>b. FireFox 树规则（有额外的树—规则树和样式文本树，针对更容易的样式计算）<br>Firefox has two extra trees for easier style computation - the rule tree and style context tree. Webkit also has style objects but they are not stored in a tree like the style context tree, only the DOM node points to its relevant style.<img src="http://img.mukewang.com/582e362c0001b3a506400407.png" alt="Firefox style context tree"><br>The style contexts contain end values（样式文本包含终值）. The values are computed by applying all the matching rules in the correct order and performing manipulations that transform them from logical to concrete values. For example - if the logical value is percentage of the screen it will be calculated and transformed to absolute units. The rule tree idea is really clever. It enables sharing these values between nodes to avoid computing them again. This also saves space.<br>All the matched rules are stored in a tree. The bottom nodes in a path have higher priority. The tree contains all the paths for rule matches that were found. Storing the rules is done lazily. The tree isn’t calculated at the beginning for every node, but whenever a node style needs to be computed the computed paths are added to the tree.<br>The idea is to see the tree paths as words in a lexicon. Lets say we already computed this rule tree:<br>Suppose we need to match rules for another element in the content tree, and find out the matched rules (in the correct order) are B - E - I. </li>
<li>Division into structs—分成结构<br>The style contexts are divided into structs(结构体). Those structs contain style information for a certain category like border or color. All the properties in a struct are either inherited or non inherited（所有属性在结构体中要么继承要么非继承）. Inherited properties are properties that unless defined by the element, are inherited from its parent. Non inherited properties (called “reset” properties) use default values if not defined.<br>The tree helps us by caching entire structs (containing the computed end values) in the tree（此树帮我等缓存所有结构体）. The idea is that if the bottom node didn’t supply a definition for a struct, a cached struct in an upper node can be used.</li>
<li>用树规则计算样式文本<br>When computing the style context for a certain element, we first compute a path in the rule tree or use an existing one. We then begin to apply the rules in the path to fill the structs in our new style context. We start at the bottom node of the path - the one with the highest precedence (usually the most specific selector) and traverse the tree up until our struct is full. If there is no specification for the struct in that rule node, then we can greatly optimize - we go up the tree until we find a node that specifies it fully and simply point to it - that’s the best optimization - the entire struct is shared. This saves computation of end values and memory.<br>If we find partial definitions we go up the tree until the struct is filled.<br>If we didn’t find any definitions for our struct, then in case the struct is an “inherited” type - we point to the struct of our parent in the context tree, in this case we also succeeded in sharing structs. If its a reset struct then default values will be used.<br>If the most specific node does add values then we need to do some extra calculations for transforming it to actual values. We then cache the result in the tree node so it can be used by children.<br>The resulting rule tree will look like this (the nodes are marked with the node name : the # of rule they point at):<img src="http://img.mukewang.com/582e3a850001ce7405000294.png" alt="The rule tree"><br><img src="http://img.mukewang.com/582e3aaa00017cbb04000305.png" alt="The context tree"><br>Suppose we parse the HTML and get to the second <div> tag. We need to create a style context for this node and fill its style structs.<br>We will match the rules and discover that the matching rules for the <div> are 1 ,2 and 6. This means there is already an existing path in the tree that our element can use and we just need to add another node to it for rule 6 (node F in the rule tree).<br>We will create a style context and put it in the context tree. The new style context will point to node F in the rule tree.<br>c. Manipulating the rules for an easy match—操作规则方便匹配<br>There are several sources for style rules:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CSS rules, either in external style sheets or in style elements.</div><div class="line">p &#123;color:blue&#125;</div><div class="line">Inline style attributes like</div><div class="line">&lt;p style=&quot;color:blue&quot; /&gt;</div><div class="line">HTML visual attributes (which are mapped to relevant style rules)</div><div class="line">&lt;p bgcolor=&quot;blue&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The last two are easily matched to the element since he owns the style attributes and HTML attributes can be mapped using the element as the key.(最后两个很容易地匹配到了元素因其拥有样式属性和html可以利用元素作为key去键映射的属性)<br>d. 正确的瀑布流顺序运用规则</p>
<ul>
<li>Style sheet cascade order—CSS规则<br>A declaration for a style property can appear in several style sheets, and several times inside a style sheet. This means the order of applying the rules is very important. This is called the “cascade” order. According to CSS2 spec, the cascade order is (from low to high)级联顺序（由低到高）:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Browser declarations:浏览器声明</div><div class="line">User normal declarations：用户正常声明</div><div class="line">Author normal declarations：作者正常声明</div><div class="line">Author important declarations：作者重要声明</div><div class="line">User important declarations：用户重要声明</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The browser declarations are least important and the user overrides the author only if the declaration was marked as important. Declarations with the same order will be sorted by specifity and then the order they are specified. The HTML visual attributes are translated to matching CSS declarations . They are treated as author rules with low priority.</p>
<ul>
<li><p>种类<br>选择器特性由CSS2规范定义如下：<br>如果声明是from是一个’style’属性，而不是一个带选择器的规则，则计数1，否则为0（= a）<br>计数选择器中的ID属性的数量（= b）<br>计数选择器中其他属性和伪类的数量（= c）<br>计数选择器中元素名称和伪元素的数量（= d）<br>连接四个数字a-b-c-d（在具有大基数的数字系统中）给出特异性。<br>您需要使用的数字基数由您在某个类别中拥有的最高计数来定义。<br>例如，如果a = 14，您可以使用十六进制基。 在不太可能的情况下，如果a = 17，您将需要一个17位数字基数。 后面的情况可能发生在这样的选择器：html body div div p …（17标签在你的选择器..不是很可能）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Some examples:</div><div class="line"></div><div class="line">* &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</div><div class="line">li &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</div><div class="line">li:first-line &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line">ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line">ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</div><div class="line">h1 + *[rel=up]&#123;&#125; /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</div><div class="line">ul ol li.red &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</div><div class="line">li.red.level &#123;&#125; /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</div><div class="line">#x34y &#123;&#125; /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</div><div class="line">style=&quot;&quot; /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div></pre></td></tr></table></figure>
</li>
<li><p>规则排序<br>After the rules are matched, they are sorted according to the cascade rules. Webkit uses bubble sort for small lists and merge sort for big ones. Webkit implements sorting by overriding the “&gt;” operator for the rules:</p>
</li>
</ul>
<figure class="highlight plain"><figcaption><span>bool operator >(CSSRuleData& r1, CSSRuleData& r2)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int spec1 = r1.selector()-&gt;specificity();</div><div class="line">int spec2 = r2.selector()-&gt;specificity();</div><div class="line">return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Gradual process—渐进过程<br>Webkit使用标记是否已加载所有顶级样式表（包括@imports）的标志。 如果在附加时样式未完全加载 - 使用占位符并在文档中标记，并且一旦样式表被加载，它们将被重新计算。</li>
</ul>
<ol>
<li>Layout</li>
</ol>
<ul>
<li>Dirty bit system脏位系统<br>In order not to do a full layout for every small change, browser use a “dirty bit” system. A renderer that is changed or added marks itself and its children as “dirty” - needing layout.</li>
</ul>
<p>There are two flags - “dirty” and “children are dirty”. Children are dirty means that although the renderer itself may be ok, it has at least one child that needs a layout.</p>
<ul>
<li>Global and incremental layout—全局和增量布局<img src="http://img.mukewang.com/582e3edc00011ece03260341.png" alt="Incremental layout - only dirty renderers and their children are layed out"></li>
<li>Asynchronous and Synchronous layout—异同布渲染</li>
<li>Optimizations—选择</li>
<li>The layout process 布局过程<br>The layout usually has the following pattern:</li>
</ul>
<p>Parent renderer determines its own width.<br>Parent goes over children and:<br>Place the child renderer (sets its x and y).<br>Calls child layout if needed(they are dirty or we are in a global layout or some other reason) - this calculates the child’s height.<br>Parent uses children accumulative heights and the heights of the margins and paddings to set it own height - this will be used by the parent renderer’s parent.<br>Sets its dirty bit to false.<br>Firefox uses a “state” object(nsHTMLReflowState) as a parameter to layout (termed “reflow”). Among others the state includes the parents width.<br>The output of Firefox layout is a “metrics” object(nsHTMLReflowMetrics). It will contain the renderer computed height.</p>
<ul>
<li>Width calculation 宽度计算</li>
<li>Line breaking 换行</li>
</ul>
<ol>
<li>Painting—喷涂</li>
</ol>
<ul>
<li>全局和增量<br>Like layout, painting can also be global - the entire tree is painted - or incremental. In incremental painting, some of the renderers change in a way that does not affect the entire tree. The changed renderer invalidates it’s rectangle on the screen. This causes the OS to see it as a “dirty region” and generate a “paint” event. The OS does it cleverly and coalesces several regions into one. In Chrome it is more complicated because the renderer is in a different process then the main process. Chrome simulates the OS behavior to some extent. The presentation listens to these events and delegates the message to the render root. The tree is traversed until the relevant renderer is reached. It will repaint itself (and usually its children).</li>
<li>喷涂规则<br>The stacking order of a block renderer is:<br>1.background color<br>2.background image<br>3.border<br>4.children<br>5.outline</li>
<li>FF 布局列表<br>Firefox goes over the render tree and builds a display list for the painted rectangular. It contains the renderers relevant for the rectangular, in the right painting order (backgrounds of the renderers, then borders etc).<br>That way the tree needs to be traversed only once for a repaint instead of several times - painting all backgrounds, then all images , then all borders etc.<br>Firefox optimizes the process by not adding elements that will be hidden, like elements completely beneath other opaque elements.</li>
<li>Webkit rectangle storage矩形存储<br>Before repainting, webkit saves the old rectangle as a bitmap. It then paints only the delta between the new and old rectangles. </li>
</ul>
<ol>
<li>动态改变<br>The browsers try to do the minimal possible actions in response to a change. So changes to an elements color will cause only repaint of the element. Changes to the element position will cause layout and repaint of the element, its children and possibly siblings. Adding a DOM node will cause layout and repaint of the node. Major changes, like increasing font size of the “html” element, will cause invalidation of caches, relyout and repaint of the entire tree.</li>
<li>渲染引擎线程</li>
</ol>
<ul>
<li>事件循环</li>
</ul>
<ol>
<li>CSS2 视觉模型</li>
</ol>
<ul>
<li>canvas</li>
<li>CSS Box model<br><img src="http://img.mukewang.com/582e40270001579c05090348.jpg" alt="box model"></li>
<li>Positioning scheme—定位方案</li>
<li>Box types—盒类型<br>Block box: forms a block - have their own rectangle on the browser window.<br>Inline box: does not have its own block, but is inside a containing block.<br>Blocks are formatted vertically one after the other. Inlines are formatted horizontally.<img src="http://img.mukewang.com/582e409300018abe03500324.png" alt="block-inlineBlock"></li>
<li>定位<br>a. relative<br>b. floats<br>c. absolute and fixed</li>
<li>Layered representation—分层表现</li>
</ul>
<ol>
<li>资源</li>
</ol>
<p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">how browsers work</a></p>
</script></p></blockquote></li></ul>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/04/science&arts/" itemprop="url">
                  千篇一律与千变万化——音乐、建筑之间的通感(梁思成)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-03T18:35:20Z" content="2015-06-03">
              2015-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/经典/" itemprop="url" rel="index">
                    <span itemprop="name">经典</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最早接触梁思成的这篇文章在高二，当时阅读之后感觉整个人耳目一新，简直如沐春风。而如今在码农职业生涯中，<br>重温一下这篇文章，依旧回味无穷且内涵更加丰富。任何艺术品都是千篇一律与千变万化的组合，编程的世界就是科学与艺术的结合，<br>蕴含在其中的抽象与具体，现象与本质，发散与收敛等，无不折射出不易与变易的艺术与科学以及哲学的内涵。<br>正如我国人的骄傲Vue作者尤雨溪所谓的‘‘不会搞艺术的程序员不是好设计师’’，可见良好的艺术修养对于搞设计还是大有裨益的。</p>
</blockquote>
<ul>
<li>在艺术创作中，往往有一个重复和变化的问题。只有重复而无变化，作品就必然单调枯燥;只有变化而无重复，就容易陷于散漫零乱之态。<br>在有“持续性”的作品中，这一问题特别重要。我所谓的“持续性”，有些是时问的持续，有些是在空问转移的持续。<br>但是由于作品本身或者观赏者由一个空问逐步转入另一空问，同时也具备了时问的持续性，因此而成为时问与空问的综合的持续。
　　 </li>
<li>音乐就是一种时问持续的艺术创作。我们往往可以听到在一首乐曲从头到尾持续的过程中，总有一些重复的乐句、乐段—或者完全相同，<br>或者略有变化。作者通过这些重复而取得整首乐曲的统一性。
　 </li>
<li>音乐中的主题和变奏也是在时问持续的过程中，通过重复和变化而取得统一的另一例子。在舒伯特的《鳝鱼》五重奏中，<br>我们可以听到持续贯串全曲的、极其朴素明朗的“鳝鱼”主题和它的层出不穷的变奏。但是这些变奏又“万变不离其宗”—主题。<br>水波涓涓的伴奏也不断地重复着，使你形象地看到几条鳝鱼在这片伴奏的“水”里悠然自得地游来游去，从而使你“知鱼之乐”焉。
　　 </li>
<li>舞台上的艺术大多是时问与空问的综合持续。几乎所有的舞蹈都要将同一动作重复若干次，并且往往将动作的重复和音乐的重复结合<br>起来，但在重复之中又给以相应的变化;通过这种重复与变化，以突出某一种效果，表达出某一种思想感情。
　　 </li>
<li>上面所谈的那种重复与变化的统一，在建筑物形象的艺术效果上起着极其重要的作用。古今中外的无数建筑，除去极少数例外，<br>几乎都以重复运用各种构件或其他构成部分作为取得艺术效果的重要手段之一。
　　 </li>
<li>历史上最杰出的一个例子是北京的明清故宫。从已被拆除了的中华门(大明门、大清门)开始，就以一间接着一间、<br>重复了又重复的千步廊而一口气排列到天安门。从天安门到端门、午门，又是一间间重复着的“千篇一律”的朝房。再进去，<br>太和门和太和殿、中和殿、保和殿成为一组“前三殿”与乾清门和乾清宫、交泰殿、坤宁宫成为一组的“后三殿”的大同小异的重复<br>，就更像乐曲中的主题和“变奏”;每一座殿堂的本身也是许多构件和构成部分(乐句、乐段)的重复;而东西两侧的廊、玩、楼、门，<br>又是比较低微的，以重复为主但亦有相当变化的“伴奏”。然而整个故宫，它的每一个组群，每一个殿、阁、廊、<br>门却全部都是按照明清两朝工部的“工程做法”的统一规格、统一形式建造的，连彩画,雕饰也尽如此，都是无尽的重复。<br>我们完全可以说它们“千篇一律”。
　　 </li>
<li>但是，谁能不感到，从天安门一步步走进去，就如同置身于一幅大“手卷”里漫步;在时问持续的同时，空问也连续着“流动”。<br>那些殿堂、楼门、廊玩虽然制作方法千篇一律，然而每走几步，前瞻后顾，左娣右盼，那整个景色的轮廓、光影，却都在不断地改变着，<br>一个接着一个新的画面出现在周围，千变万化。空问与时问、重复与变化的辩证统一在北京故宫中达到了最高的境界。
　　 </li>
<li>翻开一部世界建筑史，凡是较优秀的个体建筑或者组群，一条街道或者一个广场，往往都以建筑物形象的重复与变化的统一而取胜。<br>说是千篇一律，却又千变万化。每一条街都是一首“乐曲”，千篇一律和千变万化的统一在城市面貌上起着重要作用。
　　 </li>
<li>十二年来，在全国各城市的建筑中，我们规划设计人员在这一点上做得还不能尽如人意。为了多快好省，我们做了大量标准设计，<br>但是“好”中自应包括艺术的一面，也就是“百花齐放”。我们有些住宅区的标准设计“千篇一律”到孩子哭着找不到家;<br>有些街道又一幢房子一个样式、一个风格，互不和谐;即使它们本身各自都很美观，放在一起就都“损人”且不“利己”，<br>“千变万化”到令人眼花缭乱。我们既要百花齐放、丰富多彩，又要避免杂乱无章、相互减色;既要和谐统一、全局完整，<br>又要避免千篇一律、单调枯燥。这恼人的矛盾是建筑师们应该认真琢磨的问题。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/02/philosophy/" itemprop="url">
                  认知世界：唯物主义辩证法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-01T23:31:29Z" content="2015-04-01">
              2015-04-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/经典/" itemprop="url" rel="index">
                    <span itemprop="name">经典</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>抽象与具体，收敛与发散性的思维明灯;封装继承与多态的理论依据</p>
</blockquote>
<h1 id="马克思主义唯物辩证法"><a href="#马克思主义唯物辩证法" class="headerlink" title=" 马克思主义唯物辩证法"></a><center> 马克思主义唯物辩证法</center></h1><h4 id="基本知识点概述"><a href="#基本知识点概述" class="headerlink" title="基本知识点概述"></a>基本知识点概述</h4><p>此知识点包含四方面的内容：<br>唯物辩证法的总特征、唯物辩证法的三大规律、五对范畴、思维方法 </p>
<h3 id="一、唯特辩证法的总特征-普遍联和永恒发展"><a href="#一、唯特辩证法的总特征-普遍联和永恒发展" class="headerlink" title="一、唯特辩证法的总特征(普遍联和永恒发展)"></a>一、唯特辩证法的总特征(普遍联和永恒发展)</h3><p>普遍联系：联系是指事物内部各要素之间和事物之间相互影响、相互制约和相互作用的关系。联系具有客观性、普遍性和多样性的特点。 </p>
<p>永恒发展：发展是前进上升的运动。发展的实质是新事物的产生和旧事物的灭亡。 </p>
<h3 id="二、唯物辩证法的三大规律"><a href="#二、唯物辩证法的三大规律" class="headerlink" title="二、唯物辩证法的三大规律"></a>二、唯物辩证法的三大规律</h3><ul>
<li>对立统一规律 </li>
</ul>
<blockquote>
<p>对立统一规律是唯物辩证法的实质和核心。对立统一规律揭示了普遍联系的根本内容和永恒发展的内在动力。矛盾分析法是人们认识世界和改造世界的根本方法。 </p>
</blockquote>
<ol>
<li><p>矛盾的同一性和斗争性及其相互关系 </p>
<ol>
<li><p>矛盾是指事物之间的对立和统一及其关系，要区分逻辑矛盾与辩证矛盾。 </p>
</li>
<li><p>同一性是指矛盾双方相互依存、相互贯通的性质和趋势。 </p>
</li>
<li><p>斗争性是矛盾对立面之间相互排斥、相互分享的性质和趋势。 </p>
</li>
<li><p>矛盾同一性和斗争性的原理，要求我们要分析和解决矛盾时，必须从对立中把握同一，从同一中把握对立。 </p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>矛盾的同一性和斗争性在事物发展中的作用 </p>
<ol>
<li><p>矛盾是事物发展的动力是指:</p>
<p> 矛盾着的对立面又统一、又斗争推动了事物的运动和变化。<br> 矛盾的同一性和斗争性在事物发展中都有重要作用。 </p>
</li>
<li><p>矛盾的同一性在事物发展中的作用是：</p>
<p> 第一，提供矛盾得以存在和发展的条件。</p>
<p> 第二，使矛盾双方相互吸取有利于自身的因素而得到发展。</p>
<p> 第三，矛盾双方相互贯通规定了事物发展的基本趋势和方向。 </p>
</li>
<li><p>矛盾的斗争性的作用表现在量变和质变两种状态中：</p>
<p> 在量变过程中，斗争性推动矛盾双方量的变化，通过双方力量的消长，为质变作准备；</p>
<p> 在质变过程中，斗争性使旧的矛盾统一体分解，新的矛盾统一体产生，完成质变。 </p>
</li>
</ol>
</li>
<li><p>矛盾的普遍性和特殊性及其相互关系 </p>
<p> 矛盾的普遍性是指矛盾存在于一切事物的发展过程当中，即矛盾无处不在，无时不有。 </p>
<p> 矛盾的特殊性是指具体事物在其运动中的矛盾及每一矛盾的各个方面都有其特点。 </p>
<p> 矛盾的普遍性和特殊性是辩证统一的关系。 </p>
</li>
<li><p>矛盾分析法 </p>
</li>
</ol>
<p>根本认识方法：包含分析矛盾特殊性的方法，两点论与重点论相结合的方法，抓关键、<br>看主流的方法，在对立中把握同一与在同一中把握对立的方法，指着与继承下统一的方法等。 </p>
<h3 id="质量互变规律"><a href="#质量互变规律" class="headerlink" title="质量互变规律"></a>质量互变规律</h3><ul>
<li><p>质是一事物成为自身并区别于它事物的规定性。 </p>
</li>
<li><p>量是事物存在和发展的规模、程度、速度以及它的构成成分在空间上的排列组合等可以用数量<br>表示的规定性。 </p>
</li>
<li><p>度是保持事物的质的稳定性的数量界限。 </p>
</li>
</ul>
<p>####量变和质变的辩证关系：</p>
<pre><code>第一，量变是质变的必要准备。
第二，质变是量变的必然结果。
第三，量变和质变是相互渗透的。 
</code></pre><h3 id="否定之否定规律"><a href="#否定之否定规律" class="headerlink" title="否定之否定规律"></a>否定之否定规律</h3><blockquote>
<p>肯定因素是维持现存事物存在的因素，否定因素是促使现存事物灭亡的因素。 </p>
</blockquote>
<p>####辩证的否定观：</p>
<pre><code>(1)辩证的否定是包含肯定的否定。 

(2)辩证的否定是事物的自我否定，是事物自身肯定因素和否定因素矛盾运动的必然结果。 

(3)辩证的否定是发展环节和联系环节。 

(4)辩证的否定是“扬弃”。克服旧事物中的消极因素，保留它的积极因素。 
</code></pre><p>否定之否定规律：</p>
<blockquote>
<p>事物变化发展的方向道路是由肯定到否定，再到否定之否定的循环往复的过程。 </p>
</blockquote>
<h3 id="五对范畴"><a href="#五对范畴" class="headerlink" title="五对范畴"></a>五对范畴</h3><h4 id="原因和结果"><a href="#原因和结果" class="headerlink" title="原因和结果"></a>原因和结果</h4><p>(1)、原因和结果是揭示客观世界中普遍联系着的事物，引起被引起、彼此制约的一对范畴。<br>    原因是引起一定现象的现象。结果由于原因作用而引起的现象。 </p>
<p>(2)、判断前后相继的两个现象之间是否具有因果联系，其根本标志是看它们是不是引起被<br>    引起的关系。 </p>
<p>(3)、原因和结果的区分既是确定的又是不确定的。如果把两个具有因果联系的现象从普遍联<br>    系中抽出来加以考察，原因与结果的区分是确定的，如果把它们放在世界无限发展的链条<br>    中去考察，那么原因和结果的区分则是不确定的。同一个现象是在一种关系中是结果，<br>    在另一种关系中则是原因，反之亦然。 </p>
<p>(4)、原因和结果相互作用、相互转化、互为因果。 </p>
<h4 id="必然性和偶然性"><a href="#必然性和偶然性" class="headerlink" title="必然性和偶然性"></a>必然性和偶然性</h4><p>(1)、必然性和偶然性是揭示事物产生、发展、灭亡不同趋势的一对范畴。 </p>
<p>(2)、必然性和偶然性是对立的有区别的。表现在：①必然性是指在事物发展中一定如此的趋势；偶然性是事物发展中并非必定发生的、不确定的趋势。②必然性是由事物内部的根本矛盾决定的；偶然性是由非根本矛盾和外部条件造成的。③必然性对事物的发展起决定作用，它决定事物的发展方向；偶然性则对事物的发展起影响作用，加速或延缓事物的发展。 </p>
<p>(3)必然性和偶然性相互依存，又相互转化。 </p>
<h4 id="可能性和现实性"><a href="#可能性和现实性" class="headerlink" title="可能性和现实性"></a>可能性和现实性</h4><p>可能性是指包含在现实事物之中的、预示着事物发展前途的种种趋势。<br>现实性是包含内在根据的、合乎必然性的存在。 </p>
<p>可能性和现实性是相互依赖、相互转化的。</p>
<pre><code>①可能性和现实性相互依存，密不可分。

②可能性和现实性在一定条件下相互转化。 
</code></pre><h4 id="现象和本质"><a href="#现象和本质" class="headerlink" title="现象和本质"></a>现象和本质</h4><p>本质和现象是揭示客观事物的内<br>在联系和外在联系相互关系的一对范畴。 </p>
<h4 id="内容和形式"><a href="#内容和形式" class="headerlink" title="内容和形式"></a>内容和形式</h4><p>内容和形式是提示事物内在要素同这些要素的结构和表现方式的关系范畴。 </p>
<h3 id="辩证思维方法"><a href="#辩证思维方法" class="headerlink" title="辩证思维方法"></a>辩证思维方法</h3><blockquote>
<p>辩证思维是指以变化发展视角认识事物的思维方式，通常被认为是与逻辑思维相对立的一种思维方式。<br>在逻辑思维中，事物一般是“非此即彼”、“非真即假”，而在辩证思维中，事物可以在同一时间里“亦此亦彼”、“亦真亦假”而无碍思维活动的正常进行。<br>辨证思维指的是一种世界观。世间万物之间是互相联系，互相影响的，而辨证思维正是以世间万物之间的客观联<br>系为基础，而进行的对世界进一步的认识和感知，并在思考的过程中感受人与自然的关系，进而得到某种结论<br>的一种思维。辨证思维模式要求观察问题和分析问题时，以动态发展的眼光来看问题。<br>辩证思维是唯物辩证法在思维中的运用，唯物辩证法的范畴、观点、规律完全适用于辩证思维。<br>辩证思维是客观辩证法在思维中的反映，联系、发展的观点也是辩证思维的基本观点。<br>对立统一规律、质量互变规律和否定之否定规律是唯物辩证法的基本规律，也是辩证思维的基本规律，<br>即对立统一思维法、质量互变思维法和否定之否定思维法。</p>
</blockquote>
<ul>
<li>发展过程</li>
</ul>
<p>人类对辩证思维的认识有一个从自发到自觉的发展过程。人们远在知道什么是辩证法之前，早已辩证地思考问题了，<br>然而这不过是自发的辩证思维。人们只有懂得和运用辩证法理论时，才能真正认识思维的辩证本性，达到自觉的<br>辩证思维。对辩证思维的研究早在古代就有了萌芽。古希腊哲学家爱利亚的芝诺关于运动的诘难，就已经涉及到<br>如何在概念中表达运动的辩证法问题。亚里士多德已经研究了辩证思维的最主要的形式。但是，他们对于辩证思<br>维的观点是直观的、素朴的，只是到了近代才对辩证思维有充分的研究。18世纪末和19世纪初，随着自然科学的<br>进一步发展，不断涌现</p>
<ul>
<li>辩证思维出魅力</li>
</ul>
<p>出大量的新现象和新问题，这就需要人们自觉地进行辩证思考。<br>I.康德提出的”二律背反”问题及其认识上的困惑突出地表明，人们只有辩证思维才能正确地解决科学发展中<br>提出的理论问题。G.W.F.黑格尔从理性思维本身的辩证本性出发，探讨思维的辩证方法和思维形式的相互隶属<br>关系，建立了他的理性逻辑体系。但他是一个唯心主义者，认为自然界和思维中的一切都是“纯思”的结果，<br>因而不可能揭示辩证思维的真实性质并赋予其理论以科学的形态。马克思主义辩证法理论的建立及其在思维领<br>域中的运用表明了人类的辩证思维不仅已进到自觉阶段，而且具有完整的、科学的形态，即科学的辩证逻辑。</p>
<ul>
<li>特征</li>
</ul>
<p>最主要的特征是，事物普遍联系的观点、发展变化的观点和对立统一的观点。</p>
<ul>
<li>认识作用</li>
</ul>
<p>(1)思维方法的本质</p>
<p>思维方法的本质是人们在客观规律和关系的基础上依据主体需要而形成的思维规则、程序和手段，<br>是人们认识世界的中介。</p>
<p>(2)辩证思维的实质</p>
<p>辩证思维的实质就是按照唯物辩证法的原则，在联系和发展中把握认识对象，在对立统一中认识事物。</p>
<p>(3)坚持辩证思维方法的重要意义</p>
<p>只有坚持辩证思维方法，才能实现由感性认识到理性认识的飞跃。在对感性材料进行思维加工时，<br>必须要运用归纳和演绎、分析和综合、抽象与具体等方法。另外，坚持辩证思维方法对于建立科学体系，<br>指导社会实践有着重要意义。</p>
<p>(4)客观辩证法与主观辩证法</p>
<p>所谓客观辩证法，是指宇宙中客观存在的普遍联系、变化发展及其辩证规律，<br>是客观世界本身所具有的辩证性质;所谓主观辩证法，是指辩证的思维，即人的思维对世界的辩证性质的认识。<br>客观辩证法是主观辩证法的内容，主观辩证法是对客观辩证法的反映，二者统一的基础是实践。</p>
<ul>
<li>辩证思维的基本方法 </li>
</ul>
<p>####1.归纳演绎</p>
<p>归纳和演绎是最初也是最基本的思维方法。归纳是从个别上升到一般的方法，即从个别事实中概括出一般的原理。<br>演绎是从一般到个别的方法，即从一般原理推论出个别结论。归纳和演绎的客观基础是事物本身固有的个性<br>和共性、特殊和普遍的关系。归纳和演绎是方向相反的两种思维方法，但两者又是互相依赖、互相渗透、<br>互相促进的。归纳是演绎的基础，作为演绎出发点的一般原理往往是归纳得来的;演绎是归纳的前提，它为归<br>纳提供理论指导和论证。在实际的思维过程中，归纳和演绎是相互推移、交替使用的。归纳和演绎都具有局限性，<br>单纯的归纳或演绎还不能揭示事物的本质和规律，需要运用更为深刻的其他思维方法。</p>
<p>####2.分析综合</p>
<p>这是更深刻地把握事物本质的思维方法。分析是在思维过程中把认识的对象分解为不同的组成部分、方面、<br>特性等，对它们分别加以研究，认识事物的各个方面，从中找出事物的本质;综合则是把分解出来的不同部分、<br>方面按其客观的次序、结构组成一个整体，从而达到认识事物的整体。分析和综合的客观基础是事物整体与部分<br>、系统与要素之间的关系。分析和综合是两种相反的思维方法，但它们又是统一的，相互联系、相互转化、<br>相互促进。分析是综合的基础，没有分析就没有综合;综合是分析的完成，离开了综合就没有科学的分析。<br>分析和综合的统一是矛盾分析法在思维领域中的具体运用。</p>
<h4 id="抽象具体"><a href="#抽象具体" class="headerlink" title="抽象具体"></a>抽象具体</h4><p>抽象和具体是辩证思维的高级形式。抽象是对客观事物某一方面本质的概括或规定;思维具体或理性具体是在抽<br>象的基础上形成的综合，它不同于感性具体，感性具体只是感官直接感觉到的具体，而理性具体则是在感性具体<br>基础上经过思维的分析和综合，达到对事物多方面属性或本质的把握。由抽象上升到具体的方法，就是由抽象的<br>逻辑起点经过一系列中介，达到思维具体的过程。</p>
<p>####逻辑历史</p>
<p>由抽象上升到具体的逻辑思维过程同客观事物的历史过程和认识的历史过程应当符合，也就是逻辑和历史的统一。<br>逻辑指的是理性思维或抽象思维，它以理论的形态反映客观事物的规律性。<br>历史包括两层意思：一是指客观现实的历史发展过程，二是指人类认识的历史发展过程。<br>真正科学的认识是现实历史发展的反映，要求思维的逻辑与历史的进程相一致。历史是逻辑韵基础和内容，<br>逻辑是历史在理论上的再现，是“修正过”的历史。逻辑和历史的一致是辩证思维的一个根本原则。<br>A联系法：就是运用普遍联系的观点来考察思维对象的一种观点方法，是从空间上来考察思维对象的横向联系<br>的一种观点。<br>B发展法：就是运用辩证思维的发展观来考察思维对象的一种观点方法，是从时间上来考察思维对象的过去、<br>现在和将来的纵向发展过程的一种观点方式。<br>C全面法：就是运用全面的观点去考察思维对象的一种观点方法，即从时空整体上全面地考察思维对象的横<br>向联系和纵向发展过程。<br>换言之，就是对思维对象作多方面、多角度、多侧面、多方位的考察的一种观点方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/02/youth/" itemprop="url">
                  Youth
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-01T23:31:23Z" content="2015-01-01">
              2015-01-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/经典/" itemprop="url" rel="index">
                    <span itemprop="name">经典</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>志不朽者虽难必易，行不止者虽远必臻!</p>
</blockquote>
<h1 id="Youth"><a href="#Youth" class="headerlink" title=" Youth"></a><center> Youth</center></h1><p>　　Youth isn’t a time of life; it is a state of mind; it is not a matter of rosy cheeks,<br>red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions;<br>it is the freshness of the deep springs of life.</p>
<p>　　Youth means a temperamental predominance of courage over timidity, of the appetite for<br>adventure over the love of ease. This often exists in a man of 60 more than a boy of 20.<br>Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p>
<p>　　Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust<br> bows the heart and turns the spirit back to dust.</p>
<p>　　Whether 60 or 16, there is in every human being’s the lure of wonder, the unfailing childlike appetite for<br> what’s next and the joy of the game of living. In the center of my heart and your heart there is a wireless<br> station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the infinite,<br> so long are you young.</p>
<p>   When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism,<br> then you are grown old, even at 20; but as long as your aerials are up, to catch waves of optimism,<br> there is hope you may die young at 80.</p>
<hr>
<h1 id="青春"><a href="#青春" class="headerlink" title="青春"></a><center>青春</center></h1><p>　　青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。</p>
<p>　　青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，<br>    方堕暮年。</p>
<p>　　岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p>
<p>　　无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，<br>    只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。</p>
<p>　　一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，<br>    捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/01/math-and-programming/" itemprop="url">
                  数学与编程(王垠)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-01T11:31:20Z" content="2015-01-01">
              2015-01-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/综合/" itemprop="url" rel="index">
                    <span itemprop="name">综合</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/01/01/math-and-programming/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/01/01/math-and-programming/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##数学并不是计算机科学的基础</p>
<p>很多人都盲目的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。<br>这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。</p>
<p>##事实其实是这样的：</p>
<p>计算机科学其实根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易一点。所谓“高等数学”，<br>在计算机科学里面基本用不上。</p>
<p>计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，<br>比如工程的问题，艺术的问题，经济的问题，社会的问题等等。</p>
<p>计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。<br>你必须针对计算机科学进行学习，才有可能成为好的程序员。</p>
<p>数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而糟糕的设计。<br>所谓“数学的美感”，其实大部分是夜郎自大。<br>99%的数学家都写不出像样的代码。</p>
<p>##数学是异常糟糕的语言</p>
<p>这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，<br>只不过是一种非常糟糕的程序语言。数学的理论很多是有用的，然而数学家门用于描述这些理论所用的语言，<br>却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。<br>这不是他们不够聪明，而是数学语言的“设计”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，<br>而大部分时间是在折腾它的语法。</p>
<p>举一个非常简单的例子。如果你说cos2θ表示(cos θ)2，那么理所当然，cos-1θ就应该表示1/(cos θ)了？可它偏偏不是！<br>别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：“凭什么？”<br>cos2θ表示(cos θ)2，而cos-1θ，明明是一模一样的形式，表示的却是arccos θ。一个是求幂，<br>一个是调用反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。</p>
<p>如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，<br>带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，<br>双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。<br>有些人上一门数学课，到最后还没明白那些符号是什么意思。</p>
<p>直到今天，数学家们写书仍然非常不严谨。他们常犯的一个错误是把x2这样的东西叫做“函数”（function）。<br>其实x2根本不是一个函数，它只是一个表达式。你必须同时指明“x是参数”，加上x2，才会成为一个函数。<br>所以正确的函数写法其实看起来像这样：f(x) = x2。或者如果你不想给它一个名字，可以借用lambda calculus的写法，写成：λx.x2。</p>
<p>可是数学家们灰常的喜欢“约定俗成”。他们定了一些不成文的规矩是这样：凡是叫“x”的，都是函数的参数，凡是叫“y”的，<br>都可能是一个函数…… 所以你写x2就可以表示λx.x2，而不需要显式的写出“λx”。殊不知这些约定俗成，<br>看起来貌似可以让你少写几个字，却造成了许许多多的混淆和麻烦。比如，你在Mathematica里面可以对 x2+y 求关于x的导数，<br>而且会得到 y’(x) + 2x 这样蹊跷的结果，因为它认为y可能是一个函数。更奇怪的是，如果你在后面多加一个a，<br>也就是对x2+y+a求导，你会得到 2x！那么 y’(x) 到哪里去了？莫名其妙……</p>
<p>相对而言，程序语言就严谨很多，所有的程序语言都要求你必须指出函数的参数叫什么名字。像x2这样的东西，<br>在程序语言里面不是一个函数（function），而只是一个表达式（expression）。<br>即使 JavaScript 这样毛病众多的语言都是这样。比如，你必须写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function (x) &#123; return x * x &#125;</div></pre></td></tr></table></figure></p>
<p>那个括号里的(x)，显式的声明了变量的名字，避免了可能出现的混淆。我不是第一个指出这些问题的人。<br>其实现代逻辑学的鼻祖Gottlob Frege在一百多年以前就在他的论文“Function and Concept”里批评了数学家们的这种做法。<br>可是数学界的表达方式直到今天还是一样的混乱。</p>
<p>很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。<br>莱布尼兹设计来描述微积分的语言（∫，dx, dy, …），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。<br>我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，<br>反而当成教条灌输给学生，那就是不思进取了。</p>
<p>数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，<br>往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。<br>很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这<br>就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，<br>数学的语言跟Perl（一种非常糟糕的程序语言）有些类似。Perl把各种人需要的各种功能，不加选择地加进了语言里面，<br>造成语言繁复不堪，甚至连Perl的创造者自己都不能理解它所有的功能。</p>
<p>数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。<br>如果你知道什么是Curry-Howard Correspondence就会明白，其实每一个数学证明都不过是一段代码。同样的定理，<br>可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，<br>没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，<br>非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。</p>
<p>数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，<br>就越是觉得我高深莫测，越是感觉你自己笨！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，<br>简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，<br>一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。</p>
<p>数学里最在乎语言设计的分支，莫过于逻辑学了。很多人（包括很多程序语言专家）都盲目的崇拜逻辑学家，<br>盲目的相信数理逻辑是优雅美好的语言。在程序语言界，数理逻辑已经成为一种灾害，明明很容易就能解释清楚的语义，<br>非得写成一堆稀奇古怪，含义混淆的逻辑公式。殊不知其实数理逻辑也是有很大的历史遗留问题和误区的。<br>研究逻辑学的人经常遇到各种“不可判定”（undecidable）问题和所谓“悖论”（paradox），研究几十年也没搞清楚，<br>而其实那些问题都是他们自己造出来的。你只需要把语言改一下，去掉一些不必要的功能，问题就没了。但逻辑学家们总喜欢跟你说，<br>那是某天才老祖宗想出来的，多么多么的了不起啊，不能改！</p>
<p>用一阶逻辑（first-order logic）这样的东西，你可以写出一些毫无意义的语句。逻辑老师们会告诉你，记住啦，这些是没有意义的，<br>如果写出来这些东西，是你的问题！他们没有意识到，如果一个人可以用一个语言写出毫无意义的东西，<br>那么这问题在于这个语言，而不在于这个人。一阶逻辑号称可以“表达所有数学”，结果事实却是，<br>没有几个数学家真的可以用它表达很有用的知识。到后来，稍微明智一点的逻辑学家们开始研究这些老古董语言到底出了什么毛病，<br>于是他们创造了Model Theory这样的理论。写出一些长篇大部头，用于“验证”这些逻辑语言的合理性。<br>这些问题在我看来都是显而易见的，因为很多逻辑的语言根本就不是很好很有用的东西。去研究它们“为什么有毛病”，<br>其实是白费力气。自己另外设计一个更好语言就完事了。</p>
<p>在我看来，除了现代逻辑学的鼻祖Gottlob Frege理解了逻辑的精髓，其它逻辑学家基本都是照本宣科，一知半解。<br>他们喜欢把简单的问题搞复杂，制造一些新名词，说得玄乎其玄灵丹妙药似的。如果你想了解逻辑学的精华，<br>建议你看看Frege的文集。看了之后你也许会发现，Frege思想的精华，其实已经融入在几乎所有的程序语言里了。</p>
<p>##编程是一门艺术</p>
<p>从上面你也许已经明白了，普通程序员使用的编程语言，就算是C++这样毛病众多的语言，其实也已经比数学家使用的语言好很多。<br>用数学的语言可以写出含糊复杂的证明，在期刊或者学术会议上蒙混过关，用程序语言写出来的代码却无法混过计算机这道严格的关卡。<br>因为计算机不是人，它不会迷迷糊糊的点点头让你混过去，或者因为你是大师就不懂装懂。代码是需要经过现实的检验的。<br>如果你的代码有问题，它迟早会导致出问题。</p>
<p>计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，<br>然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，<br>它根本解决不了编程中遇到的实际问题。</p>
<p>编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，<br>它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。<br>所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，<br>却能更好的理解数学。我建议你们先学编程，再去看数学。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Yan Li" />
          <p class="site-author-name" itemprop="name">Yan Li</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanlee26" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/franklyan" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://stackoverflow.com/users/7261459/yan" target="_blank" title="stackoverflow">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  stackoverflow
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://home.cnblogs.com/u/frank26/" title="cnblogs" target="_blank">cnblogs</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://twitter.com/?request_context=signup" title="Twitter" target="_blank">Twitter</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">您是第<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>个小伙伴</span>
  

  
    <span class="site-pv">本站总浏览<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
  
  
</div>



        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yan Li</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Pisces
  </a>
</div>

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yanlee24"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementById('footer')
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


  <!-- 背景动画 -->
  <script type="text/javascript" src="/js/src/particle.js"></script>
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
