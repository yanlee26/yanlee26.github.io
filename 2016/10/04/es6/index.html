<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="这世间，唯有梦想与好姑娘不可辜负！">
    

    <!--Author-->
    
        <meta name="author" content="Yan Li">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="ES6/ES7总结分析"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="这世间，唯有梦想与好姑娘不可辜负！" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Frank_lyan&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>ES6/ES7总结分析 - Frank_lyan&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Resharpe Your Saw</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/yanlee26">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>ES6/ES7总结分析</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2016-10-04
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Hexo/">#Hexo</a> <a href="/tags/clean-blog/">#clean_blog</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/JS/">JS</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>ECMAScript 6, also known as ECMAScript 2015, is the latest version of the ECMAScript<br> standard.  ES6 is a significant update to the language, and the first update to<br> the language since ES5 was standardized in 2009. Implementation of these features<br> in major  engines is <a href="http://kangax.github.io/es5-compat-table/es6/" target="_blank" rel="external">underway now(支持情况一览)</a>.</p>
</blockquote>
<p>See the <a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="external">ES6 standard（ES6规范）</a> for full specification of the ECMAScript 6 language.</p>
<p>ES6 includes the following new features—新特性如下:</p>
<ol>
<li>let + const</li>
<li>arrows箭头函数</li>
<li>destructuring解耦</li>
<li>enhanced string literals字符串的扩展</li>
<li>enhanced regular expression正则的扩展</li>
<li>enhanced number expression数值的扩展</li>
<li>enhanced array expression数组的扩展</li>
<li>enhanced function expression函数的扩展</li>
<li>enhanced object literals对象的扩展</li>
<li>symbols标记</li>
<li>map + set</li>
<li>proxies代理</li>
<li>reflect</li>
<li>promises</li>
<li>iterators迭代器 + for..of</li>
<li>generators</li>
<li>async函数</li>
<li>class</li>
<li>decorator</li>
<li>modules</li>
<li><p>module loaders</p>
</li>
<li><p>subclassable built-ins</p>
</li>
<li>typed arrays</li>
<li>internationalization-localization国际及地域化</li>
<li>SIMD</li>
<li>Good Practise</li>
</ol>
<h2 id="ECMAScript-6-Features"><a href="#ECMAScript-6-Features" class="headerlink" title="ECMAScript 6 Features"></a>ECMAScript 6 Features</h2><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><blockquote>
<p>Block-scoped binding constructs.  <code>let</code> is the new <code>var</code>(块级作用域绑定结构，let是新的var).<br><code>const</code> is single-assignment.  Static restrictions prevent use before assignment<br>（const 是单一声明，严格模式限制其必须先声明再使用）.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">const PI=3.1415926;</div><div class="line">let callbacks = []</div><div class="line">for (let i = 0; i &lt;= 2; i++) &#123;</div><div class="line">    callbacks[i] = function () &#123; return i * 2 &#125;</div><div class="line">&#125;</div><div class="line">callbacks[0]() === 0;</div><div class="line">//block-scoped functions</div><div class="line">&#123;</div><div class="line">    function foo () &#123; return 1 &#125;</div><div class="line">    foo() === 1</div><div class="line">    &#123;</div><div class="line">        function foo () &#123; return 2 &#125;</div><div class="line">        foo() === 2</div><div class="line">    &#125;</div><div class="line">    foo() === 1</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">Object.defineProperty(typeof global === &quot;object&quot; ? global : window, &quot;PI&quot;, &#123;</div><div class="line">    value:        3.1415926,</div><div class="line">    enumerable:   true,</div><div class="line">    writable:     false,</div><div class="line">    configurable: false</div><div class="line">&#125;)</div><div class="line">var callbacks = [];</div><div class="line">for (var i = 0; i &lt;= 2; i++) &#123;</div><div class="line">    (function (i) &#123;</div><div class="line">        callbacks[i] = function() &#123; return i * 2; &#125;;</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div><div class="line">callbacks[0]() === 0;</div><div class="line">(function () &#123;</div><div class="line">    var foo = function () &#123; return 1; &#125;</div><div class="line">    foo() === 1;</div><div class="line">    (function () &#123;</div><div class="line">        var foo = function () &#123; return 2; &#125;</div><div class="line">        foo() === 2;</div><div class="line">    &#125;)();</div><div class="line">    foo() === 1;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>More MDN info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/let" target="_blank" rel="external">let statement</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/const" target="_blank" rel="external">const statement</a></p>
<h3 id="Destructuring解耦"><a href="#Destructuring解耦" class="headerlink" title="Destructuring解耦"></a>Destructuring解耦</h3><blockquote>
<p>Destructuring allows binding using pattern matching, with support for matching arrays and objects(解耦允许绑定模式匹配<br>，支持数组和对象). </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// list matching列表匹配</div><div class="line">var [a, , b] = [1,2,3];</div><div class="line"></div><div class="line">// object matching对象匹配</div><div class="line">var &#123; op: a, lhs: &#123; op: b &#125;, rhs: c &#125;</div><div class="line">       = getASTNode()</div><div class="line">var &#123;op, lhs, rhs&#125; = getASTNode()</div><div class="line">// Can be used in parameter position用于形参位置</div><div class="line">function g(&#123;name: x&#125;) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div><div class="line">g(&#123;name: 5&#125;)</div><div class="line">// Fail-soft destructuring</div><div class="line">var [a] = [];</div><div class="line">a === undefined;</div><div class="line"></div><div class="line">// Fail-soft destructuring with defaults</div><div class="line">var [a = 1] = [];</div><div class="line">a === 1;</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Operators/Destructuring_assignment" target="_blank" rel="external">MDN Destructuring assignment</a></p>
<h3 id="enhanced-string-literals字符串的扩展"><a href="#enhanced-string-literals字符串的扩展" class="headerlink" title="enhanced string literals字符串的扩展"></a>enhanced string literals字符串的扩展</h3><ol>
<li>Unicode编码</li>
</ol>
<blockquote>
<p>Non-breaking additions to support full Unicode, including new Unicode literal form in strings and<br>new RegExp <code>u</code> mode to handle code points, as well as new APIs to process strings at the 21bit code points level.<br>These additions support building global apps in JS.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&quot;𠮷&quot;.length === 2</div><div class="line">&quot;𠮷&quot;.match(/./u)[0].length === 2</div><div class="line">&quot;𠮷&quot; === &quot;\uD842\uDFB7&quot;</div><div class="line">&quot;𠮷&quot; === &quot;\u&#123;20BB7&#125;&quot;</div><div class="line">&quot;𠮷&quot;.codePointAt(0) == 0x20BB7</div><div class="line">for (let codepoint of &quot;𠮷&quot;) console.log(codepoint)</div><div class="line">//ES5</div><div class="line">&quot;𠮷&quot;.length === 2;</div><div class="line">&quot;𠮷&quot;.match(/(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF][\uD800-\uDBFF][\uDC00-\uDFFF][\uD800-\uDBFF](?![\uDC00-\uDFFF])(?:[^\uD800-\uDBFF]^)[\uDC00-\uDFFF])/)[0].length === 2;</div><div class="line">&quot;𠮷&quot; === &quot;\uD842\uDFB7&quot;;</div><div class="line">//  no equivalent in ES5</div><div class="line">//  no equivalent in ES5</div><div class="line">//  no equivalent in ES5</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/RegExp/unicode" target="_blank" rel="external">MDN RegExp.prototype.unicode</a></p>
<ol>
<li>Template Strings</li>
</ol>
<blockquote>
<p>Template strings provide syntactic sugar for constructing strings.<br>This is similar to string interpolation features in Perl, Python and more.<br>模板字符串为适应的字符串提供了语法糖。这类似于Perl，Python等中的字符串插值功能.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Basic literal string creation</div><div class="line">`In  &apos;\n&apos; is a line-feed.`</div><div class="line"></div><div class="line">// Multiline strings</div><div class="line">`In  this is</div><div class="line"> not legal.`</div><div class="line"></div><div class="line">// String interpolation字符串插值</div><div class="line">var name = &quot;Bob&quot;, time = &quot;today&quot;;</div><div class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</div><div class="line"></div><div class="line">// Construct an HTTP request prefix is used to interpret the replacements and construction</div><div class="line">get`http://example.com/foo?bar=$&#123;bar + baz&#125;&amp;quux=$&#123;quux&#125;`</div><div class="line">//ES5</div><div class="line">get([ &quot;http://example.com/foo?bar=&quot;, &quot;&amp;quux=&quot;, &quot;&quot; ],bar + baz, quux);</div></pre></td></tr></table></figure>
<ol>
<li>codePointAt()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line">s.codePointAt(0) // 134071</div><div class="line">s.codePointAt(1) // 57271</div><div class="line">s.codePointAt(2) // 97</div></pre></td></tr></table></figure>
<ol>
<li>string.fromCodePoint() 从码点返回对应字符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String.fromCodePoint(0x20BB7)</div><div class="line">// &quot;𠮷&quot;</div></pre></td></tr></table></figure>
<ol>
<li>遍历</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (let codePoint of &apos;foo&apos;) &#123;</div><div class="line">  console.log(codePoint)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>at() 返回字符串给定位置的字符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.at(0) // &quot;a&quot;</div></pre></td></tr></table></figure>
<ol>
<li>normalize()</li>
</ol>
<blockquote>
<p>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()</div></pre></td></tr></table></figure>
<ol>
<li>includes(),startWith(),endsWith()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;Hello world!&apos;;</div><div class="line">s.startsWith(&apos;Hello&apos;) // true</div><div class="line">s.endsWith(&apos;!&apos;) // true</div><div class="line">s.includes(&apos;o&apos;) // true</div></pre></td></tr></table></figure>
<ol>
<li>repeat() </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</div></pre></td></tr></table></figure>
<ol>
<li>padStart(),padEnd()</li>
</ol>
<p>ES2017 引入了字符串补全长度的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</div><div class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</div><div class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</div><div class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</div></pre></td></tr></table></figure>
<ol>
<li>标签模板</li>
</ol>
<p>紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert`123`</div><div class="line">// 等同于</div><div class="line">alert(123)</div></pre></td></tr></table></figure>
<ol>
<li>string.raw()<br>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String.raw`Hi\\n`</div><div class="line">// &quot;Hi\\n&quot;</div></pre></td></tr></table></figure>
<ol>
<li>局限<br>模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</li>
</ol>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/template_strings" target="_blank" rel="external">MDN Template Strings</a></p>
<h3 id="enhanced-regular-expression正则的扩展"><a href="#enhanced-regular-expression正则的扩展" class="headerlink" title="enhanced regular expression正则的扩展"></a>enhanced regular expression正则的扩展</h3><blockquote>
<p>保持匹配之间的匹配位置粘性，并且以这种方式支持对任意长输入字符串的有效解析，即使具有任意数量的不同的正则表达式。</p>
</blockquote>
<ol>
<li>RegExp构造函数<br>ES5中，按参数类型正则分两种情况：字符串/正则表达式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var regex=new RegExp(&apos;xyz&apos;,i);//var regex=/xyz/i;</div><div class="line">var regex=new RegExp(/xyz/i);//var regex=/xyz/i;</div></pre></td></tr></table></figure>
<p>ES6中，RegExp构造函数首个参数是正则对象，次个参数可以指定修饰符且以次个参数修饰符为准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new RegExp(/abc/ig, &apos;i&apos;).flags</div></pre></td></tr></table></figure>
<ol>
<li>字符串的正则方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.prototype.match // RegExp.prototype[Symbol.match]</div><div class="line">String.prototype.replace // RegExp.prototype[Symbol.replace]</div><div class="line">String.prototype.search //RegExp.prototype[Symbol.search]</div><div class="line">String.prototype.split // RegExp.prototype[Symbol.split]</div></pre></td></tr></table></figure>
<ol>
<li>u修饰符</li>
<li>y修饰符</li>
<li>实例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">let parser = (input, match) =&gt; &#123;</div><div class="line">    for (let pos = 0, lastPos = input.length; pos &lt; lastPos; ) &#123;</div><div class="line">        for (let i = 0; i &lt; match.length; i++) &#123;</div><div class="line">            match[i].pattern.lastIndex = pos</div><div class="line">            let found</div><div class="line">            if ((found = match[i].pattern.exec(input)) !== null) &#123;</div><div class="line">                match[i].action(found)</div><div class="line">                pos = match[i].pattern.lastIndex</div><div class="line">                break</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let report = (match) =&gt; &#123;</div><div class="line">    console.log(JSON.stringify(match))</div><div class="line">&#125;</div><div class="line">parser(&quot;Foo 1 Bar 7 Baz 42&quot;, [</div><div class="line">    &#123; pattern: /^Foo\s+(\d+)/y, action: (match) =&gt; report(match) &#125;,</div><div class="line">    &#123; pattern: /^Bar\s+(\d+)/y, action: (match) =&gt; report(match) &#125;,</div><div class="line">    &#123; pattern: /^Baz\s+(\d+)/y, action: (match) =&gt; report(match) &#125;,</div><div class="line">    &#123; pattern: /^\s*/y,         action: (match) =&gt; &#123;&#125;            &#125;</div><div class="line">])</div><div class="line">//ES5</div><div class="line">var parser = function (input, match) &#123;</div><div class="line">    for (var i, found, inputTmp = input; inputTmp !== &quot;&quot;; ) &#123;</div><div class="line">        for (i = 0; i &lt; match.length; i++) &#123;</div><div class="line">            if ((found = match[i].pattern.exec(inputTmp)) !== null) &#123;</div><div class="line">                match[i].action(found);</div><div class="line">                inputTmp = inputTmp.substr(found[0].length);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var report = function (match) &#123;</div><div class="line">    console.log(JSON.stringify(match));</div><div class="line">&#125;;</div><div class="line">parser(&quot;Foo 1 Bar 7 Baz 42&quot;, [</div><div class="line">    &#123; pattern: /^Foo\s+(\d+)/, action: function (match) &#123; report(match); &#125; &#125;,</div><div class="line">    &#123; pattern: /^Bar\s+(\d+)/, action: function (match) &#123; report(match); &#125; &#125;,</div><div class="line">    &#123; pattern: /^Baz\s+(\d+)/, action: function (match) &#123; report(match); &#125; &#125;,</div><div class="line">    &#123; pattern: /^\s*/,         action: function (match) &#123;&#125;                 &#125;</div><div class="line">]);</div></pre></td></tr></table></figure>
<h3 id="enhanced-number-expression数值的扩展"><a href="#enhanced-number-expression数值的扩展" class="headerlink" title="enhanced number expression数值的扩展"></a>enhanced number expression数值的扩展</h3><ol>
<li>二进制八进制</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0b111110111 === 503 // true   Ob二进制</div><div class="line">0o767 === 503 // true Oo八进制</div></pre></td></tr></table></figure>
<ol>
<li>Number.isFinite(),Number.isNaN()</li>
<li>Number.parseInt(),Number.parseFloat()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line">parseInt(&apos;12.34&apos;) // 12</div><div class="line">parseFloat(&apos;123.45#&apos;) // 123.45</div><div class="line"></div><div class="line">// ES6的写法 是逐步减少全局性方法，使得语言逐步模块化。</div><div class="line">Number.parseInt(&apos;12.34&apos;) // 12</div><div class="line">Number.parseFloat(&apos;123.45#&apos;) // 123.45</div></pre></td></tr></table></figure>
<ol>
<li>Number.isInteger()</li>
<li>Number.EPSILON ES6在Number对象上面，新增一个极小的常量Number.EPSILON。</li>
<li>Number.isSafeInteger()                 </li>
<li>Math对象的扩展</li>
</ol>
<ul>
<li>Math.trunc() 去除一个数的小数部分，返回整数部分。</li>
<li>Math.sign() 判断一个数到底是正数、负数、还是零。</li>
<li>Math.cbrt() 立方根。</li>
<li>Math.clz32() 返回一个数的32位无符号整数形式有多少个前导0。</li>
<li>Math.imul()方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</li>
<li>Math.fround()方法返回一个数的单精度浮点数形式。</li>
<li>Math.hypot()方法返回所有参数的平方和的平方根。</li>
<li>对数方法<ul>
<li>Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。</li>
<li>Math.log1p(x)方法返回1 + x的自然对数</li>
<li>Math.log10(x)返回以10为底的x的对数</li>
<li>Math.log2(x)返回以2为底的x的对数</li>
</ul>
</li>
<li>三角函数<br>  Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）<br>  Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）<br>  Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）<br>  Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）<br>  Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）<br>  Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<ol>
<li>Math.sign()用来判断一个值的正负</li>
<li>指数运算符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2 ** 2 // 4</div><div class="line">2 ** 3 // 8</div></pre></td></tr></table></figure>
<h3 id="enhanced-array-expression数组的扩展"><a href="#enhanced-array-expression数组的扩展" class="headerlink" title="enhanced array expression数组的扩展"></a>enhanced array expression数组的扩展</h3><ol>
<li>Array.from()</li>
</ol>
<blockquote>
<p>将类数组（array-like object）与可遍历(literable)对象转化成真数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//兼容性</div><div class="line">const toArray = (() =&gt;</div><div class="line">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</div><div class="line">)();</div><div class="line"></div><div class="line">let arrayLike = &#123;</div><div class="line">    &apos;0&apos;: &apos;a&apos;,</div><div class="line">    &apos;1&apos;: &apos;b&apos;,</div><div class="line">    &apos;2&apos;: &apos;c&apos;,</div><div class="line">    length: 3</div><div class="line">&#125;;</div><div class="line">var arr1=[].slice.call(arrayLike);//ES5</div><div class="line">var arr2=Array.from(arrayLike);//ES6</div><div class="line"></div><div class="line">let ps=document.querySelectorAll(&apos;p&apos;);//NodeList对象</div><div class="line">Array.from(ps).forEach(p=&gt;condole.log(p));</div><div class="line"></div><div class="line">function foo()&#123;</div><div class="line">    Array.from(arguments);//arguments对象</div><div class="line">&#125;</div><div class="line">//事实上，部署了Iterator接口的数据结构，Array.from都能将其转为数组</div><div class="line">Array.from(&apos;hello&apos;);//[&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</div><div class="line">let nameSet=new Set([&apos;a&apos;,&apos;b&apos;]);</div><div class="line">Array.from(nameSet);//[&apos;a&apos;,&apos;b&apos;]</div><div class="line">//第二个参数</div><div class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</div><div class="line">// [1, 4, 9]</div><div class="line">Array.from([1, , 2, , 3], (n) =&gt; n || 0)</div><div class="line">// [1, 0, 2, 0, 3]   布尔值为false的成员转为0。</div><div class="line">function typesOf () &#123;</div><div class="line">  return Array.from(arguments, value =&gt; typeof value)</div><div class="line">&#125;</div><div class="line">typesOf(null, [], NaN)</div><div class="line">// [&apos;object&apos;, &apos;object&apos;, &apos;number&apos;] 返回各种类型的数据</div></pre></td></tr></table></figure>
<p>另辟蹊径 …也可以将某些数据转为数组</p>
<blockquote>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是<br>还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，<br>都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    var args=[...arguements];</div><div class="line">&#125;</div><div class="line">[...document.querySelectorAll(&apos;div&apos;)];//NodeList</div><div class="line">Array.from(&#123; length: 3 &#125;);</div><div class="line">// [ undefined, undefined, undefined ]</div></pre></td></tr></table></figure>
<p>More MDN info:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="external">Array.from()</a></p>
<ol>
<li>Array.of()<br>为弥补Array()构造函数的不足，将一组值转为数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//hacker</div><div class="line">function ArrayOf()&#123;</div><div class="line">  return [].slice.call(arguments);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Array() // []</div><div class="line">Array(3) // [, , ,]</div><div class="line">Array(3, 11, 8) // [3, 11, 8]</div><div class="line"></div><div class="line">Array.of(3, 11, 8) // [3,11,8]</div><div class="line">Array.of(3) // [3]</div><div class="line">Array.of(3).length // 1</div></pre></td></tr></table></figure>
<ol>
<li>数组实例的copyWithin()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.prototype.copyWithin(target, start = 0, end = this.length)</div><div class="line">//target（必需）：从该位置开始替换数据</div><div class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</div><div class="line">// [4, 5, 3, 4, 5]</div></pre></td></tr></table></figure>
<ol>
<li>find()和findIndex()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0);//参数为回调函数</div><div class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</div><div class="line">  return value &gt; 9;</div><div class="line">&#125;) // 2  返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</div><div class="line">[NaN].indexOf(NaN)</div><div class="line">// -1  这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足</div></pre></td></tr></table></figure>
<ol>
<li>fill()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//使用给定值填充一个数组</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</div><div class="line">// [7, 7, 7]</div><div class="line">new Array(3).fill(7)</div><div class="line">// [7, 7, 7]</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</div><div class="line">// [&apos;a&apos;, 7, &apos;c&apos;]</div></pre></td></tr></table></figure>
<ol>
<li>entries(),keys(),values() 都返回一个遍历器对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//keys()对键名的遍历</div><div class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</div><div class="line">  console.log(index);</div><div class="line">&#125;</div><div class="line">// 0</div><div class="line">// 1</div><div class="line">//values()对键值的遍历</div><div class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</div><div class="line">  console.log(elem);</div><div class="line">&#125;</div><div class="line">// &apos;a&apos;</div><div class="line">// &apos;b&apos;</div><div class="line">//entries()对键值对的遍历</div><div class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</div><div class="line">  console.log(index, elem);</div><div class="line">&#125;</div><div class="line">// 0 &quot;a&quot;</div><div class="line">// 1 &quot;b&quot;</div><div class="line">//不用for...of手动next遍历</div><div class="line">let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">let entries = letter.entries();</div><div class="line">console.log(entries.next().value); // [0, &apos;a&apos;]</div><div class="line">console.log(entries.next().value); // [1, &apos;b&apos;]</div><div class="line">console.log(entries.next().value); // [2, &apos;c&apos;]</div></pre></td></tr></table></figure>
<ol>
<li>includes() 某个数组是否包含给定的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].includes(2);     // true</div><div class="line">[1, 2, 3].includes(4);     // false</div><div class="line">[1, 2, NaN].includes(NaN); // true</div></pre></td></tr></table></figure>
<ol>
<li>空位<br>注意，空位不是undefined，一个位置的值等于undefined，<br>依然是有值的。空位是没有任何值，in运算符可以说明这一点。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0 in [undefined, undefined, undefined] // true</div><div class="line">0 in [, , ,] // false</div></pre></td></tr></table></figure>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。<br>forEach(),filter(),every(),some()跳过空位；map()跳过空位但保留该值<br>；join(),toString(),将空位视为undefined，而undefined和null被处理成空字符串</p>
<p>ES6明确将空位转为undefined 即不忽略空位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Array.from([&apos;a&apos;,,&apos;b&apos;])</div><div class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</div><div class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</div><div class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</div><div class="line">[,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;] </div><div class="line">new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</div><div class="line">let arr = [, ,];</div><div class="line">for (let i of arr) &#123;</div><div class="line">  console.log(1);</div><div class="line">&#125;</div><div class="line">// 1</div><div class="line">// 1</div></pre></td></tr></table></figure>
<blockquote>
<p>Callee-evaluated default parameter values.<br>Turn an array into consecutive arguments in a function call.<br>Bind trailing parameters to an array.<br>Rest replaces the need for <code>arguments</code> and addresses common cases more directly.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f(x, y=12) &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line">f(3) == 15;</div><div class="line">// ES5 y=undefined||12</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function f(x, ...y) &#123;</div><div class="line">  return x * y.length;</div><div class="line">&#125;</div><div class="line">f(3, &quot;hello&quot;, true) == 6;</div><div class="line">//ES5</div><div class="line">&quot;use strict&quot;;</div><div class="line">function f(x) &#123;</div><div class="line">  for (var _len = arguments.length, y = Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) &#123;</div><div class="line">    y[_key - 1] = arguments[_key];</div><div class="line">  &#125;</div><div class="line">  return x * y.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function f(x, y, z) &#123;</div><div class="line">  return x + y + z;</div><div class="line">&#125;</div><div class="line">// Pass each elem of array as argument</div><div class="line">f(...[1,2,3]) == 6</div><div class="line">var str = &quot;foo&quot;</div><div class="line">var chars = [ ...str ] // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ],ES5 var chars = str.split(&quot;&quot;); // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ]</div></pre></td></tr></table></figure>
<p>More MDN info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Functions/Default_parameters" target="_blank" rel="external">Default parameters</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Functions/rest_parameters" target="_blank" rel="external">Rest parameters</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Operators/Spread_operator" target="_blank" rel="external">Spread Operator</a></p>
<h3 id="enhanced-function-expression函数的扩展"><a href="#enhanced-function-expression函数的扩展" class="headerlink" title="enhanced function expression函数的扩展"></a>enhanced function expression函数的扩展</h3><ol>
<li>参数默认值</li>
</ol>
<p>基本用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">function log(x, y) &#123;</div><div class="line">  y = y || &apos;World&apos;;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line">//ES6,参数默认值是惰性求值的</div><div class="line">let m=&apos;My&apos;</div><div class="line">function log(x, y = m+&apos;World&apos;) &#123;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结合解耦赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fetch(url,&#123;body=&apos;&apos;,method=&apos;GET&apos;,headers=&#123;&#125; &#125;)&#123;</div><div class="line">    //...</div><div class="line">&#125;</div><div class="line">fetch(&apos;http://example.com&apos;, &#123;&#125;)</div><div class="line">// &quot;GET&quot;</div><div class="line">fetch(&apos;http://example.com&apos;)</div><div class="line">// 报错,函数fetch的第二个参数是一个对象</div></pre></td></tr></table></figure></p>
<p>函数的length属性:没有指定默认值的参数个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function (a) &#123;&#125;).length // 1</div><div class="line">(function (a = 5) &#123;&#125;).length // 0</div><div class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</div></pre></td></tr></table></figure></p>
<p>作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//调用函数f时，参数形成一个单独的作用域</div><div class="line">let x = 1;</div><div class="line">function f(y = x) &#123;</div><div class="line">  let x = 2;</div><div class="line">  console.log(y);</div><div class="line">&#125;</div><div class="line">f() // 1</div></pre></td></tr></table></figure>
<p>应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function throwIfMissing() &#123;</div><div class="line">  throw new Error(&apos;Missing parameter&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo(mustBeProvided = throwIfMissing()) &#123;</div><div class="line">  return mustBeProvided;</div><div class="line">&#125;</div><div class="line">foo()</div><div class="line">// Error: Missing parameter</div></pre></td></tr></table></figure>
<ol>
<li>rest 参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(a) &#123;&#125;).length  // 1</div><div class="line">(function(...a) &#123;&#125;).length  // 0</div><div class="line">(function(a, ...b) &#123;&#125;).length  // 1</div></pre></td></tr></table></figure>
<ol>
<li>spread…  扩展运算符,好比 rest 参数的逆运算<br>主要用于函数运算</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function push(array, ...items) &#123;</div><div class="line">  array.push(...items);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function add(x, y) &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var numbers = [4, 38];</div><div class="line">add(...numbers) // 42</div></pre></td></tr></table></figure>
<p>替代数组的apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line">function f(x, y, z) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">var args = [0, 1, 2];</div><div class="line">f.apply(null, args);</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">function f(x, y, z) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">var args = [0, 1, 2];</div><div class="line">f(...args);</div><div class="line">//应用</div><div class="line">Math.max.apply(null, [14, 3, 77]);// ES5</div><div class="line">Math.max(...[14, 3, 77]);// ES6</div><div class="line">Math.max(14, 3, 77);// 等同于</div><div class="line"></div><div class="line">var arr1=[1,2,3],arr2=[4,5];</div><div class="line">Array.prototype.push.apply(arr1,arr2);//ES5</div><div class="line">arr1.push(...arr2);//ES6</div><div class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]));//ES5</div><div class="line">new Date(...[2015, 1, 1]);// ES6</div></pre></td></tr></table></figure></p>
<p>扩展运算符应用</p>
<ol>
<li>数组合并</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr1.concat(arr2,arr3);//ES5</div><div class="line">[...arr1,...arr2,...arr3];//ES6</div></pre></td></tr></table></figure>
<ol>
<li>结合解耦:将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</div><div class="line">first // 1</div><div class="line">rest  // [2, 3, 4, 5]</div></pre></td></tr></table></figure>
<p>3.函数返回值</p>
<blockquote>
<p>JS函数只能有一个返回值，如果返回多个值只能将其放入数组或对象中返回</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dateFields=readDateFields(datebase);</div><div class="line">var d=new Date(...dateFields);</div><div class="line">//上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</div></pre></td></tr></table></figure>
<ol>
<li>字符串:将字符串转为真正的数组。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[...&apos;hello&apos;]</div><div class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</div></pre></td></tr></table></figure>
<ol>
<li>实现了Iterator接口的对象</li>
</ol>
<blockquote>
<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var nodeList = document.querySelectorAll(&apos;div&apos;);</div><div class="line">var array = [...nodeList];</div><div class="line"></div><div class="line">let arrayLike = &#123;</div><div class="line">  &apos;0&apos;: &apos;a&apos;,</div><div class="line">  &apos;1&apos;: &apos;b&apos;,</div><div class="line">  &apos;2&apos;: &apos;c&apos;,</div><div class="line">  length: 3</div><div class="line">&#125;;</div><div class="line">let arr = [...arrayLike];</div><div class="line">// TypeError: Cannot spread non-iterable object.</div><div class="line">//arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</div></pre></td></tr></table></figure>
<ol>
<li>Map和Set结构，Generator函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let map = new Map([</div><div class="line">  [1, &apos;one&apos;],</div><div class="line">  [2, &apos;two&apos;],</div><div class="line">  [3, &apos;three&apos;],</div><div class="line">]);</div><div class="line">let arr = [...map.keys()]; // [1, 2, 3]</div><div class="line">var go = function*()&#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;;</div><div class="line">[...go()] // [1, 2, 3]</div></pre></td></tr></table></figure>
<ol>
<li>严格模式<blockquote>
<p>ES5中函数内部可设定为严格模式，ES6中规定函数参数一旦使用了默认值，<br>解耦赋值，或者扩展运算符，那么函数内就不能设定为严格模式。不合理之处在于<br>函数执行时先执行参数代码再执行函数体代码，而只有执行了函数体代码才知道是否<br>遵循严格模式。</p>
</blockquote>
</li>
</ol>
<p><em>为规避之，可以全局设置严格模式或者把函数放于一个IIFE中</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  &apos;use strict&apos;;</div><div class="line">  //or...</div><div class="line">const doSomething = (function () &#123;</div><div class="line">  &apos;use strict&apos;;</div><div class="line">  return function(value = 42) &#123;</div><div class="line">    return value;</div><div class="line">  &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<ol>
<li>name属性：函数的函数名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var f = function () &#123;&#125;;</div><div class="line">f.name // &quot;f&quot;  ES6</div><div class="line">const bar = function baz() &#123;&#125;;</div><div class="line">bar.name // &quot;baz&quot;</div><div class="line">(new Function).name // &quot;anonymous&quot;</div><div class="line">function foo() &#123;&#125;;</div><div class="line">foo.bind(&#123;&#125;).name // &quot;bound foo&quot;</div><div class="line">(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;</div></pre></td></tr></table></figure>
<ol>
<li>箭头函数</li>
</ol>
<blockquote>
<p>Arrows are a function shorthand using the <code>=&gt;</code> syntax.  They are syntactically similar to<br> the related feature in C#, Java 8 and CoffeeScript(和C#，Java8及CoffeeScript类似).<br> They support both statement block bodies as well as expression bodies which return the value of the expression.<br> Unlike functions, arrows share the same lexical <code>this</code> as their surrounding code(异于function，箭头函数和其EC<br> 共享this).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// Expression bodies表达式主体</div><div class="line">var odds = evens.map(v =&gt; v + 1);</div><div class="line">var nums = evens.map((v, i) =&gt; v + i);</div><div class="line">var pairs = evens.map(v =&gt; (&#123;even: v, odd: v + 1&#125;));</div><div class="line">// Statement bodies声明式主体</div><div class="line">nums.forEach(v =&gt; &#123;</div><div class="line">  if (v % 5 === 0)</div><div class="line">    fives.push(v);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Lexical this共享this</div><div class="line">this.nums.forEach((v) =&gt; &#123;</div><div class="line">    if (v % 5 === 0)</div><div class="line">        this.fives.push(v)</div><div class="line">&#125;)</div><div class="line">//ES5</div><div class="line">odds  = evens.map(function (v) &#123; return v + 1; &#125;);</div><div class="line">pairs = evens.map(function (v) &#123; return &#123; even: v, odd: v + 1 &#125;; &#125;);</div><div class="line">nums  = evens.map(function (v, i) &#123; return v + i; &#125;);</div><div class="line">nums.forEach(function (v) &#123;</div><div class="line">   if (v % 5 === 0)</div><div class="line">       fives.push(v);</div><div class="line">&#125;);</div><div class="line">//  variant 1</div><div class="line">var self = this;</div><div class="line">this.nums.forEach(function (v) &#123;</div><div class="line">    if (v % 5 === 0)</div><div class="line">        self.fives.push(v);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//  variant 2</div><div class="line">this.nums.forEach(function (v) &#123;</div><div class="line">    if (v % 5 === 0)</div><div class="line">        this.fives.push(v);</div><div class="line">&#125;, this);</div></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>函数体内this对象为定义时而非使用时所在的对象</li>
<li>不可作为构造函数</li>
<li>不可使用arguments对象，可用rest参数代替</li>
<li>不可作为generator函数，因不可使用yield命令</li>
</ul>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var handler = &#123;</div><div class="line">  id: &apos;123456&apos;,</div><div class="line">  init: function() &#123;</div><div class="line">    document.addEventListener(&apos;click&apos;,</div><div class="line">      event =&gt; this.doSomething(event.type), false);</div><div class="line">  &#125;,</div><div class="line">  doSomething: function(type) &#123;</div><div class="line">    console.log(&apos;Handling &apos; + type  + &apos; for &apos; + this.id);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">  return () =&gt; &#123;</div><div class="line">    return () =&gt; &#123;</div><div class="line">      return () =&gt; &#123;</div><div class="line">        console.log(&apos;id:&apos;, this.id);</div><div class="line">      &#125;;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var f = foo.call(&#123;id: 1&#125;);</div><div class="line">var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1</div><div class="line">var t2 = f().call(&#123;id: 3&#125;)(); // id: 1</div><div class="line">var t3 = f()().call(&#123;id: 4&#125;); // id: 1</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en/docs/Web//Reference/Functions/Arrow_functions" target="_blank" rel="external">MDN Arrow Functions</a></p>
<ol>
<li>尾调用（tail call，算法层）优化</li>
</ol>
<blockquote>
<p>Tail Call 函数式编程的重要概念，某个函数最后一步调用的是另一个函数<br>函数调用会在内存中形成一个调用记录（call frame）,保存调用位置和内部变量等信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//模型</div><div class="line">function f(x)&#123;</div><div class="line">  return g(x);</div><div class="line">&#125;</div><div class="line">function f() &#123;</div><div class="line">  let m = 1;</div><div class="line">  let n = 2;</div><div class="line">  return g(m + n);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line">// 等同于</div><div class="line">function f() &#123;</div><div class="line">  return g(3);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line">// 等同于</div><div class="line">g(3);</div><div class="line">//注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</div><div class="line">function addOne(a)&#123;</div><div class="line">  var one = 1;</div><div class="line">  function inner(b)&#123;</div><div class="line">    return b + one;</div><div class="line">  &#125;</div><div class="line">  return inner(a);</div><div class="line">&#125;//并未优化</div><div class="line">//curring将多参数的函数转换成单参数的形式。</div><div class="line">function currying(fn, n) &#123;</div><div class="line">  return function (m) &#123;</div><div class="line">    return fn.call(this, m, n);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">//算法复杂度由O(n)降到O(1)</div><div class="line">function tailFactorial(n, total) &#123;</div><div class="line">  if (n === 1) return total;</div><div class="line">  return tailFactorial(n - 1, n * total);</div><div class="line">&#125;</div><div class="line">const factorial = currying(tailFactorial, 1);</div><div class="line">factorial(5) // 120</div><div class="line">//ES6的默认值</div><div class="line">function factorial(n, total = 1) &#123;</div><div class="line">  if (n === 1) return total;</div><div class="line">  return factorial(n - 1, n * total);</div><div class="line">&#125;</div><div class="line">factorial(5) // 120</div></pre></td></tr></table></figure>
<h3 id="enhanced-object-expression对象的扩展"><a href="#enhanced-object-expression对象的扩展" class="headerlink" title="enhanced object expression对象的扩展"></a>enhanced object expression对象的扩展</h3><ol>
<li>属性的简洁表示</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var foo=&apos;bar&apos;;</div><div class="line">var baz=&#123;foo&#125;;//&#123;foo:&apos;bar&apos;&#125;,可将对象的属性或方法直接写成变量或函数</div><div class="line">function f(x, y) &#123;return &#123;x, y&#125;;&#125;</div><div class="line">var o=&#123;</div><div class="line">    method()&#123;&#125;,</div><div class="line">&#125;</div><div class="line">//getter,setter</div><div class="line">var cart = &#123;</div><div class="line">  _wheels: 4,</div><div class="line">  get wheels () &#123;</div><div class="line">    return this._wheels;</div><div class="line">  &#125;,</div><div class="line">  set wheels (value) &#123;</div><div class="line">    if (value &lt; this._wheels) &#123;</div><div class="line">      throw new Error(&apos;数值太小了！&apos;);</div><div class="line">    &#125;</div><div class="line">    this._wheels = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>属性名表达式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//JS定义对象属性方法</div><div class="line">obj.foo=true;//一</div><div class="line">obj[&apos;a&apos;+&apos;bc&apos;]=123;//二</div><div class="line">var obj=&#123;foo:true,abc:123&#125;;//ES5</div><div class="line">let propKey = &apos;foo&apos;;</div><div class="line">//ES6</div><div class="line">let obj = &#123;</div><div class="line">  [propKey]: true,</div><div class="line">  [&apos;a&apos; + &apos;bc&apos;]: 123</div><div class="line">&#125;;</div><div class="line">let obj = &#123;</div><div class="line">  [&apos;h&apos; + &apos;ello&apos;]() &#123;</div><div class="line">    return &apos;hi&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.hello() // hi</div><div class="line">//属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]</div><div class="line">const keyA = &#123;a: 1&#125;;</div><div class="line">const keyB = &#123;b: 2&#125;;</div><div class="line">const myObject = &#123;</div><div class="line">  [keyA]: &apos;valueA&apos;,</div><div class="line">  [keyB]: &apos;valueB&apos;</div><div class="line">&#125;;</div><div class="line">myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;</div></pre></td></tr></table></figure>
<ol>
<li>方法的name属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">const person = &#123;</div><div class="line">  sayName() &#123;</div><div class="line">    console.log(&apos;hello!&apos;);</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line">person.sayName.name   // &quot;sayName&quot;</div><div class="line">/*</div><div class="line">如果对象的方法使用了取值函数（getter）和存值函数（setter），</div><div class="line">则name属性不是在该方法上面，而是该方法的属性的描述对象的</div><div class="line">get和set属性上面，返回值是方法名前加上get和set。</div><div class="line">*/</div><div class="line">const obj = &#123;</div><div class="line">  get foo() &#123;&#125;,</div><div class="line">  set foo(x) &#123;&#125;</div><div class="line">&#125;;</div><div class="line">obj.foo.name</div><div class="line">// TypeError: Cannot read property &apos;name&apos; of undefined</div><div class="line">const descriptor = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;);</div><div class="line">descriptor.get.name // &quot;get foo&quot;</div><div class="line">descriptor.set.name // &quot;set foo&quot;</div><div class="line"></div><div class="line">(new Function()).name // &quot;anonymous&quot;</div><div class="line"></div><div class="line">var doSomething = function() &#123;</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line">doSomething.bind().name // &quot;bound doSomething&quot;</div><div class="line">//如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</div><div class="line">const key1 = Symbol(&apos;description&apos;);</div><div class="line">const key2 = Symbol();</div><div class="line">let obj = &#123;</div><div class="line">  [key1]() &#123;&#125;,</div><div class="line">  [key2]() &#123;&#125;,</div><div class="line">&#125;;</div><div class="line">obj[key1].name // &quot;[description]&quot;</div><div class="line">obj[key2].name // &quot;&quot;</div></pre></td></tr></table></figure>
<ol>
<li>Object.is()</li>
</ol>
<blockquote>
<p>ES5中只有==（自动转换数据类型）和===（NaN!=NaN,+0==-0）,ES6中提出<br>Same-value equality 同值相等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Object.is(&apos;foo&apos;, &apos;foo&apos;);// true</div><div class="line">Object.is(&#123;&#125;, &#123;&#125;);// false</div><div class="line">+0 === -0 //true</div><div class="line">NaN === NaN // false</div><div class="line">Object.is(+0, -0) // false</div><div class="line">Object.is(NaN, NaN) // true</div><div class="line">Object.defineProperty(Object, &apos;is&apos;, &#123;</div><div class="line">  value: function(x, y) &#123;</div><div class="line">    if (x === y) &#123;</div><div class="line">      // 针对+0 不等于 -0的情况</div><div class="line">      return x !== 0 || 1 / x === 1 / y;</div><div class="line">    &#125;</div><div class="line">    // 针对NaN的情况</div><div class="line">    return x !== x &amp;&amp; y !== y;</div><div class="line">  &#125;,</div><div class="line">  configurable: true,</div><div class="line">  enumerable: false,</div><div class="line">  writable: true</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>Object.assign()</li>
</ol>
<p>用于对象合并，将源对象(source)所有可枚举属性，复制到目标对象(target)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">var target=&#123;a:1&#125;;</div><div class="line">var source1=&#123;b:2&#125;;</div><div class="line">var source2=&#123;c:3&#125;;</div><div class="line">Object.assign(target,source1,source2);</div><div class="line">target;//&#123;a:1,b:2,c:3&#125;</div><div class="line">var obj = &#123;a: 1&#125;;</div><div class="line">Object.assign(obj) === obj // true,如果只有一个参数，Object.assign会直接返回该参数。</div><div class="line">typeof Object.assign(2) // &quot;object&quot; 如果该参数不是对象，则会先转成对象，然后返回。</div><div class="line">Object.assign(undefined) // 报错</div><div class="line">Object.assign(null) // 报错,由于undefined和null无法转成对象</div><div class="line">Object.assign(obj, undefined) === obj // true,如果无法转成对象，就会跳过</div><div class="line"></div><div class="line">var v1 = &apos;abc&apos;;</div><div class="line">var v2 = true;</div><div class="line">var v3 = 10;</div><div class="line">var obj = Object.assign(&#123;&#125;, v1, v2, v3);</div><div class="line">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</div><div class="line">//只有字符串的包装对象，会产生可枚举属性。故除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</div><div class="line">Object(true) // &#123;[[PrimitiveValue]]: true&#125;</div><div class="line">Object(10)  //  &#123;[[PrimitiveValue]]: 10&#125;</div><div class="line">Object(&apos;abc&apos;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</div><div class="line"></div><div class="line">Object.assign(&#123;b: &apos;c&apos;&#125;,</div><div class="line">  Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123;</div><div class="line">    enumerable: false,</div><div class="line">    value: &apos;hello&apos;</div><div class="line">  &#125;)</div><div class="line">)</div><div class="line">// &#123; b: &apos;c&apos; &#125; ，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</div><div class="line"></div><div class="line">Object.assign(&#123; a: &apos;b&apos; &#125;, &#123; [Symbol(&apos;c&apos;)]: &apos;d&apos; &#125;)</div><div class="line">// &#123; a: &apos;b&apos;, Symbol(c): &apos;d&apos; &#125;</div><div class="line"></div><div class="line">Object.assign([1, 2, 3], [4, 5])</div><div class="line">// [4, 5, 3] ，把数组视为对象。</div></pre></td></tr></table></figure></p>
<p><em>Object.assign进行的是浅拷贝</em></p>
<p>应用：</p>
<ol>
<li>为对象添加属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Point&#123;</div><div class="line">    constructor(x,y)&#123;</div><div class="line">        Object.assign(this,&#123;x,y&#125;);//将x属性和y属性添加到Point类的对象实例。</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>为对象添加方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Object.assign(SomeClass.prototype, &#123;</div><div class="line">  someMethod(arg1, arg2) &#123;</div><div class="line">  &#125;,</div><div class="line">  anotherMethod() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">//等同于</div><div class="line">SomeClass.prototype.someMethod = function (arg1, arg2) &#123;</div><div class="line">&#125;;</div><div class="line">SomeClass.prototype.anotherMethod = function () &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>克隆对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function clone(origin)&#123;</div><div class="line">    return Object.assign(&#123;&#125;,origin);</div><div class="line">&#125;//只克隆原始对象自身的值而克隆不了其继承的值</div><div class="line">function clone(origin)&#123;</div><div class="line">    let originProto=Object.getPrototypeOf(origin);</div><div class="line">    return Object.assign(Object.create(originProto),origin);</div><div class="line">&#125;//不仅克隆本身还克隆其继承的值</div></pre></td></tr></table></figure>
<p>4.合并对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//将多个对象合并到某个对象</div><div class="line">const merge=(target,...source)=&gt;Object.assign(target,...source);</div><div class="line">//合并后返回一个新对象</div><div class="line">const merge=(...source)=&gt;Object.assign(&#123;&#125;,...source);</div></pre></td></tr></table></figure>
<ol>
<li>为属性指定默认值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const DEFAULTS = &#123;</div><div class="line">  logLevel: 0,</div><div class="line">  outputFormat: &apos;html&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function processContent(options) &#123;</div><div class="line">  options = Object.assign(&#123;&#125;, DEFAULTS, options);</div><div class="line">  console.log(options);</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>6.属性的可枚举性：Object.getOwnPropertyDescriptor可以获取该属性的描述对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let obj = &#123; foo: 123 &#125;;</div><div class="line">Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</div><div class="line">//  &#123;</div><div class="line">//    value: 123,</div><div class="line">//    writable: true,</div><div class="line">//    enumerable: true,</div><div class="line">//    configurable: true</div><div class="line">//  &#125;</div></pre></td></tr></table></figure>
<p><em>ES5的三个操作会忽略enumerable为false的属性</em></p>
<ul>
<li>for…in循环:只遍历对象自身<em>及继承的</em>可枚举属性</li>
<li>Object.keys():返回对象自身所有科美居属性的键名</li>
<li>JSON.stringify():只串行化对象自身的可枚举属性</li>
<li>ES 6中Object.assign()会忽略enumerable为false的属性,只拷贝对象自身可枚举属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable</div><div class="line">// false</div><div class="line">Object.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable</div><div class="line">// false</div><div class="line">Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &apos;foo&apos;).enumerable</div><div class="line">// false,故for...in不会遍历到这两个继承自原型的属性。</div><div class="line">//一般我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>属性遍历</p>
<ol>
<li>for…in :对象自身的和继承的可枚举属性（不含Symbol属性）。</li>
<li>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</li>
<li>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</li>
<li>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</li>
<li>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)</div><div class="line">// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()]</div><div class="line">//遍历顺序：数值&gt;字符串&gt;Symbol</div></pre></td></tr></table></figure>
<ol>
<li><strong>proto</strong>属性，Object.setPrototypeOf(),Object.getPrototypeOf()</li>
</ol>
<blockquote>
<p><strong>proto</strong>读取或设置对象的prototype对象，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性<br>后边几个替代之</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf(&#123; __proto__: null &#125;)</div><div class="line">// null,设置了__proto__属性的对象，其值既是对象的原型</div><div class="line">// 格式, ES6 正式推荐</div><div class="line">Object.setPrototypeOf(object, prototype);</div><div class="line">Object.getPrototypeOf(obj);</div><div class="line">// 用法</div><div class="line">var o = Object.setPrototypeOf(&#123;&#125;, null);</div><div class="line">function Rectangle() &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">var rec = new Rectangle();</div><div class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</div><div class="line">// true</div><div class="line">Object.setPrototypeOf(rec, Object.prototype);</div><div class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</div><div class="line">// false</div></pre></td></tr></table></figure>
<ol>
<li><p>Object.keys(),Object.values(),Object.entries()</p>
</li>
<li><p>对象的扩展运算符</p>
<ol>
<li><p>解耦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</div><div class="line">x // 1</div><div class="line">y // 2</div><div class="line">z // &#123; a: 3, b: 4 &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let z = &#123; a: 3, b: 4 &#125;;</div><div class="line">let n = &#123; ...z &#125;;</div><div class="line">n // &#123; a: 3, b: 4 &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>Object.getOwnPropertyDescriptors() </p>
</li>
</ol>
<blockquote>
<p>指定对象所有自身属性（非继承属性）的描述对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;</div><div class="line">  foo: 123,</div><div class="line">  get bar() &#123; return &apos;abc&apos; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// &#123; foo:</div><div class="line">//    &#123; value: 123,</div><div class="line">//      writable: true,</div><div class="line">//      enumerable: true,</div><div class="line">//      configurable: true &#125;,</div><div class="line">//   bar:</div><div class="line">//    &#123; get: [Function: bar],</div><div class="line">//      set: undefined,</div><div class="line">//      enumerable: true,</div><div class="line">//      configurable: true &#125; &#125;</div></pre></td></tr></table></figure>
<ol>
<li>Null传导运算符(Babel尚未支持)</li>
</ol>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Guide/Grammar_and_types#Object_literals" target="_blank" rel="external">MDN Grammar and types: Object literals</a></p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ol>
<li>ES5对象属性名都是容易造成命名冲突的字符串，引入Symbol数据类型从根本上解决了此问题</li>
</ol>
<p><em>注意symbol不能用new命令，因为生成Symbol对象是一个原始类型的值，而非对象</em></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> let s=Symbol();</div><div class="line"> typeof s;//&apos;symbol&apos;</div><div class="line">//Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</div><div class="line">var s1=Symbol(&apos;foo&apos;);</div><div class="line">s1;//Symbol(foo)</div><div class="line">s1.toString();//&quot;Symbol(foo)&quot;</div><div class="line">//Symbol函数的参数只是表示对当前 Symbol 值的描述</div><div class="line">var s2 = Symbol(&apos;foo&apos;);</div><div class="line">s1 === s2 // false</div><div class="line">String(s1);//&quot;Symbol(foo)&quot;</div><div class="line">&quot;your symbol is &quot; + s1;//Symbol不能与其它类型值进行运算，但可以显示转为字符串</div><div class="line">var sym = Symbol();</div><div class="line">Boolean(sym) // true</div><div class="line">!sym  // false</div><div class="line">if (sym) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">Number(sym) // TypeError</div><div class="line">sym + 2 // TypeError,Symbol值也可以转为布尔值，但是不能转为数值。</div></pre></td></tr></table></figure>
<ol>
<li>作为属性名的Symbol</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var mySymbol=Symbol();</div><div class="line">var a=&#123;&#125;;</div><div class="line">a[mySymbol]=&apos;hello!&apos;;</div><div class="line">var a=&#123;[mySymbol]:&apos;hello!&apos;&#125;;</div><div class="line">Object.defineProperty(a,mySymbol,&#123;value:&apos;hello!&apos;&#125;);</div><div class="line">a[mySymbol];//&apos;hello!&apos;</div><div class="line">//Symbol值作为对象属性名时，由于点运算符后面总是字符串不会读取mySymbol作为标识名所指代的那个值不能用点运算符</div><div class="line">a.mySymbol=&apos;hello!&apos;;</div><div class="line">a.mySymbol;//&apos;undefined&apos;</div><div class="line">a[&apos;mySymbol&apos;];//&apos;hello!&apos;</div><div class="line">let s = Symbol();</div><div class="line">let obj = &#123;</div><div class="line">   [s](arg) &#123; ... &#125;</div><div class="line">&#125;;</div><div class="line">obj[s](123);</div><div class="line">//实例，常量使用Symbol的好处是任何值都不可能有相同值了，且Symbol值作为属性名时该属性为公有属性</div><div class="line">const COLOR_RED    = Symbol();</div><div class="line">const COLOR_GREEN  = Symbol();</div><div class="line">function getComplement(color) &#123;</div><div class="line">  switch (color) &#123;</div><div class="line">    case COLOR_RED:</div><div class="line">      return COLOR_GREEN;</div><div class="line">    case COLOR_GREEN:</div><div class="line">      return COLOR_RED;</div><div class="line">    default:</div><div class="line">      throw new Error(&apos;Undefined color&apos;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>消除魔术字符串</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const shapeType = &#123;</div><div class="line">  triangle: Symbol()</div><div class="line">&#125;;</div><div class="line">function getArea(shape, options) &#123;</div><div class="line">  var area = 0;</div><div class="line">  switch (shape) &#123;</div><div class="line">    case shapeType.triangle:</div><div class="line">      area = .5 * options.width * options.height;</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">  return area;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);</div></pre></td></tr></table></figure>
<ol>
<li>属性名遍历</li>
</ol>
<blockquote>
<p>Symbol作为属性名，该属性不会出现在for…in，for…of,Object.keys(),<br>Object.getOwnPropertyNames(),JSON.stringify()返回，但也不是私有属性，唯有<br>Object.getOwnPropertySymbols可以获取指定对象的所有Symbol属性名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">var a = Symbol(&apos;a&apos;);</div><div class="line">var b = Symbol(&apos;b&apos;);</div><div class="line">obj[a] = &apos;Hello&apos;;</div><div class="line">obj[b] = &apos;World&apos;;</div><div class="line">Object.getOwnPropertySymbols(obj);// [Symbol(a), Symbol(b)]</div></pre></td></tr></table></figure>
<ol>
<li>Symbol.for(),Symbol.keyFor()</li>
</ol>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Symbol" target="_blank" rel="external">MDN Symbol</a></p>
<h3 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map + Set"></a>Map + Set</h3><blockquote>
<p>Efficient data structures for common algorithms.  WeakMaps provides leak-free object-key’d side tables.</p>
</blockquote>
<ol>
<li>Set</li>
</ol>
<blockquote>
<p>ES6新的数据结构之一，类似数组但成员唯一，Set本身是一个构造函数用来生成Set数据结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var set = new Set([1, 2, 3, 4, 4]);</div><div class="line">[...set] // [1, 2, 3, 4]</div><div class="line">set.size // 4</div><div class="line">function divs () &#123;</div><div class="line">  return [...document.querySelectorAll(&apos;div&apos;)];</div><div class="line">&#125;</div><div class="line">var set = new Set(divs());//or</div><div class="line">divs().forEach(div =&gt; set.add(div));</div><div class="line">set.size // 56</div><div class="line">//Set内部，NaN相等而两个对象不等</div><div class="line">let set = new Set();</div><div class="line">let a = NaN;</div><div class="line">let b = NaN;</div><div class="line">set.add(a);</div><div class="line">set.add(b);</div><div class="line">set // Set &#123;NaN&#125;</div><div class="line"></div><div class="line">et.add(&#123;&#125;);</div><div class="line">set.size // 1</div><div class="line">set.add(&#123;&#125;);</div><div class="line">set.size // 2</div></pre></td></tr></table></figure>
<p>Set实例的属性和方法</p>
<p>属性：</p>
<ul>
<li>Set.prototype.constructor</li>
<li>Set.prototype.size</li>
</ul>
<p>方法</p>
<ul>
<li>add(value)</li>
<li>clear()</li>
<li>delete(value)</li>
<li>has(value)</li>
</ul>
<p>遍历:Set的遍历顺序就是插入顺序</p>
<ul>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
<li>forEach()</li>
</ul>
<p>Array.from可以将Set结构转为数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var items=new Set([1,2,3,4,5]);</div><div class="line">var array=Array.from(items);</div><div class="line">[...new Set(arr)]//不失为数组去重的好方法</div><div class="line">Array.from(new Set(arr));//不失为数组去重的好方法</div><div class="line"></div><div class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</div><div class="line">for (let item of set.keys()) &#123;</div><div class="line">  console.log(item);</div><div class="line">&#125;</div><div class="line">// red green blue</div><div class="line">for (let item of set.values()) &#123;</div><div class="line">  console.log(item);</div><div class="line">&#125;</div><div class="line">// red green blue</div><div class="line">for (let item of set.entries()) &#123;</div><div class="line">  console.log(item);</div><div class="line">&#125;</div><div class="line">// [&quot;red&quot;, &quot;red&quot;]</div><div class="line">// [&quot;green&quot;, &quot;green&quot;]</div><div class="line">// [&quot;blue&quot;, &quot;blue&quot;]</div><div class="line"></div><div class="line">Set.prototype[Symbol.iterator] === Set.prototype.values;//可以省略values方法</div><div class="line">// true</div></pre></td></tr></table></figure>
<ol>
<li>WeakSet</li>
</ol>
<blockquote>
<p>WeakSet成员只能是弱引用对象，成员不可遍历</p>
</blockquote>
<ol>
<li>Map</li>
</ol>
<blockquote>
<p>JS对象本质是键值对的集合（hash结构），但传统上只能用字符串作键。ES6中<br>的Map类对象的数据结构使得各种类型的值都可以作键，是一种更完善的hash结构实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var m = new Map();</div><div class="line">var o = &#123;p: &apos;Hello World&apos;&#125;;</div><div class="line">m.set(o, &apos;content&apos;)</div><div class="line">m.get(o) // &quot;content&quot;</div><div class="line">m.has(o) // true</div><div class="line">m.delete(o) // true</div><div class="line">m.has(o) // false</div><div class="line"></div><div class="line">var map = new Map([</div><div class="line">  [&apos;name&apos;, &apos;张三&apos;],</div><div class="line">  [&apos;title&apos;, &apos;Author&apos;]</div><div class="line">]);</div><div class="line">map.size // 2</div><div class="line">map.has(&apos;name&apos;) // true</div><div class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</div><div class="line">map.has(&apos;title&apos;) // true</div><div class="line">map.get(&apos;title&apos;) // &quot;Author&quot;</div></pre></td></tr></table></figure>
<p>实例和属性的操作方法</p>
<ol>
<li>size</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">map.set(&apos;foo&apos;, true);</div><div class="line">map.set(&apos;bar&apos;, false);</div><div class="line">map.size // 2</div></pre></td></tr></table></figure>
<ol>
<li>set(key, value)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var m = new Map();    </div><div class="line">m.set(&quot;edition&quot;, 6)        // 键是字符串</div><div class="line">m.set(262, &quot;standard&quot;)     // 键是数值</div><div class="line">m.set(undefined, &quot;nah&quot;)    // 键是undefined</div><div class="line">let map = new Map()</div><div class="line">  .set(1, &apos;a&apos;)</div><div class="line">  .set(2, &apos;b&apos;)</div><div class="line">  .set(3, &apos;c&apos;);</div></pre></td></tr></table></figure>
<ol>
<li>get(key)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var m = new Map();   </div><div class="line">var hello = function() &#123;console.log(&quot;hello&quot;);&#125;</div><div class="line">m.set(hello, &quot;Hello ES6!&quot;) // 键是函数</div><div class="line">m.get(hello)  // Hello ES6!</div></pre></td></tr></table></figure>
<ol>
<li>has(key)</li>
<li>delete(key)</li>
<li>clear()</li>
</ol>
<p>遍历方法同Set<br>与其它数据结构的互换</p>
<ol>
<li>数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</div><div class="line">[...myMap]</div><div class="line">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</div><div class="line">new Map([[true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])</div><div class="line">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</div></pre></td></tr></table></figure>
<ol>
<li>对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function strMapToObj(strMap) &#123;</div><div class="line">  let obj = Object.create(null);</div><div class="line">  for (let [k,v] of strMap) &#123;</div><div class="line">    obj[k] = v;</div><div class="line">  &#125;</div><div class="line">  return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</div><div class="line">strMapToObj(myMap)</div><div class="line">// &#123; yes: true, no: false &#125;</div><div class="line">function objToStrMap(obj) &#123;</div><div class="line">  let strMap = new Map();</div><div class="line">  for (let k of Object.keys(obj)) &#123;</div><div class="line">    strMap.set(k, obj[k]);</div><div class="line">  &#125;</div><div class="line">  return strMap;</div><div class="line">&#125;   </div><div class="line">objToStrMap(&#123;yes: true, no: false&#125;)</div><div class="line">// [ [ &apos;yes&apos;, true ], [ &apos;no&apos;, false ] ]</div></pre></td></tr></table></figure>
<ol>
<li>JSON</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function strMapToJson(strMap) &#123;</div><div class="line">  return JSON.stringify(strMapToObj(strMap));</div><div class="line">&#125;   </div><div class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</div><div class="line">strMapToJson(myMap)</div><div class="line">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</div><div class="line"></div><div class="line">function jsonToStrMap(jsonStr) &#123;</div><div class="line">  return objToStrMap(JSON.parse(jsonStr));</div><div class="line">&#125;    </div><div class="line">jsonToStrMap(&apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;)</div><div class="line">// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125;</div></pre></td></tr></table></figure>
<ol>
<li>WeakMap:只接收不计入GC的对象作为键名</li>
</ol>
<p>More MDN info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Map" target="_blank" rel="external">Map</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Set" target="_blank" rel="external">Set</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/WeakMap" target="_blank" rel="external">WeakMap</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/WeakSet" target="_blank" rel="external">WeakSet</a></p>
<h3 id="Proxy代理"><a href="#Proxy代理" class="headerlink" title="Proxy代理"></a>Proxy代理</h3><blockquote>
<p>用于修改某些操作的默认行为,等同于在语言层面修改，属于meta programming元编程<br>即对编程语言编程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</div><div class="line">var obj = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get: function (target, key, receiver) &#123;</div><div class="line">    console.log(`getting $&#123;key&#125;!`);</div><div class="line">    return Reflect.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: function (target, key, value, receiver) &#123;</div><div class="line">    console.log(`setting $&#123;key&#125;!`);</div><div class="line">    return Reflect.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">obj.count = 1</div><div class="line">//  setting count!</div><div class="line">++obj.count</div><div class="line">//  getting count!</div><div class="line">//  setting count!</div><div class="line">//  2</div></pre></td></tr></table></figure>
<p>proxy支持的操作</p>
<ul>
<li>get(target, propKey, receiver) 拦截对象属性的读取</li>
<li>set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。</li>
<li>getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)拦截Object.getPrototypeOf(proxy)，返回一个对象</li>
<li>isExtensible(target)拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</li>
<li>apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Proxying a normal object</div><div class="line">var target = &#123;&#125;;</div><div class="line">var handler = &#123;</div><div class="line">  get: function (receiver, name) &#123;</div><div class="line">    return `Hello, $&#123;name&#125;!`;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var p = new Proxy(target, handler);</div><div class="line">p.world === &apos;Hello, world!&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Proxying a function object</div><div class="line">var target = function () &#123; return &apos;I am the target&apos;; &#125;;</div><div class="line">var handler = &#123;</div><div class="line">  apply: function (receiver, ...args) &#123;</div><div class="line">    return &apos;I am the proxy&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var p = new Proxy(target, handler);</div><div class="line">p() === &apos;I am the proxy&apos;;</div></pre></td></tr></table></figure>
<p>There are traps available for all of the runtime-level meta-operations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var handler =</div><div class="line">&#123;</div><div class="line">  get:...,</div><div class="line">  set:...,</div><div class="line">  has:...,</div><div class="line">  deleteProperty:...,</div><div class="line">  apply:...,</div><div class="line">  construct:...,</div><div class="line">  getOwnPropertyDescriptor:...,</div><div class="line">  defineProperty:...,</div><div class="line">  getPrototypeOf:...,</div><div class="line">  setPrototypeOf:...,</div><div class="line">  enumerate:...,</div><div class="line">  ownKeys:...,</div><div class="line">  preventExtensions:...,</div><div class="line">  isExtensible:...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Proxy" target="_blank" rel="external">MDN Proxy</a></p>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>设计目的：</p>
<ol>
<li>将Object对象一些明显属于语言内部的方法（Object.defineProperty）,放到Reflect对象上</li>
<li>修改某些Object方法的返回结果，让其变得更合理。</li>
</ol>
<blockquote>
<p>如，Object.defineProperty(obj, name, desc)在无法定义属性时，<br>    会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">try&#123;</div><div class="line">    Object.defineProperty(target,property,attributes);</div><div class="line">&#125;catch(e)&#123;&#125;</div><div class="line">//ES6</div><div class="line">if(Reflect.defineProperty(target,property,attributes))&#123;</div><div class="line">//success</div><div class="line">&#125;else&#123;//failure&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>让Object操作都变成函数行为。</li>
</ol>
<blockquote>
<p>某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)<br>和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;assign&apos; in Object;//true ES5</div><div class="line">Reflect.has(Object,&apos;assign&apos;);//true</div></pre></td></tr></table></figure>
<ol>
<li>Reflect对象的方法与Proxy对象的方法一一对应。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var loggedObj = new Proxy(obj, &#123;</div><div class="line">  get(target, name) &#123;</div><div class="line">    console.log(&apos;get&apos;, target, name);</div><div class="line">    return Reflect.get(target, name);</div><div class="line">  &#125;,</div><div class="line">  deleteProperty(target, name) &#123;</div><div class="line">    console.log(&apos;delete&apos; + name);</div><div class="line">    return Reflect.deleteProperty(target, name);</div><div class="line">  &#125;,</div><div class="line">  has(target, name) &#123;</div><div class="line">    console.log(&apos;has&apos; + name);</div><div class="line">    return Reflect.has(target, name);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 ES5</div><div class="line">Reflect.apply(Math.floor, undefined, [1.75]) // 1</div></pre></td></tr></table></figure>
<ol>
<li>静态方法</li>
</ol>
<ul>
<li>Reflect.apply(target,thisArg,args)</li>
<li>Reflect.construct(target,args)</li>
<li>Reflect.get(target,name,receiver)</li>
<li>Reflect.set(target,name,value,receiver)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.deleteProperty(target,name)</li>
<li>Reflect.has(target,name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)<br>实例：使用Proxy实现观察者模式</li>
</ul>
<blockquote>
<p>函数自动观察数据对象，一旦对象有变化函数变化便自动执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const queuedObservers = new Set();</div><div class="line">const observe = fn =&gt; queuedObservers.add(fn);</div><div class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</div><div class="line"></div><div class="line">function set(target, key, value, receiver) &#123;</div><div class="line">  const result = Reflect.set(target, key, value, receiver);</div><div class="line">  queuedObservers.forEach(observer =&gt; observer());</div><div class="line">  return result;</div><div class="line">&#125;</div><div class="line">const person = observable(&#123;</div><div class="line">  name: &apos;张三&apos;,</div><div class="line">  age: 20</div><div class="line">&#125;);</div><div class="line">function print() &#123;</div><div class="line">  console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)</div><div class="line">&#125;</div><div class="line">observe(print);</div><div class="line">person.name = &apos;李四&apos;;</div></pre></td></tr></table></figure>
<h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><blockquote>
<p>Promise,简而言之即存放未来才会结束的事件结果的容器。</p>
</blockquote>
<ol>
<li>特点：<ol>
<li>对象状态不受外部影响。<blockquote>
<p>Promise代表一个异步操作，有三种状态：Pending(进行中)，Resolved(已完成)和<br>Rejected(已失败)。只有异步操作的结果可以决定当前是哪一种状态，也即是Promise名字的由来。</p>
</blockquote>
</li>
<li>状态改变就不会再变，任何时候都可以得到该结果。<blockquote>
<p>Promise对象状态的改变有两种：从Pending变为Resolved和从Pending变为Rejected。<br>只要此二种情况发生就凝固了，结果不会再变。与事件event完全不同（错过了再去监听则得不到结果）</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p><em>有了Promise对象即可以同步操作的流程实现异步操作，避免了回调地狱；且Promise对象提供统一接口，简化了异步操作</em><br>缺点是：</p>
<ul>
<li>无法取消Promise，一旦建立则立即执行；</li>
<li>如无回调函数，内部抛出错误但外部无反应；</li>
<li>当处于Pending时，无法得知目前进行到哪个阶段</li>
<li>如某事件不断发生，stream模式则优于Promise</li>
</ul>
<ol>
<li>基本用法</li>
</ol>
<blockquote>
<p>Promise对象是一个构造函数，用来生成Promise实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">//Promise新建后就会立即执行</div><div class="line">let promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">promise.then(function() &#123;</div><div class="line">  console.log(&apos;Resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi!&apos;);</div><div class="line">// Promise</div><div class="line">// Hi!</div><div class="line">// Resolved</div></pre></td></tr></table></figure>
<p>实例：实现Ajax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var getJSON = function(url) &#123;</div><div class="line">  var promise = new Promise(function(resolve, reject)&#123;</div><div class="line">    var client = new XMLHttpRequest();</div><div class="line">    client.open(&quot;GET&quot;, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = &quot;json&quot;;</div><div class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    function handler() &#123;</div><div class="line">      if (this.readyState !== 4) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      if (this.status === 200) &#123;</div><div class="line">        resolve(this.response);</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(new Error(this.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  return promise;</div><div class="line">&#125;;</div><div class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class="line">  console.log(&apos;Contents: &apos; + json);</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  console.error(&apos;出错了&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>Promise.prototype.then()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getJSON(&quot;/post/1.json&quot;).then(</div><div class="line">  post =&gt; getJSON(post.commentURL)</div><div class="line">).then(</div><div class="line">  comments =&gt; console.log(&quot;Resolved: &quot;, comments),</div><div class="line">  err =&gt; console.log(&quot;Rejected: &quot;, err)</div><div class="line">);</div></pre></td></tr></table></figure>
<ol>
<li>Promise.prototype.catch()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 写法一</div><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  try &#123;</div><div class="line">    throw new Error(&apos;test&apos;);</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">    reject(e);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">promise.catch(function(error) &#123;</div><div class="line">  console.log(error);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 写法二,reject方法的作用，等同于抛出错误</div><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  reject(new Error(&apos;test&apos;));</div><div class="line">&#125;);</div><div class="line">promise.catch(function(error) &#123;</div><div class="line">  console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>Promise.all()</li>
</ol>
<blockquote>
<p>将多个Promise实例包装成一个新的实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。</div><div class="line">var p=Promise.all([p1,p2,p3]);</div></pre></td></tr></table></figure>
<ol>
<li>Promise.race()</li>
<li>Promise.resolve()</li>
</ol>
<blockquote>
<p>将现有对象转为Promise对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var jsPromise=Promise.resolve($.ajax(&apos;/whatever.json&apos;))；</div><div class="line">//将jQuery生成的deferred对象，转为一个新的Promise对象</div><div class="line">Promise.resolve(&apos;foo&apos;);</div><div class="line">// 等价于但并不等于(异曲同工)</div><div class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</div></pre></td></tr></table></figure>
<ol>
<li>Promise.reject()</li>
<li>两个附加方法：done(),finally()</li>
</ol>
<blockquote>
<p>应用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">function timeout(duration = 0) &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        setTimeout(resolve, duration);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = timeout(1000).then(() =&gt; &#123;</div><div class="line">    return timeout(2000);</div><div class="line">&#125;).then(() =&gt; &#123;</div><div class="line">    throw new Error(&quot;hmm&quot;);</div><div class="line">&#125;).catch(err =&gt; &#123;</div><div class="line">    return Promise.all([timeout(100), timeout(200)]);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//promise combination</div><div class="line">function fetchAsync (url, timeout, onData, onError) &#123;</div><div class="line">    …</div><div class="line">&#125;</div><div class="line">let fetchPromised = (url, timeout) =&gt; &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        fetchAsync(url, timeout, resolve, reject)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">Promise.all([</div><div class="line">    fetchPromised(&quot;http://backend/foo.txt&quot;, 500),</div><div class="line">    fetchPromised(&quot;http://backend/bar.txt&quot;, 500),</div><div class="line">    fetchPromised(&quot;http://backend/baz.txt&quot;, 500)</div><div class="line">]).then((data) =&gt; &#123;</div><div class="line">    let [ foo, bar, baz ] = data</div><div class="line">    console.log(`success: foo=$&#123;foo&#125; bar=$&#123;bar&#125; baz=$&#123;baz&#125;`)</div><div class="line">&#125;, (err) =&gt; &#123;</div><div class="line">    console.log(`error: $&#123;err&#125;`)</div><div class="line">&#125;)</div><div class="line">//ES5</div><div class="line">function fetchAsync (url, timeout, onData, onError) &#123;</div><div class="line">    …</div><div class="line">&#125;</div><div class="line">function fetchAll (request, onData, onError) &#123;</div><div class="line">    var result = [], results = 0;</div><div class="line">    for (var i = 0; i &lt; request.length; i++) &#123;</div><div class="line">        result[i] = null;</div><div class="line">        (function (i) &#123;</div><div class="line">            fetchAsync(request[i].url, request[i].timeout, function (data) &#123;</div><div class="line">                result[i] = data;</div><div class="line">                if (++results === request.length)</div><div class="line">                    onData(result);</div><div class="line">            &#125;, onError);</div><div class="line">        &#125;)(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fetchAll([</div><div class="line">    &#123; url: &quot;http://backend/foo.txt&quot;, timeout: 500 &#125;,</div><div class="line">    &#123; url: &quot;http://backend/bar.txt&quot;, timeout: 500 &#125;,</div><div class="line">    &#123; url: &quot;http://backend/baz.txt&quot;, timeout: 500 &#125;</div><div class="line">], function (data) &#123;</div><div class="line">    var foo = data[0], bar = data[1], baz = data[2];</div><div class="line">    console.log(&quot;success: foo=&quot; + foo + &quot; bar=&quot; + bar + &quot; baz=&quot; + baz);</div><div class="line">&#125;, function (err) &#123;</div><div class="line">    console.log(&quot;error: &quot; + err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Promise" target="_blank" rel="external">MDN Promise</a></p>
<h3 id="Iterators-For-Of"><a href="#Iterators-For-Of" class="headerlink" title="Iterators + For..Of"></a>Iterators + For..Of</h3><blockquote>
<p>Iterator objects enable custom iteration like CLR IEnumerable or Java Iterable(Iterator对象启用自定义迭代，像CLR IEnumerable或Java Iterable。).<br>Generalize <code>for..in</code> to custom iterator-based iteration with <code>for..of</code>.  Don’t require realizing an array, enabling lazy design patterns like LINQ.<br>JS中集合主要有Array,Object,Map,Set;需要一种统一的接口机制，来处理所有不同的数据结构</p>
</blockquote>
<p>Iterator应运而生，其作用有</p>
<pre><code>1. 为各种数据结构提供一个统一的简便的访问接口；
2. 使得数据结构的成员能够按某种次序排列；
3. ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供其消费
</code></pre><p>遍历过程：</p>
<pre><code>1. 创建一个指针对象，指向当前数据结构的起始位置；即遍历器对象的本质是指针对象
2. 第n次调用指针对象的next方法，将指针指向nth数据成员；
3. 不断调用指针对象的next方法，直到指向数据结构的结束位置。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);</div><div class="line">it.next() // &#123; value: &quot;a&quot;, done: false &#125;</div><div class="line">it.next() // &#123; value: &quot;b&quot;, done: false &#125;</div><div class="line">it.next() // &#123; value: undefined, done: true &#125;</div><div class="line">function makeIterator(array) &#123;</div><div class="line">  var nextIndex = 0;</div><div class="line">  return &#123;</div><div class="line">    next: function() &#123;</div><div class="line">      return nextIndex &lt; array.length ?</div><div class="line">        &#123;value: array[nextIndex++], done: false&#125; :</div><div class="line">        &#123;value: undefined, done: true&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>数据结构默认Iterator接口</li>
</ol>
<blockquote>
<p>Iterator是为for…of而生的，当使用for…of时，该循环会自动寻找Iterator接口；一种数据结构只要部署了<br>Iterator接口即为可遍历的（iterable），ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">let fibonacci = &#123;</div><div class="line">  [Symbol.iterator]() &#123;</div><div class="line">    let pre = 0, cur = 1;</div><div class="line">    return &#123;</div><div class="line">      next() &#123;</div><div class="line">        [pre, cur] = [cur, pre + cur];</div><div class="line">        return &#123; done: false, value: cur &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">for (var n of fibonacci) &#123;</div><div class="line">  // truncate the sequence at 1000</div><div class="line">  if (n &gt; 1000)</div><div class="line">    break;</div><div class="line">  console.log(n);</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">var fibonacci = &#123;</div><div class="line">    next: (function () &#123;</div><div class="line">        var pre = 0, cur = 1;</div><div class="line">        return function () &#123;</div><div class="line">            tmp = pre;</div><div class="line">            pre = cur;</div><div class="line">            cur += tmp;</div><div class="line">            return cur;</div><div class="line">        &#125;;</div><div class="line">    &#125;)()</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var n;</div><div class="line">for (;;) &#123;</div><div class="line">    n = fibonacci.next();</div><div class="line">    if (n &gt; 1000)</div><div class="line">        break;</div><div class="line">    console.log(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Iteration is based on these duck-typed interfaces (using <a href="http://typescriptlang.org" target="_blank" rel="external">TypeScript</a> type syntax for exposition only):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">TypeScript</div><div class="line">interface IteratorResult &#123;</div><div class="line">  done: boolean;</div><div class="line">  value: any;</div><div class="line">&#125;</div><div class="line">interface Iterator &#123;</div><div class="line">  next(): IteratorResult;</div><div class="line">&#125;</div><div class="line">interface Iterable &#123;</div><div class="line">  [Symbol.iterator](): Iterator</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>调用Iterator接口的场合</li>
</ol>
<ul>
<li>解耦赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);</div><div class="line">let [x,y] = set;</div><div class="line">// x=&apos;a&apos;; y=&apos;b&apos;</div><div class="line">let [first, ...rest] = set;</div><div class="line">// first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;];</div></pre></td></tr></table></figure>
<ul>
<li>扩展运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let arr = [&apos;b&apos;, &apos;c&apos;];</div><div class="line">[&apos;a&apos;, ...arr, &apos;d&apos;]</div><div class="line">// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</div></pre></td></tr></table></figure>
<ul>
<li>yield*</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let generator = function* () &#123;</div><div class="line">  yield 1;</div><div class="line">  yield* [2,3,4];</div><div class="line">  yield 5;</div><div class="line">&#125;;</div><div class="line">var iterator = generator();</div><div class="line">iterator.next() // &#123; value: 1, done: false &#125;</div><div class="line">iterator.next() // &#123; value: 2, done: false &#125;</div><div class="line">iterator.next() // &#123; value: 3, done: false &#125;</div><div class="line">iterator.next() // &#123; value: 4, done: false &#125;</div><div class="line">iterator.next() // &#123; value: 5, done: false &#125;</div><div class="line">iterator.next() // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<ul>
<li>其它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for...of</div><div class="line">Array.from()</div><div class="line">Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&apos;a&apos;,1],[&apos;b&apos;,2]])）</div><div class="line">Promise.all()</div><div class="line">Promise.race()</div></pre></td></tr></table></figure>
<ol>
<li>字符串的Iterator接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var someString = &quot;hi&quot;;</div><div class="line">typeof someString[Symbol.iterator]</div><div class="line">// &quot;function&quot;</div><div class="line">var iterator = someString[Symbol.iterator]();</div><div class="line">iterator.next()  // &#123; value: &quot;h&quot;, done: false &#125;</div><div class="line">iterator.next()  // &#123; value: &quot;i&quot;, done: false &#125;</div><div class="line">iterator.next()  // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<ol>
<li>Iterator与Generator函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var myIterable = &#123;&#125;;</div><div class="line"></div><div class="line">myIterable[Symbol.iterator] = function* () &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;;</div><div class="line">[...myIterable] // [1, 2, 3]</div><div class="line">// 或者采用下面的简洁写法</div><div class="line">let obj = &#123;</div><div class="line">  * [Symbol.iterator]() &#123;</div><div class="line">    yield &apos;hello&apos;;</div><div class="line">    yield &apos;world&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">for (let x of obj) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div><div class="line">// hello</div><div class="line">// world</div></pre></td></tr></table></figure>
<ol>
<li>遍历器对象的return()，throw()</li>
<li>for…of循环</li>
</ol>
<blockquote>
<p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
</blockquote>
<p>与其它遍历语法比较</p>
<ul>
<li>for循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var index = 0; index &lt; myArray.length; index++) &#123;</div><div class="line">  console.log(myArray[index]);</div><div class="line">&#125;</div><div class="line">//比较繁琐，故数组内置forEach方法</div></pre></td></tr></table></figure>
<ul>
<li>forEach</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myArray.forEach(function (value) &#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;);</div><div class="line">//无法跳出forEach循环，break,continue也无能为力</div></pre></td></tr></table></figure>
<ul>
<li>for…in循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var index in myArray) &#123;</div><div class="line">  console.log(myArray[index]);</div><div class="line">&#125;</div><div class="line">//可以遍历数组键名</div></pre></td></tr></table></figure>
<p>缺点如下：</p>
<pre><code>1. 数组的键名是数字，但for...in循环是以字符串作为键名的；
2. 不仅遍历数字键名，而且还遍历手动添加的其它键，乃至原型链上的键；
3. 某些情况下，for...in循环以任意顺序遍历键名
</code></pre><p>总之，for…in循环主要是为遍历对象而设计的，不适用于数组遍历</p>
<ul>
<li>for…of循环优点如下，故首选之。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var n of fibonacci) &#123;</div><div class="line">  if (n &gt; 1000)</div><div class="line">    break;</div><div class="line">  console.log(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>有着for…in循环的简洁语法，但规避了其缺点；</li>
<li>不同于forEach方法，可以与break，continue，和return配合使用；</li>
<li>提供了遍历所有数据结构的同意操作接口。</li>
</ol>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/for...of" target="_blank" rel="external">MDN for…of</a></p>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><ol>
<li>简介</li>
</ol>
<blockquote>
<p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。语法上，Generator函数是一个状态机，<br>封装了多个内部状态。执行之，会返回一个遍历器对象，即其除了状态机还是一个遍历器生成函数，返回的遍历器对象可依次遍历<br>其内每个状态。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function* helloWorldGenerator() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line">var hw = helloWorldGenerator();</div></pre></td></tr></table></figure>
<p>yield语句</p>
<blockquote>
<p>Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，<br>故其实提供了一种可以暂停执行的函数，yield语句即暂停标识。</p>
</blockquote>
<p>遍历器next方法运行逻辑如下：</p>
<ol>
<li>遇到yield，暂停执行其后操作，并将紧跟在yield后的表达式值作为返回对象的value属性值</li>
<li>下一次调用next方法时，继续往下执行，直到遇到下一个yield语句。</li>
<li>如未遇yield语句，就一直运行到函数结束知道return语句为止，并将return语句后的表达式值作为返回对象的value属性值。</li>
<li>如无return语句则返回对象的value属性值为undefined</li>
</ol>
<p>yield与return对比</p>
<blockquote>
<p>同：都能返回紧跟气候的表达式值；异：每次遇到yield函数暂停执行，下次继续从此执行，而return不具位置记忆功能，<br>一个函数里只能执行一次return但可以执行多次yield语句。Generator函数可以返回一系列的值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* f() &#123;</div><div class="line">  console.log(&apos;执行了！&apos;)</div><div class="line">&#125;</div><div class="line">var generator = f();</div><div class="line">setTimeout(function () &#123;</div><div class="line">  generator.next()</div><div class="line">&#125;, 2000);</div></pre></td></tr></table></figure>
<p><em>若f是普通函数，为变量generator赋值便执行。但如f为Generator函数，只有调用next方法时才会执行。<br>且yield只能用在Generator函数中</em></p>
<ol>
<li>next方法的参数</li>
</ol>
<blockquote>
<p>yield语句本身无返回值（返回undefined），next方法可以带一个被当作上一个yield语句返回值的参数。</p>
</blockquote>
<ol>
<li>for…of</li>
</ol>
<blockquote>
<p>for…of循环可以自动遍历Generator函数时生成的Iterator对象且无需next方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">function* foo()&#123;</div><div class="line">    yield 1;</div><div class="line">    yield 2;</div><div class="line">    yield 3;</div><div class="line">    yield 4;</div><div class="line">    return 5</div><div class="line">&#125;</div><div class="line">for(let v of foo())&#123;console.log(v)&#125; //1 2 3 4 </div><div class="line">//一旦next方法返回对象的done为true，for...of终止且不含该返回对象</div><div class="line">//原生的JavaScript对象没有遍历接口，无法使用for...of循环，Generator函数为其加上接口完成遍历</div><div class="line">function* fibonacci() &#123;</div><div class="line">  let [prev, curr] = [0, 1];</div><div class="line">  for (;;) &#123;</div><div class="line">    [prev, curr] = [curr, prev + curr];</div><div class="line">    yield curr;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">for (let n of fibonacci()) &#123;</div><div class="line">  if (n &gt; 1000) break;</div><div class="line">  console.log(n);</div><div class="line">&#125;</div><div class="line">/*除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，</div><div class="line">它们都可以将Generator函数返回的Iterator对象，作为参数。*/</div><div class="line">function* numbers () &#123;</div><div class="line">  yield 1</div><div class="line">  yield 2</div><div class="line">  return 3</div><div class="line">  yield 4</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 扩展运算符</div><div class="line">[...numbers()] // [1, 2]</div><div class="line"></div><div class="line">// Array.from 方法</div><div class="line">Array.from(numbers()) // [1, 2]</div><div class="line"></div><div class="line">// 解构赋值</div><div class="line">let [x, y] = numbers();</div><div class="line">x // 1</div><div class="line">y // 2</div><div class="line"></div><div class="line">// for...of 循环</div><div class="line">for (let n of numbers()) &#123;</div><div class="line">  console.log(n)</div><div class="line">&#125;</div><div class="line">// 1</div><div class="line">// 2</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Generator.prototype.throw()</li>
<li>Generator.prototype.return()</li>
<li>yield*语句</li>
<li>作为属性的Generator函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  myGeneratorMethod: function* () &#123;</div><div class="line">    // ···</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>Generator函数的this</li>
</ol>
<blockquote>
<p>Generator函数总是返回一个其实例且继承了其prototype对象上方法的遍历器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function* g() &#123;&#125;</div><div class="line">g.prototype.hello = function () &#123;</div><div class="line">  return &apos;hi!&apos;;</div><div class="line">&#125;;</div><div class="line">let obj = g();</div><div class="line">obj instanceof g // true</div><div class="line">obj.hello() // &apos;hi!&apos;</div><div class="line">//如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。</div><div class="line">function* g() &#123;</div><div class="line">  this.a = 11;</div><div class="line">&#125;</div><div class="line">let obj = g();</div><div class="line">obj.a // undefined</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Generator与状态机，前者是后者的最佳结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var ticking = true;</div><div class="line">var clock = function() &#123;</div><div class="line">  if (ticking)</div><div class="line">    console.log(&apos;Tick!&apos;);</div><div class="line">  else</div><div class="line">    console.log(&apos;Tock!&apos;);</div><div class="line">  ticking = !ticking;</div><div class="line">&#125;</div><div class="line">//</div><div class="line">var clock = function*() &#123;</div><div class="line">  while (true) &#123;</div><div class="line">    console.log(&apos;Tick!&apos;);</div><div class="line">    yield;</div><div class="line">    console.log(&apos;Tock!&apos;);</div><div class="line">    yield;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>Generator与协程(coroutine)</li>
</ul>
<blockquote>
<p>协程：协作的线程或函数</p>
</blockquote>
<ol>
<li>应用</li>
</ol>
<ul>
<li>异步操作的同步化表达</li>
</ul>
<figure class="highlight plain"><figcaption><span>loadUI() &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  showLoadingScreen();</div><div class="line">  yield loadUIDataAsynchronously();</div><div class="line">  hideLoadingScreen();</div><div class="line">&#125;</div><div class="line">var loader = loadUI();</div><div class="line">// 加载UI</div><div class="line">loader.next()</div><div class="line"></div><div class="line">// 卸载UI</div><div class="line">loader.next()</div></pre></td></tr></table></figure>
<ul>
<li>控制流管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(step1)</div><div class="line">  .then(step2)</div><div class="line">  .then(step3)</div><div class="line">  .then(step4)</div><div class="line">  .then(function (value4) &#123;</div><div class="line">    // Do something with value4</div><div class="line">  &#125;, function (error) &#123;</div><div class="line">    // Handle any error from step1 through step4</div><div class="line">  &#125;)</div><div class="line">  .done();</div><div class="line">  //Generator更优雅</div><div class="line">function* longRunningTask(value1) &#123;</div><div class="line">  try &#123;</div><div class="line">    var value2 = yield step1(value1);</div><div class="line">    var value3 = yield step2(value2);</div><div class="line">    var value4 = yield step3(value3);</div><div class="line">    var value5 = yield step4(value4);</div><div class="line">    // Do something with value4</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    // Handle any error from step1 through step4</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>部署Iterator接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function* iterEntries(obj) &#123;</div><div class="line">  let keys = Object.keys(obj);</div><div class="line">  for (let i=0; i &lt; keys.length; i++) &#123;</div><div class="line">    let key = keys[i];</div><div class="line">    yield [key, obj[key]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let myObj = &#123; foo: 3, bar: 7 &#125;;</div><div class="line"></div><div class="line">for (let [key, value] of iterEntries(myObj)) &#123;</div><div class="line">  console.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// foo 3</div><div class="line">// bar 7</div></pre></td></tr></table></figure>
<ol>
<li>作为数据结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function *doStuff() &#123;</div><div class="line">  yield fs.readFile.bind(null, &apos;hello.txt&apos;);</div><div class="line">  yield fs.readFile.bind(null, &apos;world.txt&apos;);</div><div class="line">  yield fs.readFile.bind(null, &apos;and-such.txt&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>function,iterator protocol</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">let fibonacci = &#123;</div><div class="line">    *[Symbol.iterator]() &#123;</div><div class="line">        let pre = 0, cur = 1</div><div class="line">        for (;;) &#123;</div><div class="line">            [ pre, cur ] = [ cur, pre + cur ]</div><div class="line">            yield cur</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">for (let n of fibonacci) &#123;</div><div class="line">    if (n &gt; 1000)</div><div class="line">        break</div><div class="line">    console.log(n)</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">var fibonacci = &#123;</div><div class="line">      next: (function () &#123;</div><div class="line">          var pre = 0, cur = 1;</div><div class="line">          return function () &#123;</div><div class="line">              tmp = pre;</div><div class="line">              pre = cur;</div><div class="line">              cur += tmp;</div><div class="line">              return cur;</div><div class="line">          &#125;;</div><div class="line">      &#125;)()</div><div class="line">  &#125;;</div><div class="line">  var n;</div><div class="line">  for (;;) &#123;</div><div class="line">      n = fibonacci.next();</div><div class="line">      if (n &gt; 1000)</div><div class="line">          break;</div><div class="line">      console.log(n);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//direct use</div><div class="line">function* range (start, end, step) &#123;</div><div class="line">    while (start &lt; end) &#123;</div><div class="line">        yield start</div><div class="line">        start += step</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let i of range(0, 10, 2)) &#123;</div><div class="line">    console.log(i) // 0, 2, 4, 6, 8</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">function range (start, end, step) &#123;</div><div class="line">    var list = [];</div><div class="line">    while (start &lt; end) &#123;</div><div class="line">        list.push(start);</div><div class="line">        start += step;</div><div class="line">    &#125;</div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var r = range(0, 10, 2);</div><div class="line">for (var i = 0; i &lt; r.length; i++) &#123;</div><div class="line">    console.log(r[i]); // 0, 2, 4, 6, 8</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>matching</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let fibonacci = function* (numbers) &#123;</div><div class="line">    let pre = 0, cur = 1</div><div class="line">    while (numbers-- &gt; 0) &#123;</div><div class="line">        [ pre, cur ] = [ cur, pre + cur ]</div><div class="line">        yield cur</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let n of fibonacci(1000))</div><div class="line">    console.log(n)</div><div class="line"></div><div class="line">let numbers = [ ...fibonacci(1000) ]</div><div class="line"></div><div class="line">let [ n1, n2, n3, ...others ] = fibonacci(1000)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>control-flow</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">function async (proc, ...params) &#123;</div><div class="line">    var iterator = proc(...params)</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        let loop = (value) =&gt; &#123;</div><div class="line">            let result</div><div class="line">            try &#123;</div><div class="line">                result = iterator.next(value)</div><div class="line">            &#125;</div><div class="line">            catch (err) &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;</div><div class="line">            if (result.done)</div><div class="line">                resolve(result.value)</div><div class="line">            else if (   typeof result.value      === &quot;object&quot;</div><div class="line">                     &amp;&amp; typeof result.value.then === &quot;function&quot;)</div><div class="line">                result.value.then((value) =&gt; &#123;</div><div class="line">                    loop(value)</div><div class="line">                &#125;, (err) =&gt; &#123;</div><div class="line">                    reject(err)</div><div class="line">                &#125;)</div><div class="line">            else</div><div class="line">                loop(result.value)</div><div class="line">        &#125;</div><div class="line">        loop()</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  application-specific asynchronous builder</div><div class="line">function makeAsync (text, after) &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        setTimeout(() =&gt; resolve(text), after)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  application-specific asynchronous procedure</div><div class="line">async(function* (greeting) &#123;</div><div class="line">    let foo = yield makeAsync(&quot;foo&quot;, 300)</div><div class="line">    let bar = yield makeAsync(&quot;bar&quot;, 200)</div><div class="line">    let baz = yield makeAsync(&quot;baz&quot;, 100)</div><div class="line">    return `$&#123;greeting&#125; $&#123;foo&#125; $&#123;bar&#125; $&#123;baz&#125;`</div><div class="line">&#125;, &quot;Hello&quot;).then((msg) =&gt; &#123;</div><div class="line">    console.log(&quot;RESULT:&quot;, msg) // &quot;Hello foo bar baz&quot;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>methods</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Clz &#123;</div><div class="line">    * bar () &#123;</div><div class="line">        …</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let Obj = &#123;</div><div class="line">    * foo () &#123;</div><div class="line">        …</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The generator interface is (using <a href="http://typescriptlang.org" target="_blank" rel="external">TypeScript</a> type syntax for exposition only):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//TypeScript</div><div class="line">interface Generator extends Iterator &#123;</div><div class="line">    next(value?: any): IteratorResult;</div><div class="line">    throw(exception: any);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Iteration_protocols" target="_blank" rel="external">MDN Iteration protocols</a></p>
<h3 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h3><blockquote>
<p>由于JS的执行环境是单线程的，没有异步编程根本没法用。</p>
</blockquote>
<ol>
<li><p>传统方法有以下四种</p>
<ol>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ol>
</li>
<li><p>基本概念</p>
</li>
</ol>
<ul>
<li>异步：一个任务不是连续完成的，先执行第一段然后执行其它任务，等做好了准备再回头执行第二段。</li>
</ul>
<blockquote>
<p>比如读取文件并处理，第一段是向操作系统发出请求，要求读取文件；然后执行其他任务，等到操作系统<br>返回文件，再接着执行任务第二阶段（处理文件）。不连续的执行即异步，连续即同步。</p>
</blockquote>
<ul>
<li>回掉函数：JS对异步编程的实现就是通过回调函数(把任务的第二阶段单独写在一个函数里，等到重新执行该任务<br>时就直接调用这个函数callback)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;/etc/passwd&apos;, &apos;utf-8&apos;, function (err, data) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>Node 错误优先原则：执行分两个阶段，首个执行完之后任务所在的EC已经结束，在此抛出错误原来的EC已无法捕捉，<br>只能当作参数，传入第二段？？？。直观理解就是如果读取文件就出错了那还谈何打印文件，故错误优先</em></p>
<ul>
<li>Promise</li>
</ul>
<blockquote>
<p>回调函数本身无问题，问题在于多层嵌套。而Promise对象应运而生，它并非新的语法功能而是一种新的写法，将嵌套改成链式调用。<br>除此之外并无新意。且其最大的问题是代码冗余，一堆then原来的语义变得不清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</div><div class="line">readFile(fileA)</div><div class="line">.then(function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.then(function () &#123;</div><div class="line">  return readFile(fileB);</div><div class="line">&#125;)</div><div class="line">.then(function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.catch(function (err) &#123;</div><div class="line">  console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Generator函数</li>
</ol>
<blockquote>
<p>传统编程语言早有异步(多任务)的解决方案，其一叫协程(coroutine)，有点像函数又像线程。<br>协程A=》A暂停，协程B=》B交还执行权于A，yield命令是两个阶段的分界线。</p>
</blockquote>
<ul>
<li>Generator函数可以暂停执行和恢复执行，这是它封装异步任务的根本原因。除此之外还有两个特性，<br>使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next(2) // &#123; value: 2, done: true &#125;</div><div class="line">g.throw(&apos;出错了&apos;);</div><div class="line">// 出错了</div></pre></td></tr></table></figure>
<ul>
<li>异步任务的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var fetch = require(&apos;node-fetch&apos;);</div><div class="line">function* gen()&#123;</div><div class="line">  var url = &apos;https://api.github.com/users/github&apos;;</div><div class="line">  var result = yield fetch(url);</div><div class="line">  console.log(result.bio);</div><div class="line">&#125;</div><div class="line">//执行这段代码的方法如下。</div><div class="line">var g = gen();</div><div class="line">var result = g.next();</div><div class="line">result.value.then(function(data)&#123;</div><div class="line">  return data.json();</div><div class="line">&#125;).then(function(data)&#123;</div><div class="line">  g.next(data);</div><div class="line">&#125;);</div><div class="line">/*可以看到，虽然 Generator 函数将异步操作表示得很简洁，</div><div class="line">但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。*/</div></pre></td></tr></table></figure>
<ol>
<li>Thunk函数：自动执行 Generator 函数的一种方法，”传值调用”（call by value）/“传名调用”（call by name）</li>
</ol>
<h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><blockquote>
<p>ES7标准引入async函数使异步操作更加方便，本质是Generator函数的语法糖。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//Generator函数</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var readFile = function (fileName) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">    fs.readFile(fileName, function(error, data) &#123;</div><div class="line">      if (error) reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line">var gen = function* () &#123;</div><div class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div><div class="line">//async 函数</div><div class="line">var asyncReadFile = async function () &#123;</div><div class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><em>async其实就是将Generator函数的※替换成了async，将yield换成了await</em><br>改进如下：</p>
<ul>
<li>内置执行器</li>
</ul>
<figure class="highlight plain"><figcaption><span>result = asyncReadFile();```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 更好的语义</div><div class="line"></div><div class="line">async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</div><div class="line"></div><div class="line">- 更广的适用性</div><div class="line"></div><div class="line">co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值</div><div class="line">（数值、字符串和布尔值，但这时等同于同步操作）。</div><div class="line"></div><div class="line">- 返回值是Promise</div><div class="line"></div><div class="line">async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。</div><div class="line"></div><div class="line">2. 用法</div><div class="line"></div><div class="line">&gt;async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，</div><div class="line">等到异步操作完成，再接着执行函数体内后面的语句。</div></pre></td></tr></table></figure>
<p>function timeout(ms) {<br>  return new Promise((resolve) =&gt; {<br>    setTimeout(resolve, ms);<br>  });<br>}<br>async function asyncPrint(value, ms) {<br>  await timeout(ms);<br>  console.log(value)<br>}<br>asyncPrint(‘hello world’, 50);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 语法</div><div class="line"></div><div class="line">- 返回Promise对象</div></pre></td></tr></table></figure></p>
<p>async function f() {<br>  return ‘hello world’;<br>}<br>f().then(v =&gt; console.log(v))<br>// “hello world”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 错误处理</div></pre></td></tr></table></figure></p>
<p>async function f() {<br>  await new Promise(function (resolve, reject) {<br>    throw new Error(‘出错了’);<br>  });<br>}<br>f()<br>.then(v =&gt; console.log(v))<br>.catch(e =&gt; console.log(e))<br>// Error：出错了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. async函数的实现原理：将 Generator 函数和自动执行器，包装在一个函数里。</div><div class="line"></div><div class="line">###  Classes</div><div class="line"></div><div class="line">&gt;ES6 classes are a simple sugar over the prototype-based OO pattern(ES6类是基于原型的（Object-Oriented）模式的简单糖).  </div><div class="line">Having a single convenient declarative form makes class patterns easier to use, </div><div class="line">and encourages interoperability(互通性).  Classes support prototype-based inheritance, super </div><div class="line">calls,instance and static methods and constructors(支持基于原型的继承，super calls，instance实例及静态方法和构造器).</div></pre></td></tr></table></figure></p>
<p>//class definition<br>class Shape {<br>    constructor (id, x, y) {<br>        this.id = id<br>        this.move(x, y)<br>    }<br>    move (x, y) {<br>        this.x = x<br>        this.y = y<br>    }<br>}<br>//ES5<br>var Shape = function (id, x, y) {<br>    this.id = id;<br>    this.move(x, y);<br>};<br>Shape.prototype.move = function (x, y) {<br>    this.x = x;<br>    this.y = y;<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">//class inheritance</div><div class="line">class Rectangle extends Shape &#123;</div><div class="line">    constructor (id, x, y, width, height) &#123;</div><div class="line">        super(id, x, y)</div><div class="line">        this.width  = width</div><div class="line">        this.height = height</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Circle extends Shape &#123;</div><div class="line">    constructor (id, x, y, radius) &#123;</div><div class="line">        super(id, x, y)</div><div class="line">        this.radius = radius</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">var Rectangle = function (id, x, y, width, height) &#123;</div><div class="line">    Shape.call(this, id, x, y);</div><div class="line">    this.width  = width;</div><div class="line">    this.height = height;</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = Object.create(Shape.prototype);</div><div class="line">Rectangle.prototype.constructor = Rectangle;</div><div class="line">var Circle = function (id, x, y, radius) &#123;</div><div class="line">    Shape.call(this, id, x, y);</div><div class="line">    this.radius = radius;</div><div class="line">&#125;;</div><div class="line">Circle.prototype = Object.create(Shape.prototype);</div><div class="line">Circle.prototype.constructor = Circle;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>inheritance from expressions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">var aggregation = (baseClass, ...mixins) =&gt; &#123;</div><div class="line">    let base = class _Combined extends baseClass &#123;</div><div class="line">        constructor (...args) &#123;</div><div class="line">            super(...args)</div><div class="line">            mixins.forEach((mixin) =&gt; &#123;</div><div class="line">                mixin.prototype.initializer.call(this)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    let copyProps = (target, source) =&gt; &#123;</div><div class="line">        Object.getOwnPropertyNames(source)</div><div class="line">            .concat(Object.getOwnPropertySymbols(source))</div><div class="line">            .forEach((prop) =&gt; &#123;</div><div class="line">            if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))</div><div class="line">                return</div><div class="line">            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    mixins.forEach((mixin) =&gt; &#123;</div><div class="line">        copyProps(base.prototype, mixin.prototype)</div><div class="line">        copyProps(base, mixin)</div><div class="line">    &#125;)</div><div class="line">    return base</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Colored &#123;</div><div class="line">    initializer ()     &#123; this._color = &quot;white&quot; &#125;</div><div class="line">    get color ()       &#123; return this._color &#125;</div><div class="line">    set color (v)      &#123; this._color = v &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ZCoord &#123;</div><div class="line">    initializer ()     &#123; this._z = 0 &#125;</div><div class="line">    get z ()           &#123; return this._z &#125;</div><div class="line">    set z (v)          &#123; this._z = v &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Shape &#123;</div><div class="line">    constructor (x, y) &#123; this._x = x; this._y = y &#125;</div><div class="line">    get x ()           &#123; return this._x &#125;</div><div class="line">    set x (v)          &#123; this._x = v &#125;</div><div class="line">    get y ()           &#123; return this._y &#125;</div><div class="line">    set y (v)          &#123; this._y = v &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Rectangle extends aggregation(Shape, Colored, ZCoord) &#123;&#125;</div><div class="line">var rect = new Rectangle(7, 42)</div><div class="line">rect.z     = 1000</div><div class="line">rect.color = &quot;red&quot;</div><div class="line">console.log(rect.x, rect.y, rect.z, rect.color)</div><div class="line">//ES5</div><div class="line">var aggregation = function (baseClass, mixins) &#123;</div><div class="line">    var base = function () &#123;</div><div class="line">        baseClass.apply(this, arguments);</div><div class="line">        mixins.forEach(function (mixin) &#123;</div><div class="line">            mixin.prototype.initializer.call(this);</div><div class="line">        &#125;.bind(this));</div><div class="line">    &#125;;</div><div class="line">    base.prototype = Object.create(baseClass.prototype);</div><div class="line">    base.prototype.constructor = base;</div><div class="line">    var copyProps = function (target, source) &#123;</div><div class="line">        Object.getOwnPropertyNames(source).forEach(function (prop) &#123;</div><div class="line">            if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))</div><div class="line">                return</div><div class="line">            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    mixins.forEach(function (mixin) &#123;</div><div class="line">        copyProps(base.prototype, mixin.prototype);</div><div class="line">        copyProps(base, mixin);</div><div class="line">    &#125;);</div><div class="line">    return base;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Colored = function () &#123;&#125;;</div><div class="line">Colored.prototype = &#123;</div><div class="line">    initializer: function ()  &#123; this._color = &quot;white&quot;; &#125;,</div><div class="line">    getColor:    function ()  &#123; return this._color; &#125;,</div><div class="line">    setColor:    function (v) &#123; this._color = v; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var ZCoord = function () &#123;&#125;;</div><div class="line">ZCoord.prototype = &#123;</div><div class="line">    initializer: function ()  &#123; this._z = 0; &#125;,</div><div class="line">    getZ:        function ()  &#123; return this._z; &#125;,</div><div class="line">    setZ:        function (v) &#123; this._z = v; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Shape = function (x, y) &#123;</div><div class="line">    this._x = x; this._y = y;</div><div class="line">&#125;;</div><div class="line">Shape.prototype = &#123;</div><div class="line">    getX: function ()  &#123; return this._x; &#125;,</div><div class="line">    setX: function (v) &#123; this._x = v; &#125;,</div><div class="line">    getY: function ()  &#123; return this._y; &#125;,</div><div class="line">    setY: function (v) &#123; this._y = v; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var _Combined = aggregation(Shape, [ Colored, ZCoord ]);</div><div class="line">var Rectangle = function (x, y) &#123;</div><div class="line">    _Combined.call(this, x, y);</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = Object.create(_Combined.prototype);</div><div class="line">Rectangle.prototype.constructor = Rectangle;</div><div class="line"></div><div class="line">var rect = new Rectangle(7, 42);</div><div class="line">rect.setZ(1000);</div><div class="line">rect.setColor(&quot;red&quot;);</div><div class="line">console.log(rect.getX(), rect.getY(),rect.getZ(), rect.getColor());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>members</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Rectangle extends Shape &#123;</div><div class="line">    …</div><div class="line">    static defaultRectangle () &#123;</div><div class="line">        return new Rectangle(&quot;default&quot;, 0, 0, 100, 100)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Circle extends Shape &#123;</div><div class="line">    …</div><div class="line">    static defaultCircle () &#123;</div><div class="line">        return new Circle(&quot;default&quot;, 0, 0, 100)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var defRectangle = Rectangle.defaultRectangle()</div><div class="line">var defCircle    = Circle.defaultCircle()</div><div class="line">//ES5</div><div class="line">var Rectangle = function (id, x, y, width, height) &#123;</div><div class="line">    …</div><div class="line">&#125;;</div><div class="line">Rectangle.defaultRectangle = function () &#123;</div><div class="line">    return new Rectangle(&quot;default&quot;, 0, 0, 100, 100);</div><div class="line">&#125;;</div><div class="line">var Circle = function (id, x, y, width, height) &#123;</div><div class="line">    …</div><div class="line">&#125;;</div><div class="line">Circle.defaultCircle = function () &#123;</div><div class="line">    return new Circle(&quot;default&quot;, 0, 0, 100);</div><div class="line">&#125;;</div><div class="line">var defRectangle = Rectangle.defaultRectangle();</div><div class="line">var defCircle    = Circle.defaultCircle();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor (width, height) &#123;</div><div class="line">        this._width  = width</div><div class="line">        this._height = height</div><div class="line">    &#125;</div><div class="line">    set width  (width)  &#123; this._width = width               &#125;</div><div class="line">    get width  ()       &#123; return this._width                &#125;</div><div class="line">    set height (height) &#123; this._height = height             &#125;</div><div class="line">    get height ()       &#123; return this._height               &#125;</div><div class="line">    get area   ()       &#123; return this._width * this._height &#125;</div><div class="line">&#125;</div><div class="line">var r = new Rectangle(50, 20)</div><div class="line">r.area === 1000</div><div class="line">//ES5</div><div class="line">var Rectangle = function (width, height) &#123;</div><div class="line">    this._width  = width;</div><div class="line">    this._height = height;</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = &#123;</div><div class="line">    set width  (width)  &#123; this._width = width;               &#125;,</div><div class="line">    get width  ()       &#123; return this._width;                &#125;,</div><div class="line">    set height (height) &#123; this._height = height;             &#125;,</div><div class="line">    get height ()       &#123; return this._height;               &#125;,</div><div class="line">    get area   ()       &#123; return this._width * this._height; &#125;</div><div class="line">&#125;;</div><div class="line">var r = new Rectangle(50, 20);</div><div class="line">r.area === 1000;</div></pre></td></tr></table></figure>
<ul>
<li>constructor方法</li>
</ul>
<blockquote>
<p>类的默认方法，通过new关键字生成对象实例时自动调用。一个类必须有constructor方法，如未定义默认添加。<br>默认返回实例对象(this)，完全可以指定另外一个对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    return Object.create(null);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">new Foo() instanceof Foo</div><div class="line">// false,类的构造函数不使用new是无法调用的，这点与普通构造函数的主要区别</div></pre></td></tr></table></figure>
<ul>
<li>类的实例对象</li>
</ul>
<blockquote>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//定义类</div><div class="line">class Point &#123;</div><div class="line"></div><div class="line">  constructor(x, y) &#123;</div><div class="line">    this.x = x;</div><div class="line">    this.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var point = new Point(2, 3);</div><div class="line">point.toString() // (2, 3)</div><div class="line">point.hasOwnProperty(&apos;x&apos;) // true</div><div class="line">point.hasOwnProperty(&apos;y&apos;) // true</div><div class="line">point.hasOwnProperty(&apos;toString&apos;) // false</div><div class="line">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</div><div class="line">//类的所有实例共享同一个原型对象，同ES5一样</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>不存在变量提升</li>
<li>Class表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const MyClass = class Me &#123;</div><div class="line">  getClassName() &#123;</div><div class="line">    return Me.name;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">//类名为MyClass而非Me,Me只在Class内部代码可用，指代当前类，如果内部没用到可以省略</div><div class="line">//使用class关键字可以写出立即执行的Class</div><div class="line">let person = new class &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sayName() &#123;</div><div class="line">    console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;(&apos;张三&apos;);</div><div class="line"></div><div class="line">person.sayName(); // &quot;张三&quot;</div></pre></td></tr></table></figure>
<ul>
<li>私有方法</li>
</ul>
<blockquote>
<p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
</blockquote>
<ul>
<li>this指向</li>
</ul>
<blockquote>
<p>类的方法内部如含有this，默认指向类的实例。但必须小心，一旦单独使用可能报错。<br>类和模块内部默认全是严格模式，name属性总是返回紧跟在class关键字后边的类名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Logger &#123;</div><div class="line">  printName(name = &apos;there&apos;) &#123;</div><div class="line">    this.print(`Hello $&#123;name&#125;`);</div><div class="line">  &#125;</div><div class="line">  print(text) &#123;</div><div class="line">    console.log(text);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const logger = new Logger();</div><div class="line">const &#123; printName &#125; = logger;</div><div class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefine</div><div class="line">/*printName默认指向Logger实例。若将该方法提出使用，this会指向该方法运行时环境*/</div><div class="line">class Logger &#123;</div><div class="line">//构造方法中绑定this</div><div class="line">  constructor() &#123;</div><div class="line">    this.printName = this.printName.bind(this);</div><div class="line">  &#125;</div><div class="line">//箭头函数</div><div class="line">constructor() &#123;</div><div class="line">    this.printName = (name = &apos;there&apos;) =&gt; &#123;</div><div class="line">      this.print(`Hello $&#123;name&#125;`);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//使用Proxy，获取方法的时候，自动绑定this</div><div class="line">function selfish (target) &#123;</div><div class="line">  const cache = new WeakMap();</div><div class="line">  const handler = &#123;</div><div class="line">    get (target, key) &#123;</div><div class="line">      const value = Reflect.get(target, key);</div><div class="line">      if (typeof value !== &apos;function&apos;) &#123;</div><div class="line">        return value;</div><div class="line">      &#125;</div><div class="line">      if (!cache.has(value)) &#123;</div><div class="line">        cache.set(value, value.bind(target));</div><div class="line">      &#125;</div><div class="line">      return cache.get(value);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  const proxy = new Proxy(target, handler);</div><div class="line">  return proxy;</div><div class="line">&#125;</div><div class="line">const logger = selfish(new Logger());</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>class继承</li>
</ol>
<blockquote>
<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class ColorPoint extends Point&#123;</div><div class="line"> constructor(x, y, color) &#123;</div><div class="line">    super(x, y); // 调用父类的constructor(x, y)</div><div class="line">    this.color = color;</div><div class="line">  &#125;</div><div class="line">  toString() &#123;</div><div class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>上述实例中constructor和toString方法都出现了super，表示父类的构造函数，用来新建父类this对象。<br>子类必须在constructor方法中调用super方法，否则新建实例报错。只因子类无自身this对象，只有继承父类的然后<br>加工。如不调用super方法子类就得不到this对象。</p>
<blockquote>
<p>ES5的继承实例先造子类实例对象this，然后将父类的方法添加到this上。ES6则完全不同，先造父类实例对象this，然后<br>再用子类构造函数修改this。</p>
</blockquote>
<p>类的prototype属性和<strong>proto</strong>属性</p>
<blockquote>
<p>多数浏览器ES5实现之中，每个对象都有一个指向构造函数的<strong>proto</strong>属性。Class作为构造函数的语法糖，同时拥有prototype和<br><strong>proto</strong>属性，故同时存在两条继承链。作为一个对象，子类B的原型（<strong>proto</strong>属性）是父类；作为构造函数，子类B的原型(prototype<br>属性)是父类的实例。</p>
<ul>
<li>子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类；</li>
<li>子类prototype属性的<strong>proto</strong>属性，表示方法的继承，指向父类的prototype属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">&#125;</div><div class="line">class B extends A &#123;</div><div class="line">&#125;</div><div class="line">B.__proto__ === A // true</div><div class="line">B.prototype.__proto__ === A.prototype // true</div><div class="line">//原理</div><div class="line">// B的实例继承A的实例</div><div class="line">Object.setPrototypeOf(B.prototype, A.prototype);</div><div class="line">const b = new B();</div><div class="line">// B的实例继承A的静态属性</div><div class="line">Object.setPrototypeOf(B, A);</div><div class="line"></div><div class="line">Object.setPropertypeOf=function (obj,proto)&#123;</div><div class="line">    obj.__proto__=proto;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>Extends 的继承目标</li>
</ul>
<p>extends关键字后边可以继承多种类型的值，只要被继承者有prototype属性</p>
<ol>
<li>子类继承Object类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A extends Object&#123;&#125;</div><div class="line">A.__proto__===Objecdt;//true</div><div class="line">A.prototype.__proto__=Object.prototype;//true</div><div class="line">//A即构造函数Object的复制，A的实例即Object的实例</div></pre></td></tr></table></figure>
<ol>
<li>不存在任何继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">A.__proto__===Function.prototype;//true</div><div class="line">A.prototype.__proto__===Object.prototype;//true</div><div class="line">//A作为一个基类(不存在任何继承)，即普通函数故直接继承Function.prototype。</div><div class="line">但当A调用后返回一个空对象(Object实例)，故A.prototype.__proto__指向构造函数(Object)的prototype属性。</div></pre></td></tr></table></figure>
<ol>
<li>子类集成null</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A extends null&#123;&#125;</div><div class="line">A.__proto__===Function.prototype;//true</div><div class="line">A.prototype.__proto__===undefined;//true</div><div class="line">//实际上是</div><div class="line">class C extends null &#123;</div><div class="line">  constructor() &#123; return Object.create(null); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>Object.getPropertyOf():从子类获取父类</p>
</li>
<li><p>super关键字</p>
</li>
</ul>
<blockquote>
<p>既可以当函数使用也可以当对象使用，但用法完全不同。</p>
</blockquote>
<ol>
<li>作为函数，代表父类的构造函数,只能用在子类的构造函数中。(ES6规定子类构造函数必须执行一次super函数)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">class B extends A&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/*super虽然代表了父类A的构造函数，但返回的是子类的实例(super内this指向B)，</div><div class="line">此时super()相当于A.prototype.constructor.call(this).*/</div></pre></td></tr></table></figure>
<ol>
<li><p>作为对象，指向父类的原型对象。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    p()&#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class B extends A&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        super();</div><div class="line">        console.log(super.p());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let b=new B();//2</div><div class="line">//ES6 规定，通过super调用父类的方法时，super会绑定子类的this。因此super就是this</div><div class="line">class A &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    this.x = 1;</div><div class="line">  &#125;</div><div class="line">&#125;   </div><div class="line">class B extends A &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super();</div><div class="line">    this.x = 2;</div><div class="line">    super.x = 3;</div><div class="line">    console.log(super.x); // undefined,A.prototype.x</div><div class="line">    console.log(this.x); // 3</div><div class="line">  &#125;</div><div class="line">&#125;  </div><div class="line">let b = new B();</div><div class="line">/*使用super的时候，必须显式指定是作为函数、还是作为对象;由于对象都是继承其它对象的，</div><div class="line">所以可以在任意对象中使用super关键字*/</div><div class="line">var obj = &#123;</div><div class="line">  toString() &#123;</div><div class="line">    return &quot;MyObject: &quot; + super.toString();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.toString(); // MyObject: [object Object]</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>实例的<strong>proto</strong>属性</li>
</ul>
<blockquote>
<p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>prototype</strong>属性。<br>即子类原型的原型是父类的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var p1 = new Point(2, 3);</div><div class="line">var p2 = new ColorPoint(2, 3, &apos;red&apos;);</div><div class="line">p2.__proto__ === p1.__proto__ // false</div><div class="line">p2.__proto__.__proto__ === p1.__proto__ // true,ColorPoint继承了Point</div><div class="line">//通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为</div><div class="line">p2.__proto__.__proto__.printName = function () &#123;</div><div class="line">  console.log(&apos;Ha&apos;);</div><div class="line">&#125;;</div><div class="line">p1.printName() // &quot;Ha&quot;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>原生构造函数的继承—无法继承</li>
</ol>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<ol>
<li><p>Class的取值函数getter和存值函数setter<br>存值函数和取值函数是设置在属性的descriptor对象上的,与ES5完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">lass MyClass &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">  get prop() &#123;</div><div class="line">    return &apos;getter&apos;;</div><div class="line">  &#125;</div><div class="line">  set prop(value) &#123;</div><div class="line">    console.log(&apos;setter: &apos;+value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let inst = new MyClass();</div><div class="line">inst.prop = 123;</div><div class="line">// setter: 123</div><div class="line">inst.prop</div><div class="line">// &apos;getter&apos;</div><div class="line">//prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</div></pre></td></tr></table></figure>
</li>
<li><p>Class的Generator方法</p>
</li>
</ol>
<blockquote>
<p>某个方法之前加上*即为Generator函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  constructor(...args) &#123;</div><div class="line">    this.args = args;</div><div class="line">  &#125;</div><div class="line">  * [Symbol.iterator]() &#123;</div><div class="line">    for (let arg of this.args) &#123;</div><div class="line">      yield arg;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Class的静态方法</li>
</ol>
<blockquote>
<p>类相当于实例的原型，故类中定义的方法都会被实例继承。若在一个方法上加上static关键字<br>则表示该方法不会被实例继承，而是直接通过类来调用，但可以被子类继承，也可以通过super对象调用所谓的‘静态方法’。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    static classMethod()&#123;</div><div class="line">        return &apos;hello&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Foo.classMethod();//&apos;hello&apos;</div><div class="line">var foo=new Foo();</div><div class="line">foo.classMethod();// TypeError: foo.classMethod is not a function</div><div class="line"> class Bar extends Foo &#123;</div><div class="line">   static classMethod() &#123;</div><div class="line">     return super.classMethod() + &apos;, too&apos;;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Class的静态属性和实例属性</li>
</ol>
<blockquote>
<p>静态属性指Class本身的属性Class.propname,而非定义在实例对象this上的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    prop:2//无效</div><div class="line">    static prop:2//无效</div><div class="line">&#125;</div><div class="line">Foo.prop=1;</div><div class="line">Foo.prop;//1,只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</div></pre></td></tr></table></figure></p>
</blockquote>
<p>ES7提议，Babel支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//类的实例属性可以用等式，写入类的定义之中。</div><div class="line">class MyClass &#123;</div><div class="line">  myProp = 42;</div><div class="line">  constructor() &#123;</div><div class="line">    console.log(this.myProp); // 42</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">/*定义实例属性，之前只能写在类的constructor方法里面，如今可以不在。</div><div class="line">为了可读性的目的，对于那些在constructor里面已经定义的实例属性，</div><div class="line">新写法允许直接列出。*/</div><div class="line">class ReactCounter extends React.Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">//类的静态属性，只需在实例属性前加上static关键字</div><div class="line">class MyClass &#123;</div><div class="line">  static myStaticProp = 42;</div><div class="line">  constructor() &#123;</div><div class="line">    console.log(MyClass.myStaticProp); // 42</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>类的私有属性—提案，为class加了私有属性。方法是在属性名之前，使用#表示。</li>
</ol>
<blockquote>
<p>之所以引入一个新的#表示私有属性而非private关键字是因为JS是一门动态语言，使用独立符号似乎是唯一<br>可靠方法，能够准确地区分属性之公私。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  #x;</div><div class="line">  constructor(x = 0) &#123;</div><div class="line">    #x = +x;</div><div class="line">  &#125;</div><div class="line">  get x() &#123; return #x &#125;</div><div class="line">  set x(value) &#123; #x = +value &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>new.target属性—确定构造函数如何调用的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">  if (new.target !== undefined) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new Error(&apos;必须使用new生成实例&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 另一种写法</div><div class="line">function Person(name) &#123;</div><div class="line">  if (new.target === Person) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new Error(&apos;必须使用new生成实例&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var person = new Person(&apos;张三&apos;); // 正确</div><div class="line">var notAPerson = Person.call(person, &apos;张三&apos;);  // 报错</div><div class="line">//Class内调用new.target返回当前Class</div></pre></td></tr></table></figure>
<ol>
<li>Mixin模式的实现<blockquote>
<p>将多个类的接口混入(mix in)另一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function mix(...mixins) &#123;</div><div class="line">  class Mix &#123;&#125;</div><div class="line"></div><div class="line">  for (let mixin of mixins) &#123;</div><div class="line">    copyProperties(Mix, mixin);</div><div class="line">    copyProperties(Mix.prototype, mixin.prototype);</div><div class="line">  &#125;</div><div class="line">  return Mix;</div><div class="line">&#125;</div><div class="line">function copyProperties(target, source) &#123;</div><div class="line">  for (let key of Reflect.ownKeys(source)) &#123;</div><div class="line">    if ( key !== &quot;constructor&quot;</div><div class="line">      &amp;&amp; key !== &quot;prototype&quot;</div><div class="line">      &amp;&amp; key !== &quot;name&quot;</div><div class="line">    ) &#123;</div><div class="line">      let desc = Object.getOwnPropertyDescriptor(source, key);</div><div class="line">      Object.defineProperty(target, key, desc);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>More info: <a href="https://developer.mozilla.org/en/docs/Web//Reference/Classes" target="_blank" rel="external">MDN Classes</a></p>
<h3 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h3><blockquote>
<p>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。</p>
</blockquote>
<ol>
<li>类的修饰</li>
<li>方法的修饰</li>
<li>不能用于函数</li>
<li>core-decorators.js</li>
<li>使用修饰器实现自动发布事件</li>
<li>mixin混入</li>
<li>trait</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function factorial(n, acc = 1) &#123;</div><div class="line">    &apos;use strict&apos;;</div><div class="line">    if (n &lt;= 1) return acc;</div><div class="line">    return factorial(n - 1, n * acc);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Stack overflow in most implementations today,</div><div class="line">// but safe on arbitrary inputs in ES6</div><div class="line">factorial(100000)</div></pre></td></tr></table></figure>
<h3 id="Modules模块"><a href="#Modules模块" class="headerlink" title="Modules模块"></a>Modules模块</h3><blockquote>
<p>Language-level support for modules for component definition.<br>Codifies patterns from popular  module loaders (AMD, CommonJS).<br>Runtime behaviour defined by a host-defined default loader.<br>Implicitly async model – no code executes until requested modules are available and processed.<br>组件定义的模块的语言级支持。编译流行模块加载程序（AMD，COMMONJS）的模式。<br>由主机定义的默认加载器定义的运行时行为。隐式异步模型 - 在请求的模块可用并处理之前，不执行代码。<br>ES6在语言标准层面上实现了模块功能，完全可以取代CommonJS，AMD规范，成为B/S通用的模块解决方案。<br>模块化设计思想是尽量静态化，使得编译时就能确定模块的依赖关系以及输入和输出的变量。</p>
</blockquote>
<p>好处：</p>
<pre><code>1. 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式；
2. 将来浏览器的新API就能用模块格式提供，不必做成全局变量或者navigator对象的属性；
3. 不再需要对象作为命名空间(如Math)，未来这些功能可以通过模块提供。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// lib/math.js</div><div class="line">export function sum(x, y) &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line">export var pi = 3.141593;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">import * as math from &quot;lib/math&quot;;</div><div class="line">alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// otherApp.js</div><div class="line">import &#123;sum, pi&#125; from &quot;lib/math&quot;;</div><div class="line">alert(&quot;2π = &quot; + sum(pi, pi));</div></pre></td></tr></table></figure>
<p>Some additional features include <code>export default</code> and <code>export *</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// lib/mathplusplus.js</div><div class="line">export * from &quot;lib/math&quot;;</div><div class="line">export var e = 2.71828182846;</div><div class="line">export default function(x) &#123;</div><div class="line">    return Math.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">import ln, &#123;pi, e&#125; from &quot;lib/mathplusplus&quot;;</div><div class="line">alert(&quot;2π = &quot; + ln(e)*pi*2);</div></pre></td></tr></table></figure>
<ol>
<li>严格模式—自动设定为’use strict’</li>
<li>export,export default及import命令</li>
<li>模块的整体加载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import * as circle from &apos;./circle&apos;;</div><div class="line">console.log(&apos;圆面积：&apos; + circle.area(4));</div><div class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</div><div class="line">//注意：整体加载的模块所在的那个对象是可以静态分析的，不允许运行时改变</div><div class="line">circle.foo = &apos;hello&apos;;//不允许</div></pre></td></tr></table></figure>
<ol>
<li>模块的继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// circleplus.js</div><div class="line"></div><div class="line">export * from &apos;circle&apos;;</div><div class="line">export var e = 2.71828182846;</div><div class="line">export default function(x) &#123;</div><div class="line">  return Math.exp(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>import():按需加载，条件加载，动态模块路径</li>
</ol>
<p>More MDN info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/import" target="_blank" rel="external">import statement</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/export" target="_blank" rel="external">export statement</a></p>
<h3 id="Module-Loaders"><a href="#Module-Loaders" class="headerlink" title="Module Loaders"></a>Module Loaders</h3><ol>
<li>浏览器加载</li>
</ol>
<ul>
<li>传统方法：script引入</li>
</ul>
<blockquote>
<p>默认情况下，B是同步加载JS脚本，即渲染引擎遇到script就停下来直到脚本执行完，再继续向下循环。<br>如果是外部脚本，还必须加入脚本下载时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//defer:整个页面渲染结束才执行，渲染完再执行；async:一旦下载完，渲染引擎就会中断渲染，执行此脚本后再继续渲染，下载完就执行。</div><div class="line">&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>加载规则：ES6模块也可以使用script标签，但要加入type=’module’属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;</div><div class="line"> import utils from &quot;./utils.js&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!-- 等同于 --&gt;</div><div class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于外部模块脚本，注意以下几点：</p>
<pre><code>1. 代码在模块作用域之中运行而非全局，模块内顶层变量外部不可见
2. 模块脚本自动采用严格模式，无论声明与否；
3. 模块中可以使用import及export命令处理模块
4. 模块中，顶层的this关键字返回undefined而非window
5. 同一个模块如果加载多次，只执行一次
</code></pre><figure class="highlight plain"><figcaption><span>isNotModuleScript = this !== undefined;//侦测是否在ES6模块中```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. ES6模块与CommonJS模块差异</div><div class="line"></div><div class="line">两大重大差异：</div><div class="line"></div><div class="line">- 前者输出的是值的引用，后者是拷贝</div><div class="line">- 前者是编译时输出接口，后者是运行时加载</div><div class="line"></div><div class="line">&gt; CommonJS加载的是一个在脚本运行才会生成的对象，而ES6不是对象，其对外接口只是一种静态定义，</div><div class="line">在代码静态解析阶段就会生成。ES6的import有点像Unix系统的符号连接，原始值变了，import加载的值也变。</div><div class="line">故ES6模块是动态引用，不会缓存值，模块里的变量绑定其所在的模块。</div><div class="line"></div><div class="line">3. Node加载</div><div class="line"></div><div class="line">&gt;Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。</div><div class="line">目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。</div><div class="line"></div><div class="line">在静态分析阶段，一个模块脚本若含import或export语句，Node便认为其为ES6模块，否则就是CommonJS模块。</div><div class="line">若不输出任何接口但希望被认为是ES6模块，可在脚本中加入```export &#123;&#125;;//不输出任何脚本的ES6标准写法</div></pre></td></tr></table></figure>
<p>ES6模块中顶层的this指向undefined；而CommonJS模块的顶层this指向当前模块。</p>
<ul>
<li>import 命令加载CommonJS模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// a.js  CommonJS模块</div><div class="line">module.exports = &#123;</div><div class="line">  foo: &apos;hello&apos;,</div><div class="line">  bar: &apos;world&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 等同于</div><div class="line">export default &#123;</div><div class="line">  foo: &apos;hello&apos;,</div><div class="line">  bar: &apos;world&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>require命令加载ES6模块<blockquote>
<p>采用require命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。</p>
</blockquote>
</li>
</ul>
<ol>
<li>循环加载circular dependency</li>
</ol>
<ul>
<li>CommonJS模块加载原理<h3 id="Subclassable-Built-ins内嵌对象的亚类"><a href="#Subclassable-Built-ins内嵌对象的亚类" class="headerlink" title="Subclassable Built-ins内嵌对象的亚类"></a>Subclassable Built-ins内嵌对象的亚类</h3><blockquote>
<p>In ES6, built-ins like <code>Array</code>, <code>Date</code> and DOM <code>Element</code>s can be subclassed.<br>Object construction for a function named <code>Ctor</code> now uses two-phases (both virtually dispatched):</p>
</blockquote>
</li>
<li>Call <code>Ctor[@@create]</code> to allocate the object, installing any special behavior</li>
<li>Invoke constructor on new instance to initialize<br>The known <code>@@create</code> symbol is available via <code>Symbol.create</code>.  Built-ins now expose their <code>@@create</code> explicitly.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Pseudo-code of Array</div><div class="line">class Array &#123;</div><div class="line">    constructor(...args) &#123; /* ... */ &#125;</div><div class="line">    static [Symbol.create]() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// User code of Array subclass</div><div class="line">class MyArray extends Array &#123;</div><div class="line">    constructor(...args) &#123; super(...args); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Two-phase &apos;new&apos;:</div><div class="line">// 1) Call @@create to allocate object</div><div class="line">// 2) Invoke constructor on new instance</div><div class="line">var arr = new MyArray();</div><div class="line">arr[1] = 12;</div><div class="line">arr.length == 2</div></pre></td></tr></table></figure>
<h3 id="typed-arrays"><a href="#typed-arrays" class="headerlink" title="typed arrays"></a>typed arrays</h3><blockquote>
<p>支持任意基于字节的数据结构来实现网络协议，加密算法，文件格式操作等。<br><figure class="highlight plain"><figcaption><span>Example &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    constructor (buffer = new ArrayBuffer(24)) &#123;</div><div class="line">        this.buffer = buffer</div><div class="line">    &#125;</div><div class="line">    set buffer (buffer) &#123;</div><div class="line">        this._buffer    = buffer</div><div class="line">        this._id        = new Uint32Array (this._buffer,  0,  1)</div><div class="line">        this._username  = new Uint8Array  (this._buffer,  4, 16)</div><div class="line">        this._amountDue = new Float32Array(this._buffer, 20,  1)</div><div class="line">    &#125;</div><div class="line">    get buffer ()     &#123; return this._buffer       &#125;</div><div class="line">    set id (v)        &#123; this._id[0] = v           &#125;</div><div class="line">    get id ()         &#123; return this._id[0]        &#125;</div><div class="line">    set username (v)  &#123; this._username[0] = v     &#125;</div><div class="line">    get username ()   &#123; return this._username[0]  &#125;</div><div class="line">    set amountDue (v) &#123; this._amountDue[0] = v    &#125;</div><div class="line">    get amountDue ()  &#123; return this._amountDue[0] &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let example = new Example()</div><div class="line">example.id = 7</div><div class="line">example.username = &quot;John Doe&quot;</div><div class="line">example.amountDue = 42.0</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="internationalization-localization"><a href="#internationalization-localization" class="headerlink" title="internationalization-localization"></a>internationalization-localization</h3><blockquote>
<p>collation整理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var list = [ &quot;ä&quot;, &quot;a&quot;, &quot;z&quot; ]</div><div class="line">var l10nDE = new Intl.Collator(&quot;de&quot;)</div><div class="line">var l10nSV = new Intl.Collator(&quot;sv&quot;)</div><div class="line">l10nDE.compare(&quot;ä&quot;, &quot;z&quot;) === -1</div><div class="line">l10nSV.compare(&quot;ä&quot;, &quot;z&quot;) === +1</div><div class="line">console.log(list.sort(l10nDE.compare)) // [ &quot;a&quot;, &quot;ä&quot;, &quot;z&quot; ]</div><div class="line">console.log(list.sort(l10nSV.compare)) // [ &quot;a&quot;, &quot;z&quot;, &quot;ä&quot; ]</div></pre></td></tr></table></figure>
<blockquote>
<p>number formatting</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var l10nEN = new Intl.NumberFormat(&quot;en-US&quot;)</div><div class="line">var l10nDE = new Intl.NumberFormat(&quot;de-DE&quot;)</div><div class="line">l10nEN.format(1234567.89) === &quot;1,234,567.89&quot;</div><div class="line">l10nDE.format(1234567.89) === &quot;1.234.567,89&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>current formatting</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var l10nUSD = new Intl.NumberFormat(&quot;en-US&quot;, &#123; style: &quot;currency&quot;, currency: &quot;USD&quot; &#125;)</div><div class="line">var l10nGBP = new Intl.NumberFormat(&quot;en-GB&quot;, &#123; style: &quot;currency&quot;, currency: &quot;GBP&quot; &#125;)</div><div class="line">var l10nEUR = new Intl.NumberFormat(&quot;de-DE&quot;, &#123; style: &quot;currency&quot;, currency: &quot;EUR&quot; &#125;)</div><div class="line">l10nUSD.format(100200300.40) === &quot;$100,200,300.40&quot;</div><div class="line">l10nGBP.format(100200300.40) === &quot;£100,200,300.40&quot;</div><div class="line">l10nEUR.format(100200300.40) === &quot;100.200.300,40 €&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>date/time formating</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var l10nEN = new Intl.DateTimeFormat(&quot;en-US&quot;)</div><div class="line">var l10nDE = new Intl.DateTimeFormat(&quot;de-DE&quot;)</div><div class="line">l10nEN.format(new Date(&quot;2015-01-02&quot;)) === &quot;1/2/2015&quot;</div><div class="line">l10nDE.format(new Date(&quot;2015-01-02&quot;)) === &quot;2.1.2015&quot;</div></pre></td></tr></table></figure>
<h3 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h3><blockquote>
<p>SIMD（发音/sim-dee/）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。<br>它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。<br>与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>
</blockquote>
<h3 id="Good-Practise"><a href="#Good-Practise" class="headerlink" title="Good Practise"></a>Good Practise</h3><ol>
<li><p>块级作用域</p>
<ol>
<li>let取代var</li>
<li>全局常量和线程安全<br>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量</li>
</ol>
</li>
<li>字符串：``</li>
<li>解耦赋值：首选</li>
<li>对象：单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</li>
<li>数组：使用扩展运算符配合Array.from方法</li>
<li>函数：</li>
<li>Map结构：区分Object和Map，只有模拟现实世界的实体对象采用Object。若是键值对结构首选Map</li>
<li>Class :首选</li>
<li>模块：import取代require</li>
<li>EsLint使用</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="#参考链接"></a>#参考链接</h3><p><a href="https://github.com/lukehoban/es6features#readme" target="_blank" rel="external">https://github.com/lukehoban/es6features#readme</a><br><a href="http://es6-features.org/#Constants" target="_blank" rel="external">http://es6-features.org/#Constants</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/yanlee26" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 Yan Li<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>