<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="这世间，唯有梦想与好姑娘不可辜负！">
    

    <!--Author-->
    
        <meta name="author" content="Yan Li">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="ES6/ES7总结分析"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="这世间，唯有梦想与好姑娘不可辜负！" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Frank_lyan&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>ES6/ES7总结分析 - Frank_lyan&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Resharpe Your Saw</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/yanlee26">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>ES6/ES7总结分析</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2016-10-04
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Hexo/">#Hexo</a> <a href="/tags/clean-blog/">#clean_blog</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/JS/">JS</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>ECMAScript 6, also known as ECMAScript 2015, is the latest version of the ECMAScript<br> standard.  ES6 is a significant update to the language, and the first update to<br> the language since ES5 was standardized in 2009. Implementation of these features<br> in major  engines is <a href="http://kangax.github.io/es5-compat-table/es6/" target="_blank" rel="external">underway now(支持情况一览)</a>.</p>
</blockquote>
<p>See the <a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="external">ES6 standard（ES6规范）</a> for full specification of the ECMAScript 6 language.</p>
<h3 id="ES6-includes-the-following-new-features—新特性如下"><a href="#ES6-includes-the-following-new-features—新特性如下" class="headerlink" title="ES6 includes the following new features—新特性如下:"></a>ES6 includes the following new features—新特性如下:</h3><ol>
<li>let + const</li>
<li>arrows箭头函数</li>
<li>destructuring解耦</li>
<li>enhanced string literals字符串的扩展</li>
<li>enhanced regular expression正则的扩展</li>
<li>enhanced number expression数值的扩展</li>
<li>enhanced array expression数组的扩展</li>
<li>enhanced function expression函数的扩展</li>
<li>enhanced object literals对象的扩展</li>
<li>symbols标记</li>
<li>map + set</li>
<li>proxies代理</li>
<li>reflect</li>
<li>promises</li>
<li>iterators迭代器 + for..of</li>
<li>generators</li>
<li>async函数</li>
<li>class</li>
<li>decorator</li>
<li>modules</li>
<li><p>module loaders</p>
</li>
<li><p>subclassable built-ins</p>
</li>
<li>typed arrays</li>
<li>internationalization-localization国际及地域化</li>
<li>SIMD</li>
<li>Good Practise</li>
</ol>
<h2 id="ECMAScript-6-Features"><a href="#ECMAScript-6-Features" class="headerlink" title="ECMAScript 6 Features"></a>ECMAScript 6 Features</h2><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><blockquote>
<p>Block-scoped binding constructs.  <figure class="highlight plain"><figcaption><span>is the new ```var```(块级作用域绑定结构，let是新的var). </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```const```is single-assignment.  Static restrictions prevent use before assignment</div><div class="line">（const 是单一声明，严格模式限制其必须先声明再使用）.</div></pre></td></tr></table></figure></p>
</blockquote>
<p>//ES6<br>const PI=3.1415926;<br>let callbacks = []<br>for (let i = 0; i &lt;= 2; i++) {<br>    callbacks[i] = function () { return i <em> 2 }<br>}<br>callbacks<a href="">0</a> === 0;<br>//block-scoped functions<br>{<br>    function foo () { return 1 }<br>    foo() === 1<br>    {<br>        function foo () { return 2 }<br>        foo() === 2<br>    }<br>    foo() === 1<br>}<br>//ES5<br>Object.defineProperty(typeof global === “object” ? global : window, “PI”, {<br>    value:        3.1415926,<br>    enumerable:   true,<br>    writable:     false,<br>    configurable: false<br>})<br>var callbacks = [];<br>for (var i = 0; i &lt;= 2; i++) {<br>    (function (i) {<br>        callbacks[i] = function() { return i </em> 2; };<br>    })(i);<br>}<br>callbacks<a href="">0</a> === 0;<br>(function () {<br>    var foo = function () { return 1; }<br>    foo() === 1;<br>    (function () {<br>        var foo = function () { return 2; }<br>        foo() === 2;<br>    })();<br>    foo() === 1;<br>})();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">More MDN info: [let statement](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/let), [const statement](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/const)</div><div class="line"></div><div class="line">###  Destructuring解耦</div><div class="line"></div><div class="line">&gt;Destructuring allows binding using pattern matching, with support for matching arrays and objects(解耦允许绑定模式匹配</div><div class="line">，支持数组和对象).</div></pre></td></tr></table></figure></p>
<p>// list matching列表匹配<br>var [a, , b] = [1,2,3];</p>
<p>// object matching对象匹配<br>var { op: a, lhs: { op: b }, rhs: c }<br>       = getASTNode()<br>var {op, lhs, rhs} = getASTNode()<br>// Can be used in parameter position用于形参位置<br>function g({name: x}) {<br>  console.log(x);<br>}<br>g({name: 5})<br>// Fail-soft destructuring<br>var [a] = [];<br>a === undefined;</p>
<p>// Fail-soft destructuring with defaults<br>var [a = 1] = [];<br>a === 1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">More info: [MDN Destructuring assignment](https://developer.mozilla.org/en-US/docs/Web//Reference/Operators/Destructuring_assignment)</div><div class="line"></div><div class="line">###  enhanced string literals字符串的扩展</div><div class="line"></div><div class="line">1. Unicode编码</div><div class="line"></div><div class="line">&gt;Non-breaking additions to support full Unicode, including new Unicode literal form in strings and </div><div class="line">new RegExp `u` mode to handle code points, as well as new APIs to process strings at the 21bit code points level.  </div><div class="line">These additions support building global apps in JS.</div></pre></td></tr></table></figure></p>
<p>“𠮷”.length === 2<br>“𠮷”.match(/./u)[0].length === 2<br>“𠮷” === “\uD842\uDFB7”<br>“𠮷” === “\u{20BB7}”<br>“𠮷”.codePointAt(0) == 0x20BB7<br>for (let codepoint of “𠮷”) console.log(codepoint)<br>//ES5<br>“𠮷”.length === 2;<br>“𠮷”.match(/(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF][\uD800-\uDBFF][\uDC00-\uDFFF]<a href="?![\uDC00-\uDFFF]">\uD800-\uDBFF</a>(?:[^\uD800-\uDBFF]^)[\uDC00-\uDFFF])/)[0].length === 2;<br>“𠮷” === “\uD842\uDFB7”;<br>//  no equivalent in ES5<br>//  no equivalent in ES5<br>//  no equivalent in ES5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">More info: [MDN RegExp.prototype.unicode](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/RegExp/unicode)</div><div class="line"></div><div class="line">2. Template Strings</div><div class="line"></div><div class="line">&gt;Template strings provide syntactic sugar for constructing strings.  </div><div class="line">This is similar to string interpolation features in Perl, Python and more. </div><div class="line">模板字符串为适应的字符串提供了语法糖。这类似于Perl，Python等中的字符串插值功能.</div></pre></td></tr></table></figure>
<p>// Basic literal string creation<br><code>In  &#39;\n&#39; is a line-feed.</code></p>
<p>// Multiline strings<br><code>In  this is
 not legal.</code></p>
<p>// String interpolation字符串插值<br>var name = “Bob”, time = “today”;<br><code>Hello ${name}, how are you ${time}?</code></p>
<p>// Construct an HTTP request prefix is used to interpret the replacements and construction<br>get<code>http://example.com/foo?bar=${bar + baz}&amp;quux=${quux}</code><br>//ES5<br>get([ “<a href="http://example.com/foo?bar=" target="_blank" rel="external">http://example.com/foo?bar=</a>“, “&amp;quux=”, “” ],bar + baz, quux);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. codePointAt()</div></pre></td></tr></table></figure>
<p>var s = ‘𠮷a’;<br>s.codePointAt(0) // 134071<br>s.codePointAt(1) // 57271<br>s.codePointAt(2) // 97<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. string.fromCodePoint() 从码点返回对应字符</div></pre></td></tr></table></figure></p>
<p>String.fromCodePoint(0x20BB7)<br>// “𠮷”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. 遍历</div></pre></td></tr></table></figure></p>
<p>for (let codePoint of ‘foo’) {<br>  console.log(codePoint)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. at() 返回字符串给定位置的字符</div></pre></td></tr></table></figure></p>
<p>‘abc’.at(0) // “a”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">7. normalize()</div><div class="line"></div><div class="line">&gt; ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</div></pre></td></tr></table></figure></p>
<p>‘\u01D1’.normalize() === ‘\u004F\u030C’.normalize()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">8. includes(),startWith(),endsWith()</div></pre></td></tr></table></figure>
<p>var s = ‘Hello world!’;<br>s.startsWith(‘Hello’) // true<br>s.endsWith(‘!’) // true<br>s.includes(‘o’) // true<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">9. repeat()</div></pre></td></tr></table></figure></p>
<p>‘x’.repeat(3) // “xxx”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">10. padStart(),padEnd()</div><div class="line"></div><div class="line">ES2017 引入了字符串补全长度的功能。</div></pre></td></tr></table></figure></p>
<p>‘x’.padStart(5, ‘ab’) // ‘ababx’<br>‘x’.padStart(4, ‘ab’) // ‘abax’<br>‘x’.padEnd(5, ‘ab’) // ‘xabab’<br>‘x’.padEnd(4, ‘ab’) // ‘xaba’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">11. 标签模板</div><div class="line"></div><div class="line">紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</div></pre></td></tr></table></figure></p>
<p>alert<code>123</code><br>// 等同于<br>alert(123)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">12. string.raw()</div><div class="line">String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</div></pre></td></tr></table></figure></p>
<p>String.raw<code>Hi\\n</code><br>// “Hi\n”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">13. 局限</div><div class="line"></div><div class="line">模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</div><div class="line"></div><div class="line">More info: [MDN Template Strings](https://developer.mozilla.org/en-US/docs/Web//Reference/template_strings)</div><div class="line"></div><div class="line">###  enhanced regular expression正则的扩展</div><div class="line"></div><div class="line">&gt; 保持匹配之间的匹配位置粘性，并且以这种方式支持对任意长输入字符串的有效解析，即使具有任意数量的不同的正则表达式。</div><div class="line"></div><div class="line">1. RegExp构造函数</div><div class="line">ES5中，按参数类型正则分两种情况：字符串/正则表达式</div></pre></td></tr></table></figure></p>
<p>var regex=new RegExp(‘xyz’,i);//var regex=/xyz/i;<br>var regex=new RegExp(/xyz/i);//var regex=/xyz/i;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ES6中，RegExp构造函数首个参数是正则对象，次个参数可以指定修饰符且以次个参数修饰符为准</div></pre></td></tr></table></figure></p>
<p>new RegExp(/abc/ig, ‘i’).flags<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 字符串的正则方法</div></pre></td></tr></table></figure></p>
<p>String.prototype.match // RegExp.prototype[Symbol.match]<br>String.prototype.replace // RegExp.prototype[Symbol.replace]<br>String.prototype.search //RegExp.prototype[Symbol.search]<br>String.prototype.split // RegExp.prototype[Symbol.split]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. u修饰符</div><div class="line">4. y修饰符</div><div class="line">实例</div></pre></td></tr></table></figure></p>
<p>let parser = (input, match) =&gt; {<br>    for (let pos = 0, lastPos = input.length; pos &lt; lastPos; ) {<br>        for (let i = 0; i &lt; match.length; i++) {<br>            match[i].pattern.lastIndex = pos<br>            let found<br>            if ((found = match[i].pattern.exec(input)) !== null) {<br>                match[i].action(found)<br>                pos = match[i].pattern.lastIndex<br>                break<br>            }<br>        }<br>    }<br>}</p>
<p>let report = (match) =&gt; {<br>    console.log(JSON.stringify(match))<br>}<br>parser(“Foo 1 Bar 7 Baz 42”, [<br>    { pattern: /^Foo\s+(\d+)/y, action: (match) =&gt; report(match) },<br>    { pattern: /^Bar\s+(\d+)/y, action: (match) =&gt; report(match) },<br>    { pattern: /^Baz\s+(\d+)/y, action: (match) =&gt; report(match) },<br>    { pattern: /^\s*/y,         action: (match) =&gt; {}            }<br>])<br>//ES5<br>var parser = function (input, match) {<br>    for (var i, found, inputTmp = input; inputTmp !== “”; ) {<br>        for (i = 0; i &lt; match.length; i++) {<br>            if ((found = match[i].pattern.exec(inputTmp)) !== null) {<br>                match[i].action(found);<br>                inputTmp = inputTmp.substr(found[0].length);<br>                break;<br>            }<br>        }<br>    }<br>}</p>
<p>var report = function (match) {<br>    console.log(JSON.stringify(match));<br>};<br>parser(“Foo 1 Bar 7 Baz 42”, [<br>    { pattern: /^Foo\s+(\d+)/, action: function (match) { report(match); } },<br>    { pattern: /^Bar\s+(\d+)/, action: function (match) { report(match); } },<br>    { pattern: /^Baz\s+(\d+)/, action: function (match) { report(match); } },<br>    { pattern: /^\s*/,         action: function (match) {}                 }<br>]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###  enhanced number expression数值的扩展</div><div class="line"></div><div class="line">1. 二进制八进制</div></pre></td></tr></table></figure></p>
<p>0b111110111 === 503 // true   Ob二进制<br>0o767 === 503 // true Oo八进制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. Number.isFinite(),Number.isNaN()</div><div class="line">3. Number.parseInt(),Number.parseFloat()</div></pre></td></tr></table></figure></p>
<p>// ES5的写法<br>parseInt(‘12.34’) // 12<br>parseFloat(‘123.45#’) // 123.45</p>
<p>// ES6的写法 是逐步减少全局性方法，使得语言逐步模块化。<br>Number.parseInt(‘12.34’) // 12<br>Number.parseFloat(‘123.45#’) // 123.45<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. Number.isInteger()</div><div class="line">5. Number.EPSILON ES6在Number对象上面，新增一个极小的常量Number.EPSILON。</div><div class="line">6. Number.isSafeInteger()                 </div><div class="line">7. Math对象的扩展</div><div class="line"></div><div class="line">- Math.trunc() 去除一个数的小数部分，返回整数部分。</div><div class="line">- Math.sign() 判断一个数到底是正数、负数、还是零。</div><div class="line">- Math.cbrt() 立方根。</div><div class="line">- Math.clz32() 返回一个数的32位无符号整数形式有多少个前导0。</div><div class="line">- Math.imul()方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</div><div class="line">- Math.fround()方法返回一个数的单精度浮点数形式。</div><div class="line">- Math.hypot()方法返回所有参数的平方和的平方根。</div><div class="line">- 对数方法</div><div class="line">    - Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。</div><div class="line">    - Math.log1p(x)方法返回1 + x的自然对数</div><div class="line">    - Math.log10(x)返回以10为底的x的对数</div><div class="line">    - Math.log2(x)返回以2为底的x的对数</div><div class="line">- 三角函数</div><div class="line">    Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</div><div class="line">    Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</div><div class="line">    Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</div><div class="line">    Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</div><div class="line">    Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</div><div class="line">    Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</div><div class="line">8. Math.sign()用来判断一个值的正负</div><div class="line">9. 指数运算符</div></pre></td></tr></table></figure></p>
<p>2 <strong> 2 // 4<br>2 </strong> 3 // 8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### enhanced array expression数组的扩展</div><div class="line"></div><div class="line">1. Array.from()</div><div class="line"></div><div class="line">&gt;将类数组（array-like object）与可遍历(literable)对象转化成真数组</div></pre></td></tr></table></figure></p>
<p>//兼容性<br>const toArray = (() =&gt;<br>  Array.from ? Array.from : obj =&gt; [].slice.call(obj)<br>)();</p>
<p>let arrayLike = {<br>    ‘0’: ‘a’,<br>    ‘1’: ‘b’,<br>    ‘2’: ‘c’,<br>    length: 3<br>};<br>var arr1=[].slice.call(arrayLike);//ES5<br>var arr2=Array.from(arrayLike);//ES6</p>
<p>let ps=document.querySelectorAll(‘p’);//NodeList对象<br>Array.from(ps).forEach(p=&gt;condole.log(p));</p>
<p>function foo(){<br>    Array.from(arguments);//arguments对象<br>}<br>//事实上，部署了Iterator接口的数据结构，Array.from都能将其转为数组<br>Array.from(‘hello’);//[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]<br>let nameSet=new Set([‘a’,’b’]);<br>Array.from(nameSet);//[‘a’,’b’]<br>//第二个参数<br>Array.from([1, 2, 3], (x) =&gt; x * x)<br>// [1, 4, 9]<br>Array.from([1, , 2, , 3], (n) =&gt; n || 0)<br>// [1, 0, 2, 0, 3]   布尔值为false的成员转为0。<br>function typesOf () {<br>  return Array.from(arguments, value =&gt; typeof value)<br>}<br>typesOf(null, [], NaN)<br>// [‘object’, ‘object’, ‘number’] 返回各种类型的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">另辟蹊径 ...也可以将某些数据转为数组</div><div class="line"></div><div class="line">&gt;扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是</div><div class="line">还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，</div><div class="line">都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</div></pre></td></tr></table></figure>
<p>function foo(){<br>    var args=[…arguements];<br>}<br>[…document.querySelectorAll(‘div’)];//NodeList<br>Array.from({ length: 3 });<br>// [ undefined, undefined, undefined ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">More MDN info:[Array.from()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)</div><div class="line"></div><div class="line">2. Array.of()</div><div class="line">为弥补Array()构造函数的不足，将一组值转为数组</div></pre></td></tr></table></figure></p>
<p>//hacker<br>function ArrayOf(){<br>  return [].slice.call(arguments);<br>}</p>
<p>Array() // []<br>Array(3) // [, , ,]<br>Array(3, 11, 8) // [3, 11, 8]</p>
<p>Array.of(3, 11, 8) // [3,11,8]<br>Array.of(3) // [3]<br>Array.of(3).length // 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 数组实例的copyWithin()</div></pre></td></tr></table></figure></p>
<p>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>//target（必需）：从该位置开始替换数据<br>[1, 2, 3, 4, 5].copyWithin(0, 3)<br>// [4, 5, 3, 4, 5]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. find()和findIndex()</div></pre></td></tr></table></figure>
<p>[1, 4, -5, 10].find((n) =&gt; n &lt; 0);//参数为回调函数<br>[1, 5, 10, 15].findIndex(function(value, index, arr) {<br>  return value &gt; 9;<br>}) // 2  返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br>[NaN].indexOf(NaN)<br>// -1  这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. fill()</div></pre></td></tr></table></figure></p>
<p>//使用给定值填充一个数组<br>[‘a’, ‘b’, ‘c’].fill(7)<br>// [7, 7, 7]<br>new Array(3).fill(7)<br>// [7, 7, 7]<br>[‘a’, ‘b’, ‘c’].fill(7, 1, 2)<br>// [‘a’, 7, ‘c’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. entries(),keys(),values() 都返回一个遍历器对象</div></pre></td></tr></table></figure></p>
<p>//keys()对键名的遍历<br>for (let index of [‘a’, ‘b’].keys()) {<br>  console.log(index);<br>}<br>// 0<br>// 1<br>//values()对键值的遍历<br>for (let elem of [‘a’, ‘b’].values()) {<br>  console.log(elem);<br>}<br>// ‘a’<br>// ‘b’<br>//entries()对键值对的遍历<br>for (let [index, elem] of [‘a’, ‘b’].entries()) {<br>  console.log(index, elem);<br>}<br>// 0 “a”<br>// 1 “b”<br>//不用for…of手动next遍历<br>let letter = [‘a’, ‘b’, ‘c’];<br>let entries = letter.entries();<br>console.log(entries.next().value); // [0, ‘a’]<br>console.log(entries.next().value); // [1, ‘b’]<br>console.log(entries.next().value); // [2, ‘c’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">7. includes() 某个数组是否包含给定的值</div></pre></td></tr></table></figure></p>
<p>[1, 2, 3].includes(2);     // true<br>[1, 2, 3].includes(4);     // false<br>[1, 2, NaN].includes(NaN); // true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">8. 空位</div><div class="line">注意，空位不是undefined，一个位置的值等于undefined，</div><div class="line">依然是有值的。空位是没有任何值，in运算符可以说明这一点。</div></pre></td></tr></table></figure>
<p>0 in [undefined, undefined, undefined] // true<br>0 in [, , ,] // false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</div><div class="line">forEach(),filter(),every(),some()跳过空位；map()跳过空位但保留该值</div><div class="line">；join(),toString(),将空位视为undefined，而undefined和null被处理成空字符串</div><div class="line"></div><div class="line">ES6明确将空位转为undefined 即不忽略空位</div></pre></td></tr></table></figure></p>
<p>Array.from([‘a’,,’b’])<br>// [ “a”, undefined, “b” ]<br>[…[‘a’,,’b’]]<br>// [ “a”, undefined, “b” ]<br>[,’a’,’b’,,].copyWithin(2,0) // [,”a”,,”a”]<br>new Array(3).fill(‘a’) // [“a”,”a”,”a”]<br>let arr = [, ,];<br>for (let i of arr) {<br>  console.log(1);<br>}<br>// 1<br>// 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;Callee-evaluated default parameter values.  </div><div class="line">Turn an array into consecutive arguments in a function call.  </div><div class="line">Bind trailing parameters to an array.  </div><div class="line">Rest replaces the need for `arguments` and addresses common cases more directly.</div></pre></td></tr></table></figure></p>
<p>function f(x, y=12) {<br>  return x + y;<br>}<br>f(3) == 15;<br>// ES5 y=undefined||12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>function f(x, …y) {<br>  return x <em> y.length;<br>}<br>f(3, “hello”, true) == 6;<br>//ES5<br>“use strict”;<br>function f(x) {<br>  for (var _len = arguments.length, y = Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {<br>    y[_key - 1] = arguments[_key];<br>  }<br>  return x </em> y.length;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>function f(x, y, z) {<br>  return x + y + z;<br>}<br>// Pass each elem of array as argument<br>f(…[1,2,3]) == 6<br>var str = “foo”<br>var chars = [ …str ] // [ “f”, “o”, “o” ],ES5 var chars = str.split(“”); // [ “f”, “o”, “o” ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">More MDN info: [Default parameters](https://developer.mozilla.org/en-US/docs/Web//Reference/Functions/Default_parameters), [Rest parameters](https://developer.mozilla.org/en-US/docs/Web//Reference/Functions/rest_parameters), [Spread Operator](https://developer.mozilla.org/en-US/docs/Web//Reference/Operators/Spread_operator)</div><div class="line"></div><div class="line">### enhanced function expression函数的扩展</div><div class="line"></div><div class="line">1. 参数默认值</div><div class="line"></div><div class="line">基本用法</div></pre></td></tr></table></figure></p>
<p>//ES5<br>function log(x, y) {<br>  y = y || ‘World’;<br>  console.log(x, y);<br>}<br>//ES6,参数默认值是惰性求值的<br>let m=’My’<br>function log(x, y = m+’World’) {<br>  console.log(x, y);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">结合解耦赋值</div></pre></td></tr></table></figure></p>
<p>function fetch(url,{body=’’,method=’GET’,headers={} }){<br>    //…<br>}<br>fetch(‘<a href="http://example.com" target="_blank" rel="external">http://example.com</a>‘, {})<br>// “GET”<br>fetch(‘<a href="http://example.com" target="_blank" rel="external">http://example.com</a>‘)<br>// 报错,函数fetch的第二个参数是一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">函数的length属性:没有指定默认值的参数个数</div></pre></td></tr></table></figure></p>
<p>(function (a) {}).length // 1<br>(function (a = 5) {}).length // 0<br>(function (a, b, c = 5) {}).length // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">作用域</div></pre></td></tr></table></figure></p>
<p>//调用函数f时，参数形成一个单独的作用域<br>let x = 1;<br>function f(y = x) {<br>  let x = 2;<br>  console.log(y);<br>}<br>f() // 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">应用</div></pre></td></tr></table></figure></p>
<p>function throwIfMissing() {<br>  throw new Error(‘Missing parameter’);<br>}</p>
<p>function foo(mustBeProvided = throwIfMissing()) {<br>  return mustBeProvided;<br>}<br>foo()<br>// Error: Missing parameter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. rest 参数</div></pre></td></tr></table></figure></p>
<p>(function(a) {}).length  // 1<br>(function(…a) {}).length  // 0<br>(function(a, …b) {}).length  // 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. spread...  扩展运算符,好比 rest 参数的逆运算</div><div class="line">主要用于函数运算</div></pre></td></tr></table></figure></p>
<p>function push(array, …items) {<br>  array.push(…items);<br>}</p>
<p>function add(x, y) {<br>  return x + y;<br>}</p>
<p>var numbers = [4, 38];<br>add(…numbers) // 42<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">替代数组的apply方法</div></pre></td></tr></table></figure></p>
<p>// ES5的写法<br>function f(x, y, z) {<br>  // …<br>}<br>var args = [0, 1, 2];<br>f.apply(null, args);</p>
<p>// ES6的写法<br>function f(x, y, z) {<br>  // …<br>}<br>var args = [0, 1, 2];<br>f(…args);<br>//应用<br>Math.max.apply(null, [14, 3, 77]);// ES5<br>Math.max(…[14, 3, 77]);// ES6<br>Math.max(14, 3, 77);// 等同于</p>
<p>var arr1=[1,2,3],arr2=[4,5];<br>Array.prototype.push.apply(arr1,arr2);//ES5<br>arr1.push(…arr2);//ES6<br>new (Date.bind.apply(Date, [null, 2015, 1, 1]));//ES5<br>new Date(…[2015, 1, 1]);// ES6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">扩展运算符应用</div><div class="line"></div><div class="line">1. 数组合并</div></pre></td></tr></table></figure></p>
<p>arr1.concat(arr2,arr3);//ES5<br>[…arr1,…arr2,…arr3];//ES6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 结合解耦:将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</div></pre></td></tr></table></figure></p>
<p>const [first, …rest] = [1, 2, 3, 4, 5];<br>first // 1<br>rest  // [2, 3, 4, 5]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3.函数返回值</div><div class="line"></div><div class="line">&gt;JS函数只能有一个返回值，如果返回多个值只能将其放入数组或对象中返回</div></pre></td></tr></table></figure></p>
<p>var dateFields=readDateFields(datebase);<br>var d=new Date(…dateFields);<br>//上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. 字符串:将字符串转为真正的数组。</div></pre></td></tr></table></figure></p>
<p>[…’hello’]<br>// [ “h”, “e”, “l”, “l”, “o” ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. 实现了Iterator接口的对象</div><div class="line"></div><div class="line">&gt;任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</div></pre></td></tr></table></figure></p>
<p>var nodeList = document.querySelectorAll(‘div’);<br>var array = […nodeList];</p>
<p>let arrayLike = {<br>  ‘0’: ‘a’,<br>  ‘1’: ‘b’,<br>  ‘2’: ‘c’,<br>  length: 3<br>};<br>let arr = […arrayLike];<br>// TypeError: Cannot spread non-iterable object.<br>//arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. Map和Set结构，Generator函数</div></pre></td></tr></table></figure></p>
<p>let map = new Map([<br>  [1, ‘one’],<br>  [2, ‘two’],<br>  [3, ‘three’],<br>]);<br>let arr = […map.keys()]; // [1, 2, 3]<br>var go = function*(){<br>  yield 1;<br>  yield 2;<br>  yield 3;<br>};<br>[…go()] // [1, 2, 3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. 严格模式</div><div class="line">&gt;ES5中函数内部可设定为严格模式，ES6中规定函数参数一旦使用了默认值，</div><div class="line">解耦赋值，或者扩展运算符，那么函数内就不能设定为严格模式。不合理之处在于</div><div class="line">函数执行时先执行参数代码再执行函数体代码，而只有执行了函数体代码才知道是否</div><div class="line">遵循严格模式。</div><div class="line"></div><div class="line">*为规避之，可以全局设置严格模式或者把函数放于一个IIFE中*</div></pre></td></tr></table></figure></p>
<p>  ‘use strict’;<br>  //or…<br>const doSomething = (function () {<br>  ‘use strict’;<br>  return function(value = 42) {<br>    return value;<br>  };<br>}());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. name属性：函数的函数名</div></pre></td></tr></table></figure></p>
<p>var f = function () {};<br>f.name // “f”  ES6<br>const bar = function baz() {};<br>bar.name // “baz”<br>(new Function).name // “anonymous”<br>function foo() {};<br>foo.bind({}).name // “bound foo”<br>(function(){}).bind({}).name // “bound “<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. 箭头函数</div><div class="line"></div><div class="line">&gt;Arrows are a function shorthand using the `=&gt;` syntax.  They are syntactically similar to</div><div class="line"> the related feature in C#, Java 8 and CoffeeScript(和C#，Java8及CoffeeScript类似).  </div><div class="line"> They support both statement block bodies as well as expression bodies which return the value of the expression.  </div><div class="line"> Unlike functions, arrows share the same lexical `this` as their surrounding code(异于function，箭头函数和其EC</div><div class="line"> 共享this).</div></pre></td></tr></table></figure></p>
<p>// Expression bodies表达式主体<br>var odds = evens.map(v =&gt; v + 1);<br>var nums = evens.map((v, i) =&gt; v + i);<br>var pairs = evens.map(v =&gt; ({even: v, odd: v + 1}));<br>// Statement bodies声明式主体<br>nums.forEach(v =&gt; {<br>  if (v % 5 === 0)<br>    fives.push(v);<br>});</p>
<p>// Lexical this共享this<br>this.nums.forEach((v) =&gt; {<br>    if (v % 5 === 0)<br>        this.fives.push(v)<br>})<br>//ES5<br>odds  = evens.map(function (v) { return v + 1; });<br>pairs = evens.map(function (v) { return { even: v, odd: v + 1 }; });<br>nums  = evens.map(function (v, i) { return v + i; });<br>nums.forEach(function (v) {<br>   if (v % 5 === 0)<br>       fives.push(v);<br>});<br>//  variant 1<br>var self = this;<br>this.nums.forEach(function (v) {<br>    if (v % 5 === 0)<br>        self.fives.push(v);<br>});</p>
<p>//  variant 2<br>this.nums.forEach(function (v) {<br>    if (v % 5 === 0)<br>        this.fives.push(v);<br>}, this);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意点：</div><div class="line"></div><div class="line">- 函数体内this对象为定义时而非使用时所在的对象</div><div class="line">- 不可作为构造函数</div><div class="line">- 不可使用arguments对象，可用rest参数代替</div><div class="line">- 不可作为generator函数，因不可使用yield命令</div><div class="line"></div><div class="line">箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。</div></pre></td></tr></table></figure></p>
<p>var handler = {<br>  id: ‘123456’,<br>  init: function() {<br>    document.addEventListener(‘click’,<br>      event =&gt; this.doSomething(event.type), false);<br>  },<br>  doSomething: function(type) {<br>    console.log(‘Handling ‘ + type  + ‘ for ‘ + this.id);<br>  }<br>};</p>
<p>function foo() {<br>  return () =&gt; {<br>    return () =&gt; {<br>      return () =&gt; {<br>        console.log(‘id:’, this.id);<br>      };<br>    };<br>  };<br>}</p>
<p>var f = foo.call({id: 1});<br>var t1 = f.call({id: 2})()(); // id: 1<br>var t2 = f().call({id: 3})(); // id: 1<br>var t3 = f()().call({id: 4}); // id: 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">More info: [MDN Arrow Functions](https://developer.mozilla.org/en/docs/Web//Reference/Functions/Arrow_functions)</div><div class="line"></div><div class="line">8. 尾调用（tail call，算法层）优化</div><div class="line"></div><div class="line">&gt;Tail Call 函数式编程的重要概念，某个函数最后一步调用的是另一个函数</div><div class="line">函数调用会在内存中形成一个调用记录（call frame）,保存调用位置和内部变量等信息</div></pre></td></tr></table></figure></p>
<p>//模型<br>function f(x){<br>  return g(x);<br>}<br>function f() {<br>  let m = 1;<br>  let n = 2;<br>  return g(m + n);<br>}<br>f();<br>// 等同于<br>function f() {<br>  return g(3);<br>}<br>f();<br>// 等同于<br>g(3);<br>//注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br>function addOne(a){<br>  var one = 1;<br>  function inner(b){<br>    return b + one;<br>  }<br>  return inner(a);<br>}//并未优化<br>//curring将多参数的函数转换成单参数的形式。<br>function currying(fn, n) {<br>  return function (m) {<br>    return fn.call(this, m, n);<br>  };<br>}<br>//算法复杂度由O(n)降到O(1)<br>function tailFactorial(n, total) {<br>  if (n === 1) return total;<br>  return tailFactorial(n - 1, n <em> total);<br>}<br>const factorial = currying(tailFactorial, 1);<br>factorial(5) // 120<br>//ES6的默认值<br>function factorial(n, total = 1) {<br>  if (n === 1) return total;<br>  return factorial(n - 1, n </em> total);<br>}<br>factorial(5) // 120<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### enhanced object expression对象的扩展</div><div class="line"></div><div class="line">1. 属性的简洁表示</div></pre></td></tr></table></figure></p>
<p>var foo=’bar’;<br>var baz={foo};//{foo:’bar’},可将对象的属性或方法直接写成变量或函数<br>function f(x, y) {return {x, y};}<br>var o={<br>    method(){},<br>}<br>//getter,setter<br>var cart = {<br>  _wheels: 4,<br>  get wheels () {<br>    return this._wheels;<br>  },<br>  set wheels (value) {<br>    if (value &lt; this._wheels) {<br>      throw new Error(‘数值太小了！’);<br>    }<br>    this._wheels = value;<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 属性名表达式</div></pre></td></tr></table></figure></p>
<p>//JS定义对象属性方法<br>obj.foo=true;//一<br>obj[‘a’+’bc’]=123;//二<br>var obj={foo:true,abc:123};//ES5<br>let propKey = ‘foo’;<br>//ES6<br>let obj = {</p>
<p>};<br>let obj = {<br>  <a href="">‘h’ + ‘ello’</a> {<br>    return ‘hi’;<br>  }<br>};<br>obj.hello() // hi<br>//属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]<br>const keyA = {a: 1};<br>const keyB = {b: 2};<br>const myObject = {</p>
<p>};<br>myObject // Object {[object Object]: “valueB”}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 方法的name属性</div></pre></td></tr></table></figure></p>
<p>const person = {<br>  sayName() {<br>    console.log(‘hello!’);<br>  },<br>};<br>person.sayName.name   // “sayName”<br>/<em><br>如果对象的方法使用了取值函数（getter）和存值函数（setter），<br>则name属性不是在该方法上面，而是该方法的属性的描述对象的<br>get和set属性上面，返回值是方法名前加上get和set。
</em>/<br>const obj = {<br>  get foo() {},<br>  set foo(x) {}<br>};<br>obj.foo.name<br>// TypeError: Cannot read property ‘name’ of undefined<br>const descriptor = Object.getOwnPropertyDescriptor(obj, ‘foo’);<br>descriptor.get.name // “get foo”<br>descriptor.set.name // “set foo”</p>
<p>(new Function()).name // “anonymous”</p>
<p>var doSomething = function() {<br>  // …<br>};<br>doSomething.bind().name // “bound doSomething”<br>//如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。<br>const key1 = Symbol(‘description’);<br>const key2 = Symbol();<br>let obj = {<br>  <a href="">key1</a> {},<br>  <a href="">key2</a> {},<br>};<br>obj[key1].name // “[description]”<br>obj[key2].name // “”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. Object.is()</div><div class="line"></div><div class="line">&gt; ES5中只有==（自动转换数据类型）和===（NaN!=NaN,+0==-0）,ES6中提出</div><div class="line">Same-value equality 同值相等</div></pre></td></tr></table></figure></p>
<p>Object.is(‘foo’, ‘foo’);// true<br>Object.is({}, {});// false<br>+0 === -0 //true<br>NaN === NaN // false<br>Object.is(+0, -0) // false<br>Object.is(NaN, NaN) // true<br>Object.defineProperty(Object, ‘is’, {<br>  value: function(x, y) {<br>    if (x === y) {<br>      // 针对+0 不等于 -0的情况<br>      return x !== 0 || 1 / x === 1 / y;<br>    }<br>    // 针对NaN的情况<br>    return x !== x &amp;&amp; y !== y;<br>  },<br>  configurable: true,<br>  enumerable: false,<br>  writable: true<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. Object.assign()</div><div class="line"></div><div class="line">用于对象合并，将源对象(source)所有可枚举属性，复制到目标对象(target)</div></pre></td></tr></table></figure></p>
<p>var target={a:1};<br>var source1={b:2};<br>var source2={c:3};<br>Object.assign(target,source1,source2);<br>target;//{a:1,b:2,c:3}<br>var obj = {a: 1};<br>Object.assign(obj) === obj // true,如果只有一个参数，Object.assign会直接返回该参数。<br>typeof Object.assign(2) // “object” 如果该参数不是对象，则会先转成对象，然后返回。<br>Object.assign(undefined) // 报错<br>Object.assign(null) // 报错,由于undefined和null无法转成对象<br>Object.assign(obj, undefined) === obj // true,如果无法转成对象，就会跳过</p>
<p>var v1 = ‘abc’;<br>var v2 = true;<br>var v3 = 10;<br>var obj = Object.assign({}, v1, v2, v3);<br>console.log(obj); // { “0”: “a”, “1”: “b”, “2”: “c” }<br>//只有字符串的包装对象，会产生可枚举属性。故除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。<br>Object(true) // {[[PrimitiveValue]]: true}<br>Object(10)  //  {[[PrimitiveValue]]: 10}<br>Object(‘abc’) // {0: “a”, 1: “b”, 2: “c”, length: 3, [[PrimitiveValue]]: “abc”}</p>
<p>Object.assign({b: ‘c’},<br>  Object.defineProperty({}, ‘invisible’, {<br>    enumerable: false,<br>    value: ‘hello’<br>  })<br>)<br>// { b: ‘c’ } ，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>
<p>Object.assign({ a: ‘b’ }, { [Symbol(‘c’)]: ‘d’ })<br>// { a: ‘b’, Symbol(c): ‘d’ }</p>
<p>Object.assign([1, 2, 3], [4, 5])<br>// [4, 5, 3] ，把数组视为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*Object.assign进行的是浅拷贝*</div><div class="line"></div><div class="line">应用：</div><div class="line"></div><div class="line">1. 为对象添加属性</div></pre></td></tr></table></figure></p>
<p>class Point{<br>    constructor(x,y){<br>        Object.assign(this,{x,y});//将x属性和y属性添加到Point类的对象实例。<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 为对象添加方法</div></pre></td></tr></table></figure></p>
<p>Object.assign(SomeClass.prototype, {<br>  someMethod(arg1, arg2) {<br>  },<br>  anotherMethod() {<br>  }<br>});<br>//等同于<br>SomeClass.prototype.someMethod = function (arg1, arg2) {<br>};<br>SomeClass.prototype.anotherMethod = function () {<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 克隆对象</div></pre></td></tr></table></figure></p>
<p>function clone(origin){<br>    return Object.assign({},origin);<br>}//只克隆原始对象自身的值而克隆不了其继承的值<br>function clone(origin){<br>    let originProto=Object.getPrototypeOf(origin);<br>    return Object.assign(Object.create(originProto),origin);<br>}//不仅克隆本身还克隆其继承的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4.合并对象</div></pre></td></tr></table></figure></p>
<p>//将多个对象合并到某个对象<br>const merge=(target,…source)=&gt;Object.assign(target,…source);<br>//合并后返回一个新对象<br>const merge=(…source)=&gt;Object.assign({},…source);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. 为属性指定默认值</div></pre></td></tr></table></figure></p>
<p>const DEFAULTS = {<br>  logLevel: 0,<br>  outputFormat: ‘html’<br>};</p>
<p>function processContent(options) {<br>  options = Object.assign({}, DEFAULTS, options);<br>  console.log(options);<br>  // …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6.属性的可枚举性：Object.getOwnPropertyDescriptor可以获取该属性的描述对象</div></pre></td></tr></table></figure></p>
<p>let obj = { foo: 123 };<br>Object.getOwnPropertyDescriptor(obj, ‘foo’)<br>//  {<br>//    value: 123,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*ES5的三个操作会忽略enumerable为false的属性*</div><div class="line">- for...in循环:只遍历对象自身*及继承的*可枚举属性</div><div class="line">- Object.keys():返回对象自身所有科美居属性的键名</div><div class="line">- JSON.stringify():只串行化对象自身的可枚举属性</div><div class="line">- ES 6中Object.assign()会忽略enumerable为false的属性,只拷贝对象自身可枚举属性</div></pre></td></tr></table></figure></p>
<p>Object.getOwnPropertyDescriptor(Object.prototype, ‘toString’).enumerable<br>// false<br>Object.getOwnPropertyDescriptor([], ‘length’).enumerable<br>// false<br>Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, ‘foo’).enumerable<br>// false,故for…in不会遍历到这两个继承自原型的属性。<br>//一般我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">7. 属性遍历</div><div class="line"></div><div class="line">  1. for...in :对象自身的和继承的可枚举属性（不含Symbol属性）。</div><div class="line">  2. Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</div><div class="line">  3. Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</div><div class="line">  4. Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</div><div class="line">  5. Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</div></pre></td></tr></table></figure></p>
<p>Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })<br>// [‘2’, ‘10’, ‘b’, ‘a’, Symbol()]<br>//遍历顺序：数值&gt;字符串&gt;Symbol<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">8. __proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()</div><div class="line"></div><div class="line">&gt; __proto__读取或设置对象的prototype对象，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性</div><div class="line">后边几个替代之</div></pre></td></tr></table></figure></p>
<p>Object.getPrototypeOf({ <strong>proto</strong>: null })<br>// null,设置了<strong>proto</strong>属性的对象，其值既是对象的原型<br>// 格式, ES6 正式推荐<br>Object.setPrototypeOf(object, prototype);<br>Object.getPrototypeOf(obj);<br>// 用法<br>var o = Object.setPrototypeOf({}, null);<br>function Rectangle() {<br>  // …<br>}<br>var rec = new Rectangle();<br>Object.getPrototypeOf(rec) === Rectangle.prototype<br>// true<br>Object.setPrototypeOf(rec, Object.prototype);<br>Object.getPrototypeOf(rec) === Rectangle.prototype<br>// false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">9. Object.keys(),Object.values(),Object.entries()</div><div class="line"></div><div class="line">10. 对象的扩展运算符</div><div class="line"></div><div class="line">  1. 解耦</div></pre></td></tr></table></figure></p>
<p>  let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };<br>  x // 1<br>  y // 2<br>  z // { a: 3, b: 4 }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. 扩展运算符</div></pre></td></tr></table></figure></p>
<p>  let z = { a: 3, b: 4 };<br>  let n = { …z };<br>  n // { a: 3, b: 4 }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11.  Object.getOwnPropertyDescriptors() </div><div class="line"></div><div class="line">&gt; 指定对象所有自身属性（非继承属性）的描述对象</div></pre></td></tr></table></figure></p>
<p>const obj = {<br>  foo: 123,<br>  get bar() { return ‘abc’ }<br>};</p>
<p>Object.getOwnPropertyDescriptors(obj)<br>// { foo:<br>//    { value: 123,<br>//      writable: true,<br>//      enumerable: true,<br>//      configurable: true },<br>//   bar:<br>//    { get: [Function: bar],<br>//      set: undefined,<br>//      enumerable: true,<br>//      configurable: true } }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">12. Null传导运算符(Babel尚未支持)</div><div class="line"></div><div class="line">More info: [MDN Grammar and types: Object literals](https://developer.mozilla.org/en-US/docs/Web//Guide/Grammar_and_types#Object_literals)</div><div class="line"></div><div class="line">### Symbol</div><div class="line"></div><div class="line">1. ES5对象属性名都是容易造成命名冲突的字符串，引入Symbol数据类型从根本上解决了此问题</div><div class="line"> </div><div class="line">*注意symbol不能用new命令，因为生成Symbol对象是一个原始类型的值，而非对象*</div></pre></td></tr></table></figure></p>
<p> let s=Symbol();<br> typeof s;//‘symbol’<br>//Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。<br>var s1=Symbol(‘foo’);<br>s1;//Symbol(foo)<br>s1.toString();//“Symbol(foo)”<br>//Symbol函数的参数只是表示对当前 Symbol 值的描述<br>var s2 = Symbol(‘foo’);<br>s1 === s2 // false<br>String(s1);//“Symbol(foo)”<br>“your symbol is “ + s1;//Symbol不能与其它类型值进行运算，但可以显示转为字符串<br>var sym = Symbol();<br>Boolean(sym) // true<br>!sym  // false<br>if (sym) {<br>  // …<br>}<br>Number(sym) // TypeError<br>sym + 2 // TypeError,Symbol值也可以转为布尔值，但是不能转为数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 作为属性名的Symbol</div></pre></td></tr></table></figure></p>
<p>var mySymbol=Symbol();<br>var a={};<br>a[mySymbol]=’hello!’;<br>var a={[mySymbol]:’hello!’};<br>Object.defineProperty(a,mySymbol,{value:’hello!’});<br>a[mySymbol];//‘hello!’<br>//Symbol值作为对象属性名时，由于点运算符后面总是字符串不会读取mySymbol作为标识名所指代的那个值不能用点运算符<br>a.mySymbol=’hello!’;<br>a.mySymbol;//‘undefined’<br>a[‘mySymbol’];//‘hello!’<br>let s = Symbol();<br>let obj = {<br>   <a href="arg">s</a> { … }<br>};<br>obj<a href="123">s</a>;<br>//实例，常量使用Symbol的好处是任何值都不可能有相同值了，且Symbol值作为属性名时该属性为公有属性<br>const COLOR_RED    = Symbol();<br>const COLOR_GREEN  = Symbol();<br>function getComplement(color) {<br>  switch (color) {<br>    case COLOR_RED:<br>      return COLOR_GREEN;<br>    case COLOR_GREEN:<br>      return COLOR_RED;<br>    default:<br>      throw new Error(‘Undefined color’);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 消除魔术字符串</div></pre></td></tr></table></figure></p>
<p>const shapeType = {<br>  triangle: Symbol()<br>};<br>function getArea(shape, options) {<br>  var area = 0;<br>  switch (shape) {<br>    case shapeType.triangle:<br>      area = .5 <em> options.width </em> options.height;<br>      break;<br>  }<br>  return area;<br>}</p>
<p>getArea(shapeType.triangle, { width: 100, height: 100 });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. 属性名遍历</div><div class="line"></div><div class="line">&gt; Symbol作为属性名，该属性不会出现在for...in，for...of,Object.keys(),</div><div class="line">Object.getOwnPropertyNames(),JSON.stringify()返回，但也不是私有属性，唯有</div><div class="line">Object.getOwnPropertySymbols可以获取指定对象的所有Symbol属性名。</div></pre></td></tr></table></figure></p>
<p>var obj = {};<br>var a = Symbol(‘a’);<br>var b = Symbol(‘b’);<br>obj[a] = ‘Hello’;<br>obj[b] = ‘World’;<br>Object.getOwnPropertySymbols(obj);// [Symbol(a), Symbol(b)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. Symbol.for(),Symbol.keyFor()</div><div class="line"></div><div class="line">More info: [MDN Symbol](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Symbol)</div><div class="line"></div><div class="line">###  Map + Set </div><div class="line"></div><div class="line">&gt;Efficient data structures for common algorithms.  WeakMaps provides leak-free object-key’d side tables.</div><div class="line"></div><div class="line">1. Set</div><div class="line"></div><div class="line">&gt; ES6新的数据结构之一，类似数组但成员唯一，Set本身是一个构造函数用来生成Set数据结构</div></pre></td></tr></table></figure></p>
<p>var set = new Set([1, 2, 3, 4, 4]);<br>[…set] // [1, 2, 3, 4]<br>set.size // 4<br>function divs () {<br>  return […document.querySelectorAll(‘div’)];<br>}<br>var set = new Set(divs());//or<br>divs().forEach(div =&gt; set.add(div));<br>set.size // 56<br>//Set内部，NaN相等而两个对象不等<br>let set = new Set();<br>let a = NaN;<br>let b = NaN;<br>set.add(a);<br>set.add(b);<br>set // Set {NaN}</p>
<p>et.add({});<br>set.size // 1<br>set.add({});<br>set.size // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Set实例的属性和方法</div><div class="line"></div><div class="line">属性：</div><div class="line"></div><div class="line">- Set.prototype.constructor</div><div class="line">- Set.prototype.size</div><div class="line"></div><div class="line">方法</div><div class="line"></div><div class="line">- add(value)</div><div class="line">- clear()</div><div class="line">- delete(value)</div><div class="line">- has(value)</div><div class="line"></div><div class="line">遍历:Set的遍历顺序就是插入顺序</div><div class="line"></div><div class="line">- keys()</div><div class="line">- values()</div><div class="line">- entries()</div><div class="line">- forEach()</div><div class="line"></div><div class="line">Array.from可以将Set结构转为数组</div></pre></td></tr></table></figure></p>
<p>var items=new Set([1,2,3,4,5]);<br>var array=Array.from(items);<br>[…new Set(arr)]//不失为数组去重的好方法<br>Array.from(new Set(arr));//不失为数组去重的好方法</p>
<p>let set = new Set([‘red’, ‘green’, ‘blue’]);<br>for (let item of set.keys()) {<br>  console.log(item);<br>}<br>// red green blue<br>for (let item of set.values()) {<br>  console.log(item);<br>}<br>// red green blue<br>for (let item of set.entries()) {<br>  console.log(item);<br>}<br>// [“red”, “red”]<br>// [“green”, “green”]<br>// [“blue”, “blue”]</p>
<p>Set.prototype[Symbol.iterator] === Set.prototype.values;//可以省略values方法<br>// true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. WeakSet</div><div class="line"></div><div class="line">&gt;WeakSet成员只能是弱引用对象，成员不可遍历</div><div class="line"></div><div class="line">3. Map</div><div class="line"></div><div class="line">&gt;JS对象本质是键值对的集合（hash结构），但传统上只能用字符串作键。ES6中</div><div class="line">的Map类对象的数据结构使得各种类型的值都可以作键，是一种更完善的hash结构实现</div></pre></td></tr></table></figure>
<p>var m = new Map();<br>var o = {p: ‘Hello World’};<br>m.set(o, ‘content’)<br>m.get(o) // “content”<br>m.has(o) // true<br>m.delete(o) // true<br>m.has(o) // false</p>
<p>var map = new Map([<br>  [‘name’, ‘张三’],<br>  [‘title’, ‘Author’]<br>]);<br>map.size // 2<br>map.has(‘name’) // true<br>map.get(‘name’) // “张三”<br>map.has(‘title’) // true<br>map.get(‘title’) // “Author”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">实例和属性的操作方法</div><div class="line"></div><div class="line">1. size</div></pre></td></tr></table></figure></p>
<p>let map = new Map();<br>map.set(‘foo’, true);<br>map.set(‘bar’, false);<br>map.size // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. set(key, value)</div></pre></td></tr></table></figure></p>
<p>var m = new Map();<br>m.set(“edition”, 6)        // 键是字符串<br>m.set(262, “standard”)     // 键是数值<br>m.set(undefined, “nah”)    // 键是undefined<br>let map = new Map()<br>  .set(1, ‘a’)<br>  .set(2, ‘b’)<br>  .set(3, ‘c’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. get(key)</div></pre></td></tr></table></figure></p>
<p>var m = new Map();<br>var hello = function() {console.log(“hello”);}<br>m.set(hello, “Hello ES6!”) // 键是函数<br>m.get(hello)  // Hello ES6!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. has(key)</div><div class="line">5. delete(key)</div><div class="line">6. clear()</div><div class="line"></div><div class="line">遍历方法同Set</div><div class="line">与其它数据结构的互换</div><div class="line"></div><div class="line">  1. 数组</div></pre></td></tr></table></figure></p>
<p>let myMap = new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>[…myMap]<br>// [ [ true, 7 ], [ { foo: 3 }, [ ‘abc’ ] ] ]<br>new Map([[true, 7], [{foo: 3}, [‘abc’]]])<br>// Map {true =&gt; 7, Object {foo: 3} =&gt; [‘abc’]}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 对象</div></pre></td></tr></table></figure></p>
<p>function strMapToObj(strMap) {<br>  let obj = Object.create(null);<br>  for (let [k,v] of strMap) {<br>    obj[k] = v;<br>  }<br>  return obj;<br>}</p>
<p>let myMap = new Map().set(‘yes’, true).set(‘no’, false);<br>strMapToObj(myMap)<br>// { yes: true, no: false }<br>function objToStrMap(obj) {<br>  let strMap = new Map();<br>  for (let k of Object.keys(obj)) {<br>    strMap.set(k, obj[k]);<br>  }<br>  return strMap;<br>}<br>objToStrMap({yes: true, no: false})<br>// [ [ ‘yes’, true ], [ ‘no’, false ] ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. JSON</div></pre></td></tr></table></figure></p>
<p>function strMapToJson(strMap) {<br>  return JSON.stringify(strMapToObj(strMap));<br>}<br>let myMap = new Map().set(‘yes’, true).set(‘no’, false);<br>strMapToJson(myMap)<br>// ‘{“yes”:true,”no”:false}’</p>
<p>function jsonToStrMap(jsonStr) {<br>  return objToStrMap(JSON.parse(jsonStr));<br>}<br>jsonToStrMap(‘{“yes”:true,”no”:false}’)<br>// Map {‘yes’ =&gt; true, ‘no’ =&gt; false}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. WeakMap:只接收不计入GC的对象作为键名</div><div class="line"></div><div class="line">More MDN info: [Map](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Map), [Set](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Set), [WeakMap](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/WeakMap), [WeakSet](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/WeakSet)</div><div class="line"></div><div class="line">###  Proxy代理</div><div class="line"></div><div class="line">&gt;用于修改某些操作的默认行为,等同于在语言层面修改，属于meta programming元编程</div><div class="line">即对编程语言编程</div></pre></td></tr></table></figure></p>
<p>//Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。<br>var obj = new Proxy({}, {<br>  get: function (target, key, receiver) {<br>    console.log(<code>getting ${key}!</code>);<br>    return Reflect.get(target, key, receiver);<br>  },<br>  set: function (target, key, value, receiver) {<br>    console.log(<code>setting ${key}!</code>);<br>    return Reflect.set(target, key, value, receiver);<br>  }<br>});<br>obj.count = 1<br>//  setting count!<br>++obj.count<br>//  getting count!<br>//  setting count!<br>//  2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">proxy支持的操作</div><div class="line"></div><div class="line">- get(target, propKey, receiver) 拦截对象属性的读取</div><div class="line">- set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[&apos;foo&apos;] = v，返回一个布尔值。</div><div class="line">- has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。</div><div class="line">- deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。</div><div class="line">- ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。</div><div class="line">- getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</div><div class="line">- defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</div><div class="line">- preventExtensions(target)拦截Object.preventExtensions(proxy)，返回一个布尔值。</div><div class="line">- getPrototypeOf(target)拦截Object.getPrototypeOf(proxy)，返回一个对象</div><div class="line">- isExtensible(target)拦截Object.isExtensible(proxy)，返回一个布尔值。</div><div class="line">- setPrototypeOf(target, proto)拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</div><div class="line">- apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。</div><div class="line">- construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。</div></pre></td></tr></table></figure>
<p>// Proxying a normal object<br>var target = {};<br>var handler = {<br>  get: function (receiver, name) {<br>    return <code>Hello, ${name}!</code>;<br>  }<br>};</p>
<p>var p = new Proxy(target, handler);<br>p.world === ‘Hello, world!’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// Proxying a function object<br>var target = function () { return ‘I am the target’; };<br>var handler = {<br>  apply: function (receiver, …args) {<br>    return ‘I am the proxy’;<br>  }<br>};</p>
<p>var p = new Proxy(target, handler);<br>p() === ‘I am the proxy’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">There are traps available for all of the runtime-level meta-operations:</div></pre></td></tr></table></figure></p>
<p>var handler =<br>{<br>  get:…,<br>  set:…,<br>  has:…,<br>  deleteProperty:…,<br>  apply:…,<br>  construct:…,<br>  getOwnPropertyDescriptor:…,<br>  defineProperty:…,<br>  getPrototypeOf:…,<br>  setPrototypeOf:…,<br>  enumerate:…,<br>  ownKeys:…,<br>  preventExtensions:…,<br>  isExtensible:…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">More info: [MDN Proxy](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Proxy)</div><div class="line"></div><div class="line">###  Reflect</div><div class="line"></div><div class="line">设计目的：</div><div class="line"></div><div class="line">1. 将Object对象一些明显属于语言内部的方法（Object.defineProperty）,放到Reflect对象上</div><div class="line">2. 修改某些Object方法的返回结果，让其变得更合理。</div><div class="line"></div><div class="line">&gt;如，Object.defineProperty(obj, name, desc)在无法定义属性时，</div><div class="line">    会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</div></pre></td></tr></table></figure></p>
<p>//ES5<br>try{<br>    Object.defineProperty(target,property,attributes);<br>}catch(e){}<br>//ES6<br>if(Reflect.defineProperty(target,property,attributes)){<br>//success<br>}else{//failure}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 让Object操作都变成函数行为。</div><div class="line"></div><div class="line">&gt;某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)</div><div class="line">和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</div></pre></td></tr></table></figure></p>
<p>‘assign’ in Object;//true ES5<br>Reflect.has(Object,’assign’);//true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. Reflect对象的方法与Proxy对象的方法一一对应。</div></pre></td></tr></table></figure></p>
<p>var loggedObj = new Proxy(obj, {<br>  get(target, name) {<br>    console.log(‘get’, target, name);<br>    return Reflect.get(target, name);<br>  },<br>  deleteProperty(target, name) {<br>    console.log(‘delete’ + name);<br>    return Reflect.deleteProperty(target, name);<br>  },<br>  has(target, name) {<br>    console.log(‘has’ + name);<br>    return Reflect.has(target, name);<br>  }<br>});</p>
<p>Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 ES5<br>Reflect.apply(Math.floor, undefined, [1.75]) // 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 静态方法</div><div class="line"></div><div class="line">- Reflect.apply(target,thisArg,args)</div><div class="line">- Reflect.construct(target,args)</div><div class="line">- Reflect.get(target,name,receiver)</div><div class="line">- Reflect.set(target,name,value,receiver)</div><div class="line">- Reflect.defineProperty(target,name,desc)</div><div class="line">- Reflect.deleteProperty(target,name)</div><div class="line">- Reflect.has(target,name)</div><div class="line">- Reflect.ownKeys(target)</div><div class="line">- Reflect.isExtensible(target)</div><div class="line">- Reflect.preventExtensions(target)</div><div class="line">- Reflect.getOwnPropertyDescriptor(target, name)</div><div class="line">- Reflect.getPrototypeOf(target)</div><div class="line">- Reflect.setPrototypeOf(target, prototype)</div><div class="line">实例：使用Proxy实现观察者模式</div><div class="line"></div><div class="line">&gt; 函数自动观察数据对象，一旦对象有变化函数变化便自动执行</div></pre></td></tr></table></figure></p>
<p>const queuedObservers = new Set();<br>const observe = fn =&gt; queuedObservers.add(fn);<br>const observable = obj =&gt; new Proxy(obj, {set});</p>
<p>function set(target, key, value, receiver) {<br>  const result = Reflect.set(target, key, value, receiver);<br>  queuedObservers.forEach(observer =&gt; observer());<br>  return result;<br>}<br>const person = observable({<br>  name: ‘张三’,<br>  age: 20<br>});<br>function print() {<br>  console.log(<code>${person.name}, ${person.age}</code>)<br>}<br>observe(print);<br>person.name = ‘李四’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###  Promises</div><div class="line"></div><div class="line">&gt;Promise,简而言之即存放未来才会结束的事件结果的容器。</div><div class="line"></div><div class="line">1. 特点：</div><div class="line">    1. 对象状态不受外部影响。</div><div class="line">    &gt; Promise代表一个异步操作，有三种状态：Pending(进行中)，Resolved(已完成)和</div><div class="line">    Rejected(已失败)。只有异步操作的结果可以决定当前是哪一种状态，也即是Promise名字的由来。</div><div class="line">    2. 状态改变就不会再变，任何时候都可以得到该结果。</div><div class="line">    &gt;Promise对象状态的改变有两种：从Pending变为Resolved和从Pending变为Rejected。</div><div class="line">    只要此二种情况发生就凝固了，结果不会再变。与事件event完全不同（错过了再去监听则得不到结果）</div><div class="line"></div><div class="line">*有了Promise对象即可以同步操作的流程实现异步操作，避免了回调地狱；且Promise对象提供统一接口，简化了异步操作*</div><div class="line">缺点是：</div><div class="line"></div><div class="line">- 无法取消Promise，一旦建立则立即执行；</div><div class="line">- 如无回调函数，内部抛出错误但外部无反应；</div><div class="line">- 当处于Pending时，无法得知目前进行到哪个阶段</div><div class="line">- 如某事件不断发生，stream模式则优于Promise</div><div class="line"></div><div class="line">2. 基本用法</div><div class="line"></div><div class="line">&gt; Promise对象是一个构造函数，用来生成Promise实例</div></pre></td></tr></table></figure></p>
<p>var promise = new Promise(function(resolve, reject) {<br>  if (/<em> 异步操作成功 </em>/){<br>    resolve(value);<br>  } else {<br>    reject(error);<br>  }<br>});<br>//Promise新建后就会立即执行<br>let promise = new Promise(function(resolve, reject) {<br>  console.log(‘Promise’);<br>  resolve();<br>});<br>promise.then(function() {<br>  console.log(‘Resolved.’);<br>});<br>console.log(‘Hi!’);<br>// Promise<br>// Hi!<br>// Resolved<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">实例：实现Ajax</div></pre></td></tr></table></figure></p>
<p>var getJSON = function(url) {<br>  var promise = new Promise(function(resolve, reject){<br>    var client = new XMLHttpRequest();<br>    client.open(“GET”, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = “json”;<br>    client.setRequestHeader(“Accept”, “application/json”);<br>    client.send();</p>
<pre><code>function handler() {
  if (this.readyState !== 4) {
    return;
  }
  if (this.status === 200) {
    resolve(this.response);
  } else {
    reject(new Error(this.statusText));
  }
};
</code></pre><p>  });<br>  return promise;<br>};<br>getJSON(“/posts.json”).then(function(json) {<br>  console.log(‘Contents: ‘ + json);<br>}, function(error) {<br>  console.error(‘出错了’, error);<br>});</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. Promise.prototype.then()</div></pre></td></tr></table></figure>
<p>getJSON(“/post/1.json”).then(<br>  post =&gt; getJSON(post.commentURL)<br>).then(<br>  comments =&gt; console.log(“Resolved: “, comments),<br>  err =&gt; console.log(“Rejected: “, err)<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. Promise.prototype.catch()</div></pre></td></tr></table></figure></p>
<p>// 写法一<br>var promise = new Promise(function(resolve, reject) {<br>  try {<br>    throw new Error(‘test’);<br>  } catch(e) {<br>    reject(e);<br>  }<br>});<br>promise.catch(function(error) {<br>  console.log(error);<br>});</p>
<p>// 写法二,reject方法的作用，等同于抛出错误<br>var promise = new Promise(function(resolve, reject) {<br>  reject(new Error(‘test’));<br>});<br>promise.catch(function(error) {<br>  console.log(error);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. Promise.all()</div><div class="line"></div><div class="line">&gt; 将多个Promise实例包装成一个新的实例</div></pre></td></tr></table></figure></p>
<p>//Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。<br>var p=Promise.all([p1,p2,p3]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. Promise.race()</div><div class="line">7. Promise.resolve()</div><div class="line"></div><div class="line">&gt;将现有对象转为Promise对象</div></pre></td></tr></table></figure></p>
<p>var jsPromise=Promise.resolve($.ajax(‘/whatever.json’))；<br>//将jQuery生成的deferred对象，转为一个新的Promise对象<br>Promise.resolve(‘foo’);<br>// 等价于但并不等于(异曲同工)<br>new Promise(resolve =&gt; resolve(‘foo’))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">8. Promise.reject()</div><div class="line">9. 两个附加方法：done(),finally()</div><div class="line"></div><div class="line">&gt;应用</div></pre></td></tr></table></figure></p>
<p>function timeout(duration = 0) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(resolve, duration);<br>    })<br>}</p>
<p>var p = timeout(1000).then(() =&gt; {<br>    return timeout(2000);<br>}).then(() =&gt; {<br>    throw new Error(“hmm”);<br>}).catch(err =&gt; {<br>    return Promise.all([timeout(100), timeout(200)]);<br>})</p>
<p>//promise combination<br>function fetchAsync (url, timeout, onData, onError) {<br>    …<br>}<br>let fetchPromised = (url, timeout) =&gt; {<br>    return new Promise((resolve, reject) =&gt; {<br>        fetchAsync(url, timeout, resolve, reject)<br>    })<br>}<br>Promise.all([<br>    fetchPromised(“<a href="http://backend/foo.txt" target="_blank" rel="external">http://backend/foo.txt</a>“, 500),<br>    fetchPromised(“<a href="http://backend/bar.txt" target="_blank" rel="external">http://backend/bar.txt</a>“, 500),<br>    fetchPromised(“<a href="http://backend/baz.txt" target="_blank" rel="external">http://backend/baz.txt</a>“, 500)<br>]).then((data) =&gt; {<br>    let [ foo, bar, baz ] = data<br>    console.log(<code>success: foo=${foo} bar=${bar} baz=${baz}</code>)<br>}, (err) =&gt; {<br>    console.log(<code>error: ${err}</code>)<br>})<br>//ES5<br>function fetchAsync (url, timeout, onData, onError) {<br>    …<br>}<br>function fetchAll (request, onData, onError) {<br>    var result = [], results = 0;<br>    for (var i = 0; i &lt; request.length; i++) {<br>        result[i] = null;<br>        (function (i) {<br>            fetchAsync(request[i].url, request[i].timeout, function (data) {<br>                result[i] = data;<br>                if (++results === request.length)<br>                    onData(result);<br>            }, onError);<br>        })(i);<br>    }<br>}<br>fetchAll([<br>    { url: “<a href="http://backend/foo.txt" target="_blank" rel="external">http://backend/foo.txt</a>“, timeout: 500 },<br>    { url: “<a href="http://backend/bar.txt" target="_blank" rel="external">http://backend/bar.txt</a>“, timeout: 500 },<br>    { url: “<a href="http://backend/baz.txt" target="_blank" rel="external">http://backend/baz.txt</a>“, timeout: 500 }<br>], function (data) {<br>    var foo = data[0], bar = data[1], baz = data[2];<br>    console.log(“success: foo=” + foo + “ bar=” + bar + “ baz=” + baz);<br>}, function (err) {<br>    console.log(“error: “ + err);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">More info: [MDN Promise](https://developer.mozilla.org/en-US/docs/Web//Reference/Global_Objects/Promise)</div><div class="line"></div><div class="line">###  Iterators + For..Of</div><div class="line"></div><div class="line">&gt;Iterator objects enable custom iteration like CLR IEnumerable or Java Iterable(Iterator对象启用自定义迭代，像CLR IEnumerable或Java Iterable。).  </div><div class="line">Generalize `for..in` to custom iterator-based iteration with `for..of`.  Don’t require realizing an array, enabling lazy design patterns like LINQ.</div><div class="line">JS中集合主要有Array,Object,Map,Set;需要一种统一的接口机制，来处理所有不同的数据结构</div><div class="line"></div><div class="line">Iterator应运而生，其作用有</div><div class="line">    </div><div class="line">    1. 为各种数据结构提供一个统一的简便的访问接口；</div><div class="line">    2. 使得数据结构的成员能够按某种次序排列；</div><div class="line">    3. ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供其消费</div><div class="line">遍历过程：</div><div class="line">   </div><div class="line">    1. 创建一个指针对象，指向当前数据结构的起始位置；即遍历器对象的本质是指针对象</div><div class="line">    2. 第n次调用指针对象的next方法，将指针指向nth数据成员；</div><div class="line">    3. 不断调用指针对象的next方法，直到指向数据结构的结束位置。</div></pre></td></tr></table></figure></p>
<p>var it = makeIterator([‘a’, ‘b’]);<br>it.next() // { value: “a”, done: false }<br>it.next() // { value: “b”, done: false }<br>it.next() // { value: undefined, done: true }<br>function makeIterator(array) {<br>  var nextIndex = 0;<br>  return {<br>    next: function() {<br>      return nextIndex &lt; array.length ?<br>        {value: array[nextIndex++], done: false} :<br>        {value: undefined, done: true};<br>    }<br>  };<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. 数据结构默认Iterator接口</div><div class="line"></div><div class="line">&gt; Iterator是为for...of而生的，当使用for...of时，该循环会自动寻找Iterator接口；一种数据结构只要部署了</div><div class="line">Iterator接口即为可遍历的（iterable），ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性。</div></pre></td></tr></table></figure></p>
<p>let fibonacci = {<br>  <a href="">Symbol.iterator</a> {<br>    let pre = 0, cur = 1;<br>    return {<br>      next() {<br>        [pre, cur] = [cur, pre + cur];<br>        return { done: false, value: cur }<br>      }<br>    }<br>  }<br>}<br>for (var n of fibonacci) {<br>  // truncate the sequence at 1000<br>  if (n &gt; 1000)<br>    break;<br>  console.log(n);<br>}<br>//ES5<br>var fibonacci = {<br>    next: (function () {<br>        var pre = 0, cur = 1;<br>        return function () {<br>            tmp = pre;<br>            pre = cur;<br>            cur += tmp;<br>            return cur;<br>        };<br>    })()<br>};</p>
<p>var n;<br>for (;;) {<br>    n = fibonacci.next();<br>    if (n &gt; 1000)<br>        break;<br>    console.log(n);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Iteration is based on these duck-typed interfaces (using [TypeScript](http://typescriptlang.org) type syntax for exposition only):</div></pre></td></tr></table></figure></p>
<p>TypeScript<br>interface IteratorResult {<br>  done: boolean;<br>  value: any;<br>}<br>interface Iterator {<br>  next(): IteratorResult;<br>}<br>interface Iterable {<br>  <a href="">Symbol.iterator</a>: Iterator<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 调用Iterator接口的场合</div><div class="line"></div><div class="line">- 解耦赋值</div></pre></td></tr></table></figure></p>
<p>let set = new Set().add(‘a’).add(‘b’).add(‘c’);<br>let [x,y] = set;<br>// x=’a’; y=’b’<br>let [first, …rest] = set;<br>// first=’a’; rest=[‘b’,’c’];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 扩展运算符</div></pre></td></tr></table></figure></p>
<p>let arr = [‘b’, ‘c’];<br>[‘a’, …arr, ‘d’]<br>// [‘a’, ‘b’, ‘c’, ‘d’]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- yield*</div></pre></td></tr></table></figure>
<p>let generator = function<em> () {<br>  yield 1;<br>  yield</em> [2,3,4];<br>  yield 5;<br>};<br>var iterator = generator();<br>iterator.next() // { value: 1, done: false }<br>iterator.next() // { value: 2, done: false }<br>iterator.next() // { value: 3, done: false }<br>iterator.next() // { value: 4, done: false }<br>iterator.next() // { value: 5, done: false }<br>iterator.next() // { value: undefined, done: true }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 其它</div></pre></td></tr></table></figure></p>
<p>for…of<br>Array.from()<br>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）<br>Promise.all()<br>Promise.race()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. 字符串的Iterator接口</div></pre></td></tr></table></figure></p>
<p>var someString = “hi”;<br>typeof someString[Symbol.iterator]<br>// “function”<br>var iterator = someString<a href="">Symbol.iterator</a>;<br>iterator.next()  // { value: “h”, done: false }<br>iterator.next()  // { value: “i”, done: false }<br>iterator.next()  // { value: undefined, done: true }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">5. Iterator与Generator函数</div></pre></td></tr></table></figure></p>
<p>var myIterable = {};</p>
<p>myIterable[Symbol.iterator] = function* () {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br>};<br>[…myIterable] // [1, 2, 3]<br>// 或者采用下面的简洁写法<br>let obj = {</p>
<ul>
<li><a href="">Symbol.iterator</a> {<br>yield ‘hello’;<br>yield ‘world’;<br>}<br>};<br>for (let x of obj) {<br>console.log(x);<br>}<br>// hello<br>// world<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">6. 遍历器对象的return()，throw()</div><div class="line">7. for...of循环</div><div class="line"></div><div class="line">&gt;ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。</div><div class="line"> </div><div class="line">与其它遍历语法比较</div><div class="line"></div><div class="line">- for循环</div></pre></td></tr></table></figure>
</li>
</ul>
<p>for (var index = 0; index &lt; myArray.length; index++) {<br>  console.log(myArray[index]);<br>}<br>//比较繁琐，故数组内置forEach方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- forEach</div></pre></td></tr></table></figure></p>
<p>myArray.forEach(function (value) {<br>  console.log(value);<br>});<br>//无法跳出forEach循环，break,continue也无能为力<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- for...in循环</div></pre></td></tr></table></figure></p>
<p>for (var index in myArray) {<br>  console.log(myArray[index]);<br>}<br>//可以遍历数组键名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">缺点如下：</div><div class="line"></div><div class="line">    1. 数组的键名是数字，但for...in循环是以字符串作为键名的；</div><div class="line">    2. 不仅遍历数字键名，而且还遍历手动添加的其它键，乃至原型链上的键；</div><div class="line">    3. 某些情况下，for...in循环以任意顺序遍历键名</div><div class="line">总之，for...in循环主要是为遍历对象而设计的，不适用于数组遍历</div><div class="line"></div><div class="line">- for...of循环优点如下，故首选之。</div></pre></td></tr></table></figure></p>
<p>for (var n of fibonacci) {<br>  if (n &gt; 1000)<br>    break;<br>  console.log(n);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  1. 有着for...in循环的简洁语法，但规避了其缺点；</div><div class="line">  2. 不同于forEach方法，可以与break，continue，和return配合使用；</div><div class="line">  3. 提供了遍历所有数据结构的同意操作接口。</div><div class="line"></div><div class="line">More info: [MDN for...of](https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/for...of)</div><div class="line"></div><div class="line">###  Generators</div><div class="line"></div><div class="line">1. 简介</div><div class="line"></div><div class="line">&gt; Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。语法上，Generator函数是一个状态机，</div><div class="line">封装了多个内部状态。执行之，会返回一个遍历器对象，即其除了状态机还是一个遍历器生成函数，返回的遍历器对象可依次遍历</div><div class="line">其内每个状态。</div></pre></td></tr></table></figure></p>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}<br>var hw = helloWorldGenerator();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">yield语句</div><div class="line"></div><div class="line">&gt; Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，</div><div class="line">故其实提供了一种可以暂停执行的函数，yield语句即暂停标识。</div><div class="line"></div><div class="line">遍历器next方法运行逻辑如下：</div><div class="line"></div><div class="line">  1. 遇到yield，暂停执行其后操作，并将紧跟在yield后的表达式值作为返回对象的value属性值</div><div class="line">  2. 下一次调用next方法时，继续往下执行，直到遇到下一个yield语句。</div><div class="line">  3. 如未遇yield语句，就一直运行到函数结束知道return语句为止，并将return语句后的表达式值作为返回对象的value属性值。</div><div class="line">  4. 如无return语句则返回对象的value属性值为undefined</div><div class="line"></div><div class="line">yield与return对比</div><div class="line"></div><div class="line">&gt; 同：都能返回紧跟气候的表达式值；异：每次遇到yield函数暂停执行，下次继续从此执行，而return不具位置记忆功能，</div><div class="line">一个函数里只能执行一次return但可以执行多次yield语句。Generator函数可以返回一系列的值。</div></pre></td></tr></table></figure></p>
<p>function* f() {<br>  console.log(‘执行了！’)<br>}<br>var generator = f();<br>setTimeout(function () {<br>  generator.next()<br>}, 2000);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*若f是普通函数，为变量generator赋值便执行。但如f为Generator函数，只有调用next方法时才会执行。</div><div class="line">且yield只能用在Generator函数中*</div><div class="line"></div><div class="line">2. next方法的参数</div><div class="line"></div><div class="line">&gt; yield语句本身无返回值（返回undefined），next方法可以带一个被当作上一个yield语句返回值的参数。</div><div class="line"></div><div class="line">3. for...of</div><div class="line"></div><div class="line">&gt;for...of循环可以自动遍历Generator函数时生成的Iterator对象且无需next方法。</div></pre></td></tr></table></figure></p>
<p>function<em> foo(){<br>    yield 1;<br>    yield 2;<br>    yield 3;<br>    yield 4;<br>    return 5<br>}<br>for(let v of foo()){console.log(v)} //1 2 3 4<br>//一旦next方法返回对象的done为true，for…of终止且不含该返回对象<br>//原生的JavaScript对象没有遍历接口，无法使用for…of循环，Generator函数为其加上接口完成遍历<br>function</em> fibonacci() {<br>  let [prev, curr] = [0, 1];<br>  for (;;) {<br>    [prev, curr] = [curr, prev + curr];<br>    yield curr;<br>  }<br>}<br>for (let n of fibonacci()) {<br>  if (n &gt; 1000) break;<br>  console.log(n);<br>}<br>/<em>除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，<br>它们都可以将Generator函数返回的Iterator对象，作为参数。</em>/<br>function* numbers () {<br>  yield 1<br>  yield 2<br>  return 3<br>  yield 4<br>}</p>
<p>// 扩展运算符<br>[…numbers()] // [1, 2]</p>
<p>// Array.from 方法<br>Array.from(numbers()) // [1, 2]</p>
<p>// 解构赋值<br>let [x, y] = numbers();<br>x // 1<br>y // 2</p>
<p>// for…of 循环<br>for (let n of numbers()) {<br>  console.log(n)<br>}<br>// 1<br>// 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. Generator.prototype.throw()</div><div class="line">5. Generator.prototype.return()</div><div class="line">6. yield*语句</div><div class="line">7. 作为属性的Generator函数</div></pre></td></tr></table></figure></p>
<p>let obj = {<br>  myGeneratorMethod: function* () {<br>    // ···<br>  }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">8. Generator函数的this</div><div class="line"></div><div class="line">&gt; Generator函数总是返回一个其实例且继承了其prototype对象上方法的遍历器</div></pre></td></tr></table></figure></p>
<p>function<em> g() {}<br>g.prototype.hello = function () {<br>  return ‘hi!’;<br>};<br>let obj = g();<br>obj instanceof g // true<br>obj.hello() // ‘hi!’<br>//如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。<br>function</em> g() {<br>  this.a = 11;<br>}<br>let obj = g();<br>obj.a // undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">9. Generator与状态机，前者是后者的最佳结构</div></pre></td></tr></table></figure></p>
<p>var ticking = true;<br>var clock = function() {<br>  if (ticking)<br>    console.log(‘Tick!’);<br>  else<br>    console.log(‘Tock!’);<br>  ticking = !ticking;<br>}<br>//<br>var clock = function*() {<br>  while (true) {<br>    console.log(‘Tick!’);<br>    yield;<br>    console.log(‘Tock!’);<br>    yield;<br>  }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- Generator与协程(coroutine)</div><div class="line"></div><div class="line">&gt; 协程：协作的线程或函数</div><div class="line"></div><div class="line">10. 应用</div><div class="line"></div><div class="line">- 异步操作的同步化表达</div><div class="line"></div><div class="line">```function* loadUI() &#123;</div><div class="line">     showLoadingScreen();</div><div class="line">     yield loadUIDataAsynchronously();</div><div class="line">     hideLoadingScreen();</div><div class="line">   &#125;</div><div class="line">   var loader = loadUI();</div><div class="line">   // 加载UI</div><div class="line">   loader.next()</div><div class="line">   </div><div class="line">   // 卸载UI</div><div class="line">   loader.next()</div></pre></td></tr></table></figure></p>
<ul>
<li>控制流管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(step1)</div><div class="line">  .then(step2)</div><div class="line">  .then(step3)</div><div class="line">  .then(step4)</div><div class="line">  .then(function (value4) &#123;</div><div class="line">    // Do something with value4</div><div class="line">  &#125;, function (error) &#123;</div><div class="line">    // Handle any error from step1 through step4</div><div class="line">  &#125;)</div><div class="line">  .done();</div><div class="line">  //Generator更优雅</div><div class="line">function* longRunningTask(value1) &#123;</div><div class="line">  try &#123;</div><div class="line">    var value2 = yield step1(value1);</div><div class="line">    var value3 = yield step2(value2);</div><div class="line">    var value4 = yield step3(value3);</div><div class="line">    var value5 = yield step4(value4);</div><div class="line">    // Do something with value4</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    // Handle any error from step1 through step4</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>部署Iterator接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function* iterEntries(obj) &#123;</div><div class="line">  let keys = Object.keys(obj);</div><div class="line">  for (let i=0; i &lt; keys.length; i++) &#123;</div><div class="line">    let key = keys[i];</div><div class="line">    yield [key, obj[key]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let myObj = &#123; foo: 3, bar: 7 &#125;;</div><div class="line"></div><div class="line">for (let [key, value] of iterEntries(myObj)) &#123;</div><div class="line">  console.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// foo 3</div><div class="line">// bar 7</div></pre></td></tr></table></figure>
<ol>
<li>作为数据结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function *doStuff() &#123;</div><div class="line">  yield fs.readFile.bind(null, &apos;hello.txt&apos;);</div><div class="line">  yield fs.readFile.bind(null, &apos;world.txt&apos;);</div><div class="line">  yield fs.readFile.bind(null, &apos;and-such.txt&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>function,iterator protocol</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">let fibonacci = &#123;</div><div class="line">    *[Symbol.iterator]() &#123;</div><div class="line">        let pre = 0, cur = 1</div><div class="line">        for (;;) &#123;</div><div class="line">            [ pre, cur ] = [ cur, pre + cur ]</div><div class="line">            yield cur</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">for (let n of fibonacci) &#123;</div><div class="line">    if (n &gt; 1000)</div><div class="line">        break</div><div class="line">    console.log(n)</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">var fibonacci = &#123;</div><div class="line">      next: (function () &#123;</div><div class="line">          var pre = 0, cur = 1;</div><div class="line">          return function () &#123;</div><div class="line">              tmp = pre;</div><div class="line">              pre = cur;</div><div class="line">              cur += tmp;</div><div class="line">              return cur;</div><div class="line">          &#125;;</div><div class="line">      &#125;)()</div><div class="line">  &#125;;</div><div class="line">  var n;</div><div class="line">  for (;;) &#123;</div><div class="line">      n = fibonacci.next();</div><div class="line">      if (n &gt; 1000)</div><div class="line">          break;</div><div class="line">      console.log(n);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//direct use</div><div class="line">function* range (start, end, step) &#123;</div><div class="line">    while (start &lt; end) &#123;</div><div class="line">        yield start</div><div class="line">        start += step</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let i of range(0, 10, 2)) &#123;</div><div class="line">    console.log(i) // 0, 2, 4, 6, 8</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">function range (start, end, step) &#123;</div><div class="line">    var list = [];</div><div class="line">    while (start &lt; end) &#123;</div><div class="line">        list.push(start);</div><div class="line">        start += step;</div><div class="line">    &#125;</div><div class="line">    return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var r = range(0, 10, 2);</div><div class="line">for (var i = 0; i &lt; r.length; i++) &#123;</div><div class="line">    console.log(r[i]); // 0, 2, 4, 6, 8</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//generator matching</div><div class="line">let fibonacci = function* (numbers) &#123;</div><div class="line">    let pre = 0, cur = 1</div><div class="line">    while (numbers-- &gt; 0) &#123;</div><div class="line">        [ pre, cur ] = [ cur, pre + cur ]</div><div class="line">        yield cur</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let n of fibonacci(1000))</div><div class="line">    console.log(n)</div><div class="line"></div><div class="line">let numbers = [ ...fibonacci(1000) ]</div><div class="line"></div><div class="line">let [ n1, n2, n3, ...others ] = fibonacci(1000)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//generator control-flow</div><div class="line">function async (proc, ...params) &#123;</div><div class="line">    var iterator = proc(...params)</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        let loop = (value) =&gt; &#123;</div><div class="line">            let result</div><div class="line">            try &#123;</div><div class="line">                result = iterator.next(value)</div><div class="line">            &#125;</div><div class="line">            catch (err) &#123;</div><div class="line">                reject(err)</div><div class="line">            &#125;</div><div class="line">            if (result.done)</div><div class="line">                resolve(result.value)</div><div class="line">            else if (   typeof result.value      === &quot;object&quot;</div><div class="line">                     &amp;&amp; typeof result.value.then === &quot;function&quot;)</div><div class="line">                result.value.then((value) =&gt; &#123;</div><div class="line">                    loop(value)</div><div class="line">                &#125;, (err) =&gt; &#123;</div><div class="line">                    reject(err)</div><div class="line">                &#125;)</div><div class="line">            else</div><div class="line">                loop(result.value)</div><div class="line">        &#125;</div><div class="line">        loop()</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  application-specific asynchronous builder</div><div class="line">function makeAsync (text, after) &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        setTimeout(() =&gt; resolve(text), after)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//  application-specific asynchronous procedure</div><div class="line">async(function* (greeting) &#123;</div><div class="line">    let foo = yield makeAsync(&quot;foo&quot;, 300)</div><div class="line">    let bar = yield makeAsync(&quot;bar&quot;, 200)</div><div class="line">    let baz = yield makeAsync(&quot;baz&quot;, 100)</div><div class="line">    return `$&#123;greeting&#125; $&#123;foo&#125; $&#123;bar&#125; $&#123;baz&#125;`</div><div class="line">&#125;, &quot;Hello&quot;).then((msg) =&gt; &#123;</div><div class="line">    console.log(&quot;RESULT:&quot;, msg) // &quot;Hello foo bar baz&quot;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//generator methods</div><div class="line">class Clz &#123;</div><div class="line">    * bar () &#123;</div><div class="line">        …</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let Obj = &#123;</div><div class="line">    * foo () &#123;</div><div class="line">        …</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The generator interface is (using <a href="http://typescriptlang.org" target="_blank" rel="external">TypeScript</a> type syntax for exposition only):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//TypeScript</div><div class="line">interface Generator extends Iterator &#123;</div><div class="line">    next(value?: any): IteratorResult;</div><div class="line">    throw(exception: any);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Iteration_protocols" target="_blank" rel="external">MDN Iteration protocols</a></p>
<h3 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h3><blockquote>
<p>由于JS的执行环境是单线程的，没有异步编程根本没法用。</p>
</blockquote>
<ol>
<li><p>传统方法有以下四种</p>
<ol>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ol>
</li>
<li><p>基本概念</p>
</li>
</ol>
<ul>
<li>异步：一个任务不是连续完成的，先执行第一段然后执行其它任务，等做好了准备再回头执行第二段。</li>
</ul>
<blockquote>
<p>比如读取文件并处理，第一段是向操作系统发出请求，要求读取文件；然后执行其他任务，等到操作系统<br>返回文件，再接着执行任务第二阶段（处理文件）。不连续的执行即异步，连续即同步。</p>
</blockquote>
<ul>
<li>回掉函数：JS对异步编程的实现就是通过回调函数(把任务的第二阶段单独写在一个函数里，等到重新执行该任务<br>时就直接调用这个函数callback)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;/etc/passwd&apos;, &apos;utf-8&apos;, function (err, data) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>Node 错误优先原则：执行分两个阶段，首个执行完之后任务所在的EC已经结束，在此抛出错误原来的EC已无法捕捉，<br>只能当作参数，传入第二段？？？。直观理解就是如果读取文件就出错了那还谈何打印文件，故错误优先</em></p>
<ul>
<li>Promise</li>
</ul>
<blockquote>
<p>回调函数本身无问题，问题在于多层嵌套。而Promise对象应运而生，它并非新的语法功能而是一种新的写法，将嵌套改成链式调用。<br>除此之外并无新意。且其最大的问题是代码冗余，一堆then原来的语义变得不清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</div><div class="line">readFile(fileA)</div><div class="line">.then(function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.then(function () &#123;</div><div class="line">  return readFile(fileB);</div><div class="line">&#125;)</div><div class="line">.then(function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.catch(function (err) &#123;</div><div class="line">  console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Generator函数</li>
</ol>
<blockquote>
<p>传统编程语言早有异步(多任务)的解决方案，其一叫协程(coroutine)，有点像函数又像线程。<br>协程A=》A暂停，协程B=》B交还执行权于A，yield命令是两个阶段的分界线。</p>
</blockquote>
<ul>
<li>Generator函数可以暂停执行和恢复执行，这是它封装异步任务的根本原因。除此之外还有两个特性，<br>使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next(2) // &#123; value: 2, done: true &#125;</div><div class="line">g.throw(&apos;出错了&apos;);</div><div class="line">// 出错了</div></pre></td></tr></table></figure>
<ul>
<li>异步任务的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var fetch = require(&apos;node-fetch&apos;);</div><div class="line">function* gen()&#123;</div><div class="line">  var url = &apos;https://api.github.com/users/github&apos;;</div><div class="line">  var result = yield fetch(url);</div><div class="line">  console.log(result.bio);</div><div class="line">&#125;</div><div class="line">//执行这段代码的方法如下。</div><div class="line">var g = gen();</div><div class="line">var result = g.next();</div><div class="line">result.value.then(function(data)&#123;</div><div class="line">  return data.json();</div><div class="line">&#125;).then(function(data)&#123;</div><div class="line">  g.next(data);</div><div class="line">&#125;);</div><div class="line">/*可以看到，虽然 Generator 函数将异步操作表示得很简洁，</div><div class="line">但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。*/</div></pre></td></tr></table></figure>
<ol>
<li>Thunk函数：自动执行 Generator 函数的一种方法，”传值调用”（call by value）/“传名调用”（call by name）</li>
</ol>
<h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><blockquote>
<p>ES7标准引入async函数使异步操作更加方便，本质是Generator函数的语法糖。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//Generator函数</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var readFile = function (fileName) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">    fs.readFile(fileName, function(error, data) &#123;</div><div class="line">      if (error) reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line">var gen = function* () &#123;</div><div class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div><div class="line">//async 函数</div><div class="line">var asyncReadFile = async function () &#123;</div><div class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><em>async其实就是将Generator函数的※替换成了async，将yield换成了await</em><br>改进如下：</p>
<ul>
<li>内置执行器</li>
</ul>
<figure class="highlight plain"><figcaption><span>result = asyncReadFile();```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 更好的语义</div><div class="line"></div><div class="line">async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</div><div class="line"></div><div class="line">- 更广的适用性</div><div class="line"></div><div class="line">co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值</div><div class="line">（数值、字符串和布尔值，但这时等同于同步操作）。</div><div class="line"></div><div class="line">- 返回值是Promise</div><div class="line"></div><div class="line">async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。</div><div class="line"></div><div class="line">2. 用法</div><div class="line"></div><div class="line">&gt;async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，</div><div class="line">等到异步操作完成，再接着执行函数体内后面的语句。</div></pre></td></tr></table></figure>
<p>function timeout(ms) {<br>  return new Promise((resolve) =&gt; {<br>    setTimeout(resolve, ms);<br>  });<br>}<br>async function asyncPrint(value, ms) {<br>  await timeout(ms);<br>  console.log(value)<br>}<br>asyncPrint(‘hello world’, 50);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3. 语法</div><div class="line"></div><div class="line">- 返回Promise对象</div></pre></td></tr></table></figure></p>
<p>async function f() {<br>  return ‘hello world’;<br>}<br>f().then(v =&gt; console.log(v))<br>// “hello world”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 错误处理</div></pre></td></tr></table></figure></p>
<p>async function f() {<br>  await new Promise(function (resolve, reject) {<br>    throw new Error(‘出错了’);<br>  });<br>}<br>f()<br>.then(v =&gt; console.log(v))<br>.catch(e =&gt; console.log(e))<br>// Error：出错了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4. async函数的实现原理：将 Generator 函数和自动执行器，包装在一个函数里。</div><div class="line"></div><div class="line">###  Classes</div><div class="line"></div><div class="line">&gt;ES6 classes are a simple sugar over the prototype-based OO pattern(ES6类是基于原型的（Object-Oriented）模式的简单糖).  </div><div class="line">Having a single convenient declarative form makes class patterns easier to use, </div><div class="line">and encourages interoperability(互通性).  Classes support prototype-based inheritance, super </div><div class="line">calls,instance and static methods and constructors(支持基于原型的继承，super calls，instance实例及静态方法和构造器).</div></pre></td></tr></table></figure></p>
<p>//class definition<br>class Shape {<br>    constructor (id, x, y) {<br>        this.id = id<br>        this.move(x, y)<br>    }<br>    move (x, y) {<br>        this.x = x<br>        this.y = y<br>    }<br>}<br>//ES5<br>var Shape = function (id, x, y) {<br>    this.id = id;<br>    this.move(x, y);<br>};<br>Shape.prototype.move = function (x, y) {<br>    this.x = x;<br>    this.y = y;<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">//class inheritance</div><div class="line">class Rectangle extends Shape &#123;</div><div class="line">    constructor (id, x, y, width, height) &#123;</div><div class="line">        super(id, x, y)</div><div class="line">        this.width  = width</div><div class="line">        this.height = height</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Circle extends Shape &#123;</div><div class="line">    constructor (id, x, y, radius) &#123;</div><div class="line">        super(id, x, y)</div><div class="line">        this.radius = radius</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//ES5</div><div class="line">var Rectangle = function (id, x, y, width, height) &#123;</div><div class="line">    Shape.call(this, id, x, y);</div><div class="line">    this.width  = width;</div><div class="line">    this.height = height;</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = Object.create(Shape.prototype);</div><div class="line">Rectangle.prototype.constructor = Rectangle;</div><div class="line">var Circle = function (id, x, y, radius) &#123;</div><div class="line">    Shape.call(this, id, x, y);</div><div class="line">    this.radius = radius;</div><div class="line">&#125;;</div><div class="line">Circle.prototype = Object.create(Shape.prototype);</div><div class="line">Circle.prototype.constructor = Circle;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>inheritance from expressions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">var aggregation = (baseClass, ...mixins) =&gt; &#123;</div><div class="line">    let base = class _Combined extends baseClass &#123;</div><div class="line">        constructor (...args) &#123;</div><div class="line">            super(...args)</div><div class="line">            mixins.forEach((mixin) =&gt; &#123;</div><div class="line">                mixin.prototype.initializer.call(this)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    let copyProps = (target, source) =&gt; &#123;</div><div class="line">        Object.getOwnPropertyNames(source)</div><div class="line">            .concat(Object.getOwnPropertySymbols(source))</div><div class="line">            .forEach((prop) =&gt; &#123;</div><div class="line">            if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))</div><div class="line">                return</div><div class="line">            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    mixins.forEach((mixin) =&gt; &#123;</div><div class="line">        copyProps(base.prototype, mixin.prototype)</div><div class="line">        copyProps(base, mixin)</div><div class="line">    &#125;)</div><div class="line">    return base</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Colored &#123;</div><div class="line">    initializer ()     &#123; this._color = &quot;white&quot; &#125;</div><div class="line">    get color ()       &#123; return this._color &#125;</div><div class="line">    set color (v)      &#123; this._color = v &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ZCoord &#123;</div><div class="line">    initializer ()     &#123; this._z = 0 &#125;</div><div class="line">    get z ()           &#123; return this._z &#125;</div><div class="line">    set z (v)          &#123; this._z = v &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Shape &#123;</div><div class="line">    constructor (x, y) &#123; this._x = x; this._y = y &#125;</div><div class="line">    get x ()           &#123; return this._x &#125;</div><div class="line">    set x (v)          &#123; this._x = v &#125;</div><div class="line">    get y ()           &#123; return this._y &#125;</div><div class="line">    set y (v)          &#123; this._y = v &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Rectangle extends aggregation(Shape, Colored, ZCoord) &#123;&#125;</div><div class="line">var rect = new Rectangle(7, 42)</div><div class="line">rect.z     = 1000</div><div class="line">rect.color = &quot;red&quot;</div><div class="line">console.log(rect.x, rect.y, rect.z, rect.color)</div><div class="line">//ES5</div><div class="line">var aggregation = function (baseClass, mixins) &#123;</div><div class="line">    var base = function () &#123;</div><div class="line">        baseClass.apply(this, arguments);</div><div class="line">        mixins.forEach(function (mixin) &#123;</div><div class="line">            mixin.prototype.initializer.call(this);</div><div class="line">        &#125;.bind(this));</div><div class="line">    &#125;;</div><div class="line">    base.prototype = Object.create(baseClass.prototype);</div><div class="line">    base.prototype.constructor = base;</div><div class="line">    var copyProps = function (target, source) &#123;</div><div class="line">        Object.getOwnPropertyNames(source).forEach(function (prop) &#123;</div><div class="line">            if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))</div><div class="line">                return</div><div class="line">            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop))</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    mixins.forEach(function (mixin) &#123;</div><div class="line">        copyProps(base.prototype, mixin.prototype);</div><div class="line">        copyProps(base, mixin);</div><div class="line">    &#125;);</div><div class="line">    return base;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Colored = function () &#123;&#125;;</div><div class="line">Colored.prototype = &#123;</div><div class="line">    initializer: function ()  &#123; this._color = &quot;white&quot;; &#125;,</div><div class="line">    getColor:    function ()  &#123; return this._color; &#125;,</div><div class="line">    setColor:    function (v) &#123; this._color = v; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var ZCoord = function () &#123;&#125;;</div><div class="line">ZCoord.prototype = &#123;</div><div class="line">    initializer: function ()  &#123; this._z = 0; &#125;,</div><div class="line">    getZ:        function ()  &#123; return this._z; &#125;,</div><div class="line">    setZ:        function (v) &#123; this._z = v; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Shape = function (x, y) &#123;</div><div class="line">    this._x = x; this._y = y;</div><div class="line">&#125;;</div><div class="line">Shape.prototype = &#123;</div><div class="line">    getX: function ()  &#123; return this._x; &#125;,</div><div class="line">    setX: function (v) &#123; this._x = v; &#125;,</div><div class="line">    getY: function ()  &#123; return this._y; &#125;,</div><div class="line">    setY: function (v) &#123; this._y = v; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var _Combined = aggregation(Shape, [ Colored, ZCoord ]);</div><div class="line">var Rectangle = function (x, y) &#123;</div><div class="line">    _Combined.call(this, x, y);</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = Object.create(_Combined.prototype);</div><div class="line">Rectangle.prototype.constructor = Rectangle;</div><div class="line"></div><div class="line">var rect = new Rectangle(7, 42);</div><div class="line">rect.setZ(1000);</div><div class="line">rect.setColor(&quot;red&quot;);</div><div class="line">console.log(rect.getX(), rect.getY(),rect.getZ(), rect.getColor());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>members</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Rectangle extends Shape &#123;</div><div class="line">    …</div><div class="line">    static defaultRectangle () &#123;</div><div class="line">        return new Rectangle(&quot;default&quot;, 0, 0, 100, 100)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Circle extends Shape &#123;</div><div class="line">    …</div><div class="line">    static defaultCircle () &#123;</div><div class="line">        return new Circle(&quot;default&quot;, 0, 0, 100)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var defRectangle = Rectangle.defaultRectangle()</div><div class="line">var defCircle    = Circle.defaultCircle()</div><div class="line">//ES5</div><div class="line">var Rectangle = function (id, x, y, width, height) &#123;</div><div class="line">    …</div><div class="line">&#125;;</div><div class="line">Rectangle.defaultRectangle = function () &#123;</div><div class="line">    return new Rectangle(&quot;default&quot;, 0, 0, 100, 100);</div><div class="line">&#125;;</div><div class="line">var Circle = function (id, x, y, width, height) &#123;</div><div class="line">    …</div><div class="line">&#125;;</div><div class="line">Circle.defaultCircle = function () &#123;</div><div class="line">    return new Circle(&quot;default&quot;, 0, 0, 100);</div><div class="line">&#125;;</div><div class="line">var defRectangle = Rectangle.defaultRectangle();</div><div class="line">var defCircle    = Circle.defaultCircle();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//getter/setter</div><div class="line">class Rectangle &#123;</div><div class="line">    constructor (width, height) &#123;</div><div class="line">        this._width  = width</div><div class="line">        this._height = height</div><div class="line">    &#125;</div><div class="line">    set width  (width)  &#123; this._width = width               &#125;</div><div class="line">    get width  ()       &#123; return this._width                &#125;</div><div class="line">    set height (height) &#123; this._height = height             &#125;</div><div class="line">    get height ()       &#123; return this._height               &#125;</div><div class="line">    get area   ()       &#123; return this._width * this._height &#125;</div><div class="line">&#125;</div><div class="line">var r = new Rectangle(50, 20)</div><div class="line">r.area === 1000</div><div class="line">//ES5</div><div class="line">var Rectangle = function (width, height) &#123;</div><div class="line">    this._width  = width;</div><div class="line">    this._height = height;</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = &#123;</div><div class="line">    set width  (width)  &#123; this._width = width;               &#125;,</div><div class="line">    get width  ()       &#123; return this._width;                &#125;,</div><div class="line">    set height (height) &#123; this._height = height;             &#125;,</div><div class="line">    get height ()       &#123; return this._height;               &#125;,</div><div class="line">    get area   ()       &#123; return this._width * this._height; &#125;</div><div class="line">&#125;;</div><div class="line">var r = new Rectangle(50, 20);</div><div class="line">r.area === 1000;</div></pre></td></tr></table></figure>
<ul>
<li>constructor方法</li>
</ul>
<blockquote>
<p>类的默认方法，通过new关键字生成对象实例时自动调用。一个类必须有constructor方法，如未定义默认添加。<br>默认返回实例对象(this)，完全可以指定另外一个对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    return Object.create(null);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">new Foo() instanceof Foo</div><div class="line">// false,类的构造函数不使用new是无法调用的，这点与普通构造函数的主要区别</div></pre></td></tr></table></figure>
<ul>
<li>类的实例对象</li>
</ul>
<blockquote>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//定义类</div><div class="line">class Point &#123;</div><div class="line"></div><div class="line">  constructor(x, y) &#123;</div><div class="line">    this.x = x;</div><div class="line">    this.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var point = new Point(2, 3);</div><div class="line">point.toString() // (2, 3)</div><div class="line">point.hasOwnProperty(&apos;x&apos;) // true</div><div class="line">point.hasOwnProperty(&apos;y&apos;) // true</div><div class="line">point.hasOwnProperty(&apos;toString&apos;) // false</div><div class="line">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</div><div class="line">//类的所有实例共享同一个原型对象，同ES5一样</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>不存在变量提升</li>
<li>Class表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const MyClass = class Me &#123;</div><div class="line">  getClassName() &#123;</div><div class="line">    return Me.name;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">//类名为MyClass而非Me,Me只在Class内部代码可用，指代当前类，如果内部没用到可以省略</div><div class="line">//使用class关键字可以写出立即执行的Class</div><div class="line">let person = new class &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sayName() &#123;</div><div class="line">    console.log(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;(&apos;张三&apos;);</div><div class="line"></div><div class="line">person.sayName(); // &quot;张三&quot;</div></pre></td></tr></table></figure>
<ul>
<li>私有方法</li>
</ul>
<blockquote>
<p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
</blockquote>
<ul>
<li>this指向</li>
</ul>
<blockquote>
<p>类的方法内部如含有this，默认指向类的实例。但必须小心，一旦单独使用可能报错。<br>类和模块内部默认全是严格模式，name属性总是返回紧跟在class关键字后边的类名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Logger &#123;</div><div class="line">  printName(name = &apos;there&apos;) &#123;</div><div class="line">    this.print(`Hello $&#123;name&#125;`);</div><div class="line">  &#125;</div><div class="line">  print(text) &#123;</div><div class="line">    console.log(text);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const logger = new Logger();</div><div class="line">const &#123; printName &#125; = logger;</div><div class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefine</div><div class="line">/*printName默认指向Logger实例。若将该方法提出使用，this会指向该方法运行时环境*/</div><div class="line">class Logger &#123;</div><div class="line">//构造方法中绑定this</div><div class="line">  constructor() &#123;</div><div class="line">    this.printName = this.printName.bind(this);</div><div class="line">  &#125;</div><div class="line">//箭头函数</div><div class="line">constructor() &#123;</div><div class="line">    this.printName = (name = &apos;there&apos;) =&gt; &#123;</div><div class="line">      this.print(`Hello $&#123;name&#125;`);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//使用Proxy，获取方法的时候，自动绑定this</div><div class="line">function selfish (target) &#123;</div><div class="line">  const cache = new WeakMap();</div><div class="line">  const handler = &#123;</div><div class="line">    get (target, key) &#123;</div><div class="line">      const value = Reflect.get(target, key);</div><div class="line">      if (typeof value !== &apos;function&apos;) &#123;</div><div class="line">        return value;</div><div class="line">      &#125;</div><div class="line">      if (!cache.has(value)) &#123;</div><div class="line">        cache.set(value, value.bind(target));</div><div class="line">      &#125;</div><div class="line">      return cache.get(value);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  const proxy = new Proxy(target, handler);</div><div class="line">  return proxy;</div><div class="line">&#125;</div><div class="line">const logger = selfish(new Logger());</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>class继承</li>
</ol>
<blockquote>
<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class ColorPoint extends Point&#123;</div><div class="line"> constructor(x, y, color) &#123;</div><div class="line">    super(x, y); // 调用父类的constructor(x, y)</div><div class="line">    this.color = color;</div><div class="line">  &#125;</div><div class="line">  toString() &#123;</div><div class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述实例中constructor和toString方法都出现了super，表示父类的构造函数，用来新建父类this对象。<br>子类必须在constructor方法中调用super方法，否则新建实例报错。只因子类无自身this对象，只有继承父类的然后<br>加工。如不调用super方法子类就得不到this对象。</p>
<blockquote>
<p>ES5的继承实例先造子类实例对象this，然后将父类的方法添加到this上。ES6则完全不同，先造父类实例对象this，然后<br>再用子类构造函数修改this。</p>
</blockquote>
<p>类的prototype属性和<strong>proto</strong>属性</p>
<blockquote>
<p>多数浏览器ES5实现之中，每个对象都有一个指向构造函数的<strong>proto</strong>属性。Class作为构造函数的语法糖，同时拥有prototype和<br><strong>proto</strong>属性，故同时存在两条继承链。作为一个对象，子类B的原型（<strong>proto</strong>属性）是父类；作为构造函数，子类B的原型(prototype<br>属性)是父类的实例。</p>
<ul>
<li>子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类；</li>
<li>子类prototype属性的<strong>proto</strong>属性，表示方法的继承，指向父类的prototype属性。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">&#125;</div><div class="line">class B extends A &#123;</div><div class="line">&#125;</div><div class="line">B.__proto__ === A // true</div><div class="line">B.prototype.__proto__ === A.prototype // true</div><div class="line">//原理</div><div class="line">// B的实例继承A的实例</div><div class="line">Object.setPrototypeOf(B.prototype, A.prototype);</div><div class="line">const b = new B();</div><div class="line">// B的实例继承A的静态属性</div><div class="line">Object.setPrototypeOf(B, A);</div><div class="line"></div><div class="line">Object.setPropertypeOf=function (obj,proto)&#123;</div><div class="line">    obj.__proto__=proto;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Extends 的继承目标</li>
</ul>
<p>extends关键字后边可以继承多种类型的值，只要被继承者有prototype属性</p>
<ol>
<li>子类继承Object类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A extends Object&#123;&#125;</div><div class="line">A.__proto__===Objecdt;//true</div><div class="line">A.prototype.__proto__=Object.prototype;//true</div><div class="line">//A即构造函数Object的复制，A的实例即Object的实例</div></pre></td></tr></table></figure>
<ol>
<li>不存在任何继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">A.__proto__===Function.prototype;//true</div><div class="line">A.prototype.__proto__===Object.prototype;//true</div><div class="line">//A作为一个基类(不存在任何继承)，即普通函数故直接继承Function.prototype。</div><div class="line">但当A调用后返回一个空对象(Object实例)，故A.prototype.__proto__指向构造函数(Object)的prototype属性。</div></pre></td></tr></table></figure>
<ol>
<li>子类集成null</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A extends null&#123;&#125;</div><div class="line">A.__proto__===Function.prototype;//true</div><div class="line">A.prototype.__proto__===undefined;//true</div><div class="line">//实际上是</div><div class="line">class C extends null &#123;</div><div class="line">  constructor() &#123; return Object.create(null); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>Object.getPropertyOf():从子类获取父类</p>
</li>
<li><p>super关键字</p>
</li>
</ul>
<blockquote>
<p>既可以当函数使用也可以当对象使用，但用法完全不同。</p>
</blockquote>
<ol>
<li>作为函数，代表父类的构造函数,只能用在子类的构造函数中。(ES6规定子类构造函数必须执行一次super函数)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">class B extends A&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/*super虽然代表了父类A的构造函数，但返回的是子类的实例(super内this指向B)，</div><div class="line">此时super()相当于A.prototype.constructor.call(this).*/</div></pre></td></tr></table></figure>
<ol>
<li>作为对象，指向父类的原型对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    p()&#123;</div><div class="line">        return 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class B extends A&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        super();</div><div class="line">        console.log(super.p());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let b=new B();//2</div><div class="line">//ES6 规定，通过super调用父类的方法时，super会绑定子类的this。因此super就是this</div><div class="line">class A &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    this.x = 1;</div><div class="line">  &#125;</div><div class="line">&#125;   </div><div class="line">class B extends A &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super();</div><div class="line">    this.x = 2;</div><div class="line">    super.x = 3;</div><div class="line">    console.log(super.x); // undefined,A.prototype.x</div><div class="line">    console.log(this.x); // 3</div><div class="line">  &#125;</div><div class="line">&#125;  </div><div class="line">let b = new B();</div><div class="line">/*使用super的时候，必须显式指定是作为函数、还是作为对象;由于对象都是继承其它对象的，</div><div class="line">所以可以在任意对象中使用super关键字*/</div><div class="line">var obj = &#123;</div><div class="line">  toString() &#123;</div><div class="line">    return &quot;MyObject: &quot; + super.toString();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.toString(); // MyObject: [object Object]</div></pre></td></tr></table></figure>
<ul>
<li>实例的<strong>proto</strong>属性</li>
</ul>
<blockquote>
<p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>prototype</strong>属性。<br>即子类原型的原型是父类的原型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var p1 = new Point(2, 3);</div><div class="line">var p2 = new ColorPoint(2, 3, &apos;red&apos;);</div><div class="line">p2.__proto__ === p1.__proto__ // false</div><div class="line">p2.__proto__.__proto__ === p1.__proto__ // true,ColorPoint继承了Point</div><div class="line">//通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为</div><div class="line">p2.__proto__.__proto__.printName = function () &#123;</div><div class="line">  console.log(&apos;Ha&apos;);</div><div class="line">&#125;;</div><div class="line">p1.printName() // &quot;Ha&quot;</div></pre></td></tr></table></figure>
<ol>
<li>原生构造函数的继承—无法继承</li>
</ol>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<ol>
<li>Class的取值函数getter和存值函数setter<br>存值函数和取值函数是设置在属性的descriptor对象上的,与ES5完全一致。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">lass MyClass &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">  get prop() &#123;</div><div class="line">    return &apos;getter&apos;;</div><div class="line">  &#125;</div><div class="line">  set prop(value) &#123;</div><div class="line">    console.log(&apos;setter: &apos;+value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let inst = new MyClass();</div><div class="line">inst.prop = 123;</div><div class="line">// setter: 123</div><div class="line">inst.prop</div><div class="line">// &apos;getter&apos;</div><div class="line">//prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</div></pre></td></tr></table></figure>
<ol>
<li>Class的Generator方法</li>
</ol>
<blockquote>
<p>某个方法之前加上*即为Generator函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">  constructor(...args) &#123;</div><div class="line">    this.args = args;</div><div class="line">  &#125;</div><div class="line">  * [Symbol.iterator]() &#123;</div><div class="line">    for (let arg of this.args) &#123;</div><div class="line">      yield arg;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>Class的静态方法</li>
</ol>
<blockquote>
<p>类相当于实例的原型，故类中定义的方法都会被实例继承。若在一个方法上加上static关键字<br>则表示该方法不会被实例继承，而是直接通过类来调用，但可以被子类继承，也可以通过super对象调用所谓的‘静态方法’。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    static classMethod()&#123;</div><div class="line">        return &apos;hello&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Foo.classMethod();//&apos;hello&apos;</div><div class="line">var foo=new Foo();</div><div class="line">foo.classMethod();// TypeError: foo.classMethod is not a function</div><div class="line"> class Bar extends Foo &#123;</div><div class="line">   static classMethod() &#123;</div><div class="line">     return super.classMethod() + &apos;, too&apos;;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ol>
<li>Class的静态属性和实例属性</li>
</ol>
<blockquote>
<p>静态属性指Class本身的属性Class.propname,而非定义在实例对象this上的属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Foo&#123;</div><div class="line">    prop:2//无效</div><div class="line">    static prop:2//无效</div><div class="line">&#125;</div><div class="line">Foo.prop=1;</div><div class="line">Foo.prop;//1,只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</div></pre></td></tr></table></figure>
<p>ES7提议，Babel支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//类的实例属性可以用等式，写入类的定义之中。</div><div class="line">class MyClass &#123;</div><div class="line">  myProp = 42;</div><div class="line">  constructor() &#123;</div><div class="line">    console.log(this.myProp); // 42</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">/*定义实例属性，之前只能写在类的constructor方法里面，如今可以不在。</div><div class="line">为了可读性的目的，对于那些在constructor里面已经定义的实例属性，</div><div class="line">新写法允许直接列出。*/</div><div class="line">class ReactCounter extends React.Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    count: 0</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">//类的静态属性，只需在实例属性前加上static关键字</div><div class="line">class MyClass &#123;</div><div class="line">  static myStaticProp = 42;</div><div class="line">  constructor() &#123;</div><div class="line">    console.log(MyClass.myStaticProp); // 42</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ol>
<li>类的私有属性—提案，为class加了私有属性。方法是在属性名之前，使用#表示。</li>
</ol>
<blockquote>
<p>之所以引入一个新的#表示私有属性而非private关键字是因为JS是一门动态语言，使用独立符号似乎是唯一<br>可靠方法，能够准确地区分属性之公私。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  #x;</div><div class="line">  constructor(x = 0) &#123;</div><div class="line">    #x = +x;</div><div class="line">  &#125;</div><div class="line">  get x() &#123; return #x &#125;</div><div class="line">  set x(value) &#123; #x = +value &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>new.target属性—确定构造函数如何调用的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">  if (new.target !== undefined) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new Error(&apos;必须使用new生成实例&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 另一种写法</div><div class="line">function Person(name) &#123;</div><div class="line">  if (new.target === Person) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new Error(&apos;必须使用new生成实例&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var person = new Person(&apos;张三&apos;); // 正确</div><div class="line">var notAPerson = Person.call(person, &apos;张三&apos;);  // 报错</div><div class="line">//Class内调用new.target返回当前Class</div></pre></td></tr></table></figure>
<ol>
<li>Mixin模式的实现<blockquote>
<p>将多个类的接口混入(mix in)另一个类</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function mix(...mixins) &#123;</div><div class="line">  class Mix &#123;&#125;</div><div class="line"></div><div class="line">  for (let mixin of mixins) &#123;</div><div class="line">    copyProperties(Mix, mixin);</div><div class="line">    copyProperties(Mix.prototype, mixin.prototype);</div><div class="line">  &#125;</div><div class="line">  return Mix;</div><div class="line">&#125;</div><div class="line">function copyProperties(target, source) &#123;</div><div class="line">  for (let key of Reflect.ownKeys(source)) &#123;</div><div class="line">    if ( key !== &quot;constructor&quot;</div><div class="line">      &amp;&amp; key !== &quot;prototype&quot;</div><div class="line">      &amp;&amp; key !== &quot;name&quot;</div><div class="line">    ) &#123;</div><div class="line">      let desc = Object.getOwnPropertyDescriptor(source, key);</div><div class="line">      Object.defineProperty(target, key, desc);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>More info: <a href="https://developer.mozilla.org/en/docs/Web//Reference/Classes" target="_blank" rel="external">MDN Classes</a></p>
<h3 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h3><blockquote>
<p>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。</p>
</blockquote>
<ol>
<li>类的修饰</li>
<li>方法的修饰</li>
<li>不能用于函数</li>
<li>core-decorators.js</li>
<li>使用修饰器实现自动发布事件</li>
<li>mixin混入</li>
<li>trait</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function factorial(n, acc = 1) &#123;</div><div class="line">    &apos;use strict&apos;;</div><div class="line">    if (n &lt;= 1) return acc;</div><div class="line">    return factorial(n - 1, n * acc);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Stack overflow in most implementations today,</div><div class="line">// but safe on arbitrary inputs in ES6</div><div class="line">factorial(100000)</div></pre></td></tr></table></figure>
<h3 id="Modules模块"><a href="#Modules模块" class="headerlink" title="Modules模块"></a>Modules模块</h3><blockquote>
<p>Language-level support for modules for component definition.<br>Codifies patterns from popular  module loaders (AMD, CommonJS).<br>Runtime behaviour defined by a host-defined default loader.<br>Implicitly async model – no code executes until requested modules are available and processed.<br>组件定义的模块的语言级支持。编译流行模块加载程序（AMD，COMMONJS）的模式。<br>由主机定义的默认加载器定义的运行时行为。隐式异步模型 - 在请求的模块可用并处理之前，不执行代码。<br>ES6在语言标准层面上实现了模块功能，完全可以取代CommonJS，AMD规范，成为B/S通用的模块解决方案。<br>模块化设计思想是尽量静态化，使得编译时就能确定模块的依赖关系以及输入和输出的变量。</p>
</blockquote>
<p>好处：</p>
<ol>
<li>不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式；</li>
<li>将来浏览器的新API就能用模块格式提供，不必做成全局变量或者navigator对象的属性；</li>
<li>不再需要对象作为命名空间(如Math)，未来这些功能可以通过模块提供。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// lib/math.js</div><div class="line">export function sum(x, y) &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line">export var pi = 3.141593;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">import * as math from &quot;lib/math&quot;;</div><div class="line">alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// otherApp.js</div><div class="line">import &#123;sum, pi&#125; from &quot;lib/math&quot;;</div><div class="line">alert(&quot;2π = &quot; + sum(pi, pi));</div></pre></td></tr></table></figure>
<p>Some additional features include <code>export default</code> and <code>export *</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// lib/mathplusplus.js</div><div class="line">export * from &quot;lib/math&quot;;</div><div class="line">export var e = 2.71828182846;</div><div class="line">export default function(x) &#123;</div><div class="line">    return Math.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">import ln, &#123;pi, e&#125; from &quot;lib/mathplusplus&quot;;</div><div class="line">alert(&quot;2π = &quot; + ln(e)*pi*2);</div></pre></td></tr></table></figure>
<ol>
<li>严格模式—自动设定为’use strict’</li>
<li>export,export default及import命令</li>
<li>模块的整体加载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import * as circle from &apos;./circle&apos;;</div><div class="line">console.log(&apos;圆面积：&apos; + circle.area(4));</div><div class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</div><div class="line">//注意：整体加载的模块所在的那个对象是可以静态分析的，不允许运行时改变</div><div class="line">circle.foo = &apos;hello&apos;;//不允许</div></pre></td></tr></table></figure>
<ol>
<li>模块的继承</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// circleplus.js</div><div class="line"></div><div class="line">export * from &apos;circle&apos;;</div><div class="line">export var e = 2.71828182846;</div><div class="line">export default function(x) &#123;</div><div class="line">  return Math.exp(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>import():按需加载，条件加载，动态模块路径</li>
</ol>
<p>More MDN info: <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/import" target="_blank" rel="external">import statement</a>, <a href="https://developer.mozilla.org/en-US/docs/Web//Reference/Statements/export" target="_blank" rel="external">export statement</a></p>
<h3 id="Module-Loaders"><a href="#Module-Loaders" class="headerlink" title="Module Loaders"></a>Module Loaders</h3><ol>
<li>浏览器加载</li>
</ol>
<ul>
<li>传统方法：script引入</li>
</ul>
<blockquote>
<p>默认情况下，B是同步加载JS脚本，即渲染引擎遇到script就停下来直到脚本执行完，再继续向下循环。<br>如果是外部脚本，还必须加入脚本下载时间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//defer:整个页面渲染结束才执行，渲染完再执行；async:一旦下载完，渲染引擎就会中断渲染，执行此脚本后再继续渲染，下载完就执行。</div><div class="line">&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<ul>
<li>加载规则：ES6模块也可以使用script标签，但要加入type=’module’属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;</div><div class="line"> import utils from &quot;./utils.js&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!-- 等同于 --&gt;</div><div class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>对于外部模块脚本，注意以下几点：</p>
<pre><code>1. 代码在模块作用域之中运行而非全局，模块内顶层变量外部不可见
2. 模块脚本自动采用严格模式，无论声明与否；
3. 模块中可以使用import及export命令处理模块
4. 模块中，顶层的this关键字返回undefined而非window
5. 同一个模块如果加载多次，只执行一次
</code></pre><figure class="highlight plain"><figcaption><span>isNotModuleScript = this !== undefined;//侦测是否在ES6模块中```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2. ES6模块与CommonJS模块差异</div><div class="line"></div><div class="line">两大重大差异：</div><div class="line"></div><div class="line">- 前者输出的是值的引用，后者是拷贝</div><div class="line">- 前者是编译时输出接口，后者是运行时加载</div><div class="line"></div><div class="line">&gt; CommonJS加载的是一个在脚本运行才会生成的对象，而ES6不是对象，其对外接口只是一种静态定义，</div><div class="line">在代码静态解析阶段就会生成。ES6的import有点像Unix系统的符号连接，原始值变了，import加载的值也变。</div><div class="line">故ES6模块是动态引用，不会缓存值，模块里的变量绑定其所在的模块。</div><div class="line"></div><div class="line">3. Node加载</div><div class="line"></div><div class="line">&gt;Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。</div><div class="line">目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。</div><div class="line"></div><div class="line">在静态分析阶段，一个模块脚本若含import或export语句，Node便认为其为ES6模块，否则就是CommonJS模块。</div><div class="line">若不输出任何接口但希望被认为是ES6模块，可在脚本中加入```export &#123;&#125;;//不输出任何脚本的ES6标准写法</div></pre></td></tr></table></figure>
<p>ES6模块中顶层的this指向undefined；而CommonJS模块的顶层this指向当前模块。</p>
<ul>
<li>import 命令加载CommonJS模块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// a.js  CommonJS模块</div><div class="line">module.exports = &#123;</div><div class="line">  foo: &apos;hello&apos;,</div><div class="line">  bar: &apos;world&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 等同于</div><div class="line">export default &#123;</div><div class="line">  foo: &apos;hello&apos;,</div><div class="line">  bar: &apos;world&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>require命令加载ES6模块<blockquote>
<p>采用require命令加载 ES6 模块时，ES6 模块的所有输出接口，会成为输入对象的属性。</p>
</blockquote>
</li>
</ul>
<ol>
<li>循环加载circular dependency</li>
</ol>
<ul>
<li>CommonJS模块加载原理<h3 id="Subclassable-Built-ins内嵌对象的亚类"><a href="#Subclassable-Built-ins内嵌对象的亚类" class="headerlink" title="Subclassable Built-ins内嵌对象的亚类"></a>Subclassable Built-ins内嵌对象的亚类</h3><blockquote>
<p>In ES6, built-ins like <code>Array</code>, <code>Date</code> and DOM <code>Element</code>s can be subclassed.<br>Object construction for a function named <code>Ctor</code> now uses two-phases (both virtually dispatched):</p>
</blockquote>
</li>
<li>Call <code>Ctor[@@create]</code> to allocate the object, installing any special behavior</li>
<li>Invoke constructor on new instance to initialize<br>The known <code>@@create</code> symbol is available via <code>Symbol.create</code>.  Built-ins now expose their <code>@@create</code> explicitly.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Pseudo-code of Array</div><div class="line">class Array &#123;</div><div class="line">    constructor(...args) &#123; /* ... */ &#125;</div><div class="line">    static [Symbol.create]() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// User code of Array subclass</div><div class="line">class MyArray extends Array &#123;</div><div class="line">    constructor(...args) &#123; super(...args); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Two-phase &apos;new&apos;:</div><div class="line">// 1) Call @@create to allocate object</div><div class="line">// 2) Invoke constructor on new instance</div><div class="line">var arr = new MyArray();</div><div class="line">arr[1] = 12;</div><div class="line">arr.length == 2</div></pre></td></tr></table></figure>
<h3 id="typed-arrays"><a href="#typed-arrays" class="headerlink" title="typed arrays"></a>typed arrays</h3><blockquote>
<p>支持任意基于字节的数据结构来实现网络协议，加密算法，文件格式操作等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Example &#123;</div><div class="line">    constructor (buffer = new ArrayBuffer(24)) &#123;</div><div class="line">        this.buffer = buffer</div><div class="line">    &#125;</div><div class="line">    set buffer (buffer) &#123;</div><div class="line">        this._buffer    = buffer</div><div class="line">        this._id        = new Uint32Array (this._buffer,  0,  1)</div><div class="line">        this._username  = new Uint8Array  (this._buffer,  4, 16)</div><div class="line">        this._amountDue = new Float32Array(this._buffer, 20,  1)</div><div class="line">    &#125;</div><div class="line">    get buffer ()     &#123; return this._buffer       &#125;</div><div class="line">    set id (v)        &#123; this._id[0] = v           &#125;</div><div class="line">    get id ()         &#123; return this._id[0]        &#125;</div><div class="line">    set username (v)  &#123; this._username[0] = v     &#125;</div><div class="line">    get username ()   &#123; return this._username[0]  &#125;</div><div class="line">    set amountDue (v) &#123; this._amountDue[0] = v    &#125;</div><div class="line">    get amountDue ()  &#123; return this._amountDue[0] &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let example = new Example()</div><div class="line">example.id = 7</div><div class="line">example.username = &quot;John Doe&quot;</div><div class="line">example.amountDue = 42.0</div></pre></td></tr></table></figure>
<h3 id="internationalization-localization"><a href="#internationalization-localization" class="headerlink" title="internationalization-localization"></a>internationalization-localization</h3><blockquote>
<p>collation整理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var list = [ &quot;ä&quot;, &quot;a&quot;, &quot;z&quot; ]</div><div class="line">var l10nDE = new Intl.Collator(&quot;de&quot;)</div><div class="line">var l10nSV = new Intl.Collator(&quot;sv&quot;)</div><div class="line">l10nDE.compare(&quot;ä&quot;, &quot;z&quot;) === -1</div><div class="line">l10nSV.compare(&quot;ä&quot;, &quot;z&quot;) === +1</div><div class="line">console.log(list.sort(l10nDE.compare)) // [ &quot;a&quot;, &quot;ä&quot;, &quot;z&quot; ]</div><div class="line">console.log(list.sort(l10nSV.compare)) // [ &quot;a&quot;, &quot;z&quot;, &quot;ä&quot; ]</div></pre></td></tr></table></figure>
<blockquote>
<p>number formatting</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var l10nEN = new Intl.NumberFormat(&quot;en-US&quot;)</div><div class="line">var l10nDE = new Intl.NumberFormat(&quot;de-DE&quot;)</div><div class="line">l10nEN.format(1234567.89) === &quot;1,234,567.89&quot;</div><div class="line">l10nDE.format(1234567.89) === &quot;1.234.567,89&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>current formatting</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var l10nUSD = new Intl.NumberFormat(&quot;en-US&quot;, &#123; style: &quot;currency&quot;, currency: &quot;USD&quot; &#125;)</div><div class="line">var l10nGBP = new Intl.NumberFormat(&quot;en-GB&quot;, &#123; style: &quot;currency&quot;, currency: &quot;GBP&quot; &#125;)</div><div class="line">var l10nEUR = new Intl.NumberFormat(&quot;de-DE&quot;, &#123; style: &quot;currency&quot;, currency: &quot;EUR&quot; &#125;)</div><div class="line">l10nUSD.format(100200300.40) === &quot;$100,200,300.40&quot;</div><div class="line">l10nGBP.format(100200300.40) === &quot;£100,200,300.40&quot;</div><div class="line">l10nEUR.format(100200300.40) === &quot;100.200.300,40 €&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>date/time formating</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var l10nEN = new Intl.DateTimeFormat(&quot;en-US&quot;)</div><div class="line">var l10nDE = new Intl.DateTimeFormat(&quot;de-DE&quot;)</div><div class="line">l10nEN.format(new Date(&quot;2015-01-02&quot;)) === &quot;1/2/2015&quot;</div><div class="line">l10nDE.format(new Date(&quot;2015-01-02&quot;)) === &quot;2.1.2015&quot;</div></pre></td></tr></table></figure>
<h3 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h3><blockquote>
<p>SIMD（发音/sim-dee/）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。<br>它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。<br>与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>
</blockquote>
<h3 id="Good-Practise"><a href="#Good-Practise" class="headerlink" title="Good Practise"></a>Good Practise</h3><ol>
<li><p>块级作用域</p>
<ol>
<li>let取代var</li>
<li>全局常量和线程安全<br>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量</li>
</ol>
</li>
<li>字符串：``</li>
<li>解耦赋值：首选</li>
<li>对象：单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</li>
<li>数组：使用扩展运算符配合Array.from方法</li>
<li>函数：</li>
<li>Map结构：区分Object和Map，只有模拟现实世界的实体对象采用Object。若是键值对结构首选Map</li>
<li>Class :首选</li>
<li>模块：import取代require</li>
<li>EsLint使用</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="#参考链接"></a>#参考链接</h3><p><a href="https://github.com/lukehoban/es6features#readme" target="_blank" rel="external">https://github.com/lukehoban/es6features#readme</a><br><a href="http://es6-features.org/#Constants" target="_blank" rel="external">http://es6-features.org/#Constants</a><br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/yanlee26" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 Yan Li<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>